{"version":3,"file":"UNSAFE_ConveyorBelt.js","sources":["../../src/UNSAFE_ConveyorBelt/ConveyorBelt.tsx"],"sourcesContent":["import { ComponentChildren } from 'preact';\nimport { useEffect, useRef, useState, useCallback } from 'preact/hooks';\nimport { Button } from '../UNSAFE_Button';\nimport { ChevronLeft } from '../UNSAFE_RedwoodIcons/ChevronLeft';\nimport { ChevronRight } from '../UNSAFE_RedwoodIcons/ChevronRight';\nimport { classNames as clsx } from '../utils/UNSAFE_classNames';\nimport { styles } from './themes/ConveyorBeltStyles.css';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { xUnits } from '../UNSAFE_Theme';\n\nexport interface ConveyorBeltProps {\n  /**\n   * ConveyorBelt Component content\n   */\n  children?: ComponentChildren;\n  /**\n   * Sets the number of pixels that an element's content is scrolled from its initial position.\n   */\n  scrollPosition?: number;\n  /**\n   * Callback that is executed every time conveyor belt is scrolled and the scroll position is changed.\n   * @param value The value is the new scroll position of the conveyor belt.\n   * @returns\n   */\n  onScrollPositionChanged?: (value?: number) => void;\n  /**\n   * Indicates whether overflow content arrows are visible or hidden.\n   * \"auto\" show overflow arrows on desktop, hide on mobile.\n   * \"visible\" always show overflow arrows.\n   * \"hidden\" never show overflow arrows.\n   */\n  arrowVisibility?: 'auto' | 'visible' | 'hidden';\n}\n\n/**\n * Helper function to determine whether the current device is a mobile device\n * @returns true if runnning on a mobile device, false otherwise\n */\nfunction isMobile() {\n  const deviceType = getClientHints().deviceType;\n  return deviceType === 'phone' || deviceType === 'tablet';\n}\n\nfunction scrollPrevious(\n  direction: 'ltr' | 'rtl',\n  overflowContainer?: HTMLDivElement | null,\n  scrollAmount?: number\n) {\n  if (overflowContainer && scrollAmount) {\n    if (direction === 'ltr') {\n      overflowContainer.scrollTo({\n        left: overflowContainer.scrollLeft - scrollAmount\n      });\n    } else {\n      overflowContainer.scrollTo({\n        left: overflowContainer.scrollLeft + scrollAmount\n      });\n    }\n  }\n}\n\nfunction scrollNext(\n  direction: 'ltr' | 'rtl',\n  overflowContainer?: HTMLDivElement | null,\n  scrollAmount?: number\n) {\n  if (overflowContainer && scrollAmount) {\n    if (direction === 'ltr') {\n      overflowContainer.scrollTo({\n        left: overflowContainer.scrollLeft + scrollAmount,\n        behavior: 'smooth'\n      });\n    } else {\n      overflowContainer.scrollTo({\n        left: overflowContainer.scrollLeft - scrollAmount,\n        behavior: 'smooth'\n      });\n    }\n  }\n}\n/**\n * The Conveyor belt component is a container element that manages\n * overflow for its child elements and allows scrolling among them\n */\nexport const ConveyorBelt = ({\n  children,\n  scrollPosition,\n  onScrollPositionChanged,\n  arrowVisibility = 'auto'\n}: ConveyorBeltProps) => {\n  const [canPaginateNext, setCanPaginateNext] = useState(false);\n  const [canPaginatePrevious, setCanPaginatePrevious] = useState(false);\n  const overflowContainerRef = useRef<HTMLDivElement | null>(null);\n  const contentContainerRef = useRef<HTMLDivElement | null>(null);\n  const nextButtonContainerRef = useRef<HTMLDivElement | null>(null);\n  const prevButtonContainerRef = useRef<HTMLDivElement | null>(null);\n  const baseRef = useRef<HTMLDivElement | null>(null);\n  const leftRef = useRef<HTMLDivElement | null>(null);\n  const rightRef = useRef<HTMLDivElement | null>(null);\n  const observerRef = useRef<any>(null);\n  const { direction } = useUser();\n  const [buttonsHidden, setButtonsHidden] = useState(\n    (isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden'\n  );\n\n  const scrollEndHandler = useCallback(() => {\n    if (onScrollPositionChanged) onScrollPositionChanged(overflowContainerRef.current?.scrollLeft);\n  }, [onScrollPositionChanged]);\n\n  useEffect(() => {\n    setButtonsHidden((isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden');\n  }, [arrowVisibility]);\n\n  useEffect(() => {\n    if (!overflowContainerRef.current) return;\n    overflowContainerRef.current.scrollTo({\n      left: scrollPosition\n    });\n  }, [scrollPosition]);\n\n  useEffect(() => {\n    const overflowContainer = overflowContainerRef.current;\n    const leftGuard = leftRef.current;\n    const rightGuard = rightRef.current;\n\n    if (overflowContainer && leftGuard && rightGuard) {\n      if (!buttonsHidden) {\n        observerRef.current = new IntersectionObserver(\n          (entries) => {\n            entries.forEach((entry) => {\n              if (entry.target.getAttribute('data-intersection-id') === 'left') {\n                setCanPaginatePrevious(!entry.isIntersecting);\n              } else {\n                setCanPaginateNext(!entry.isIntersecting);\n              }\n            });\n          },\n          {\n            root: overflowContainer\n          }\n        );\n        observerRef.current.observe(leftGuard);\n        observerRef.current.observe(rightGuard);\n      }\n      overflowContainer.addEventListener('scrollend', scrollEndHandler);\n    }\n\n    // Clean-up\n    return () => {\n      if (!overflowContainer) return;\n      overflowContainer.removeEventListener('scrollend', scrollEndHandler);\n      observerRef.current.unobserve(leftGuard);\n      observerRef.current.unobserve(rightGuard);\n    };\n  }, [buttonsHidden, scrollEndHandler]);\n\n  return (\n    <div ref={baseRef} className={clsx([styles.baseStyle])}>\n      {canPaginatePrevious && !buttonsHidden && (\n        <div\n          aria-hidden={true}\n          ref={prevButtonContainerRef}\n          class={clsx([\n            styles.buttonContainer,\n            direction === 'ltr' ? styles.previousButton : styles.nextButton\n          ])}>\n          <TabbableModeContext.Provider value={{ isTabbable: false }}>\n            <Button\n              startIcon={direction === 'ltr' ? <ChevronLeft /> : <ChevronRight />}\n              variant=\"borderless\"\n              onAction={() =>\n                scrollPrevious(\n                  direction,\n                  overflowContainerRef.current,\n                  overflowContainerRef.current?.clientWidth\n                )\n              }\n            />\n          </TabbableModeContext.Provider>\n        </div>\n      )}\n      <div\n        style={{\n          clipPath: direction === 'ltr' ? `inset(0rem ${canPaginateNext ? xUnits(12) : '0rem'} 0rem ${\n            canPaginatePrevious ? xUnits(12) : 0\n          })` : `inset(0rem ${canPaginatePrevious ? xUnits(12) : '0rem'} 0rem ${\n            canPaginateNext ? xUnits(12) : 0\n          })`\n        }}\n        className={styles.overflowContainer}\n        ref={overflowContainerRef}>\n        <div className={styles.contentContainer} ref={contentContainerRef}>\n          <div data-intersection-id=\"left\" ref={leftRef} style={{ minWidth: 1 }} />\n          {children}\n          <div data-intersection-id=\"right\" ref={rightRef} style={{ minWidth: 1 }} />\n        </div>\n      </div>\n      {canPaginateNext && !buttonsHidden && (\n        <div\n          aria-hidden={true}\n          ref={nextButtonContainerRef}\n          class={clsx([\n            styles.buttonContainer,\n            direction === 'ltr' ? styles.nextButton : styles.previousButton\n          ])}>\n          <TabbableModeContext.Provider value={{ isTabbable: false }}>\n            <Button\n              startIcon={direction === 'ltr' ? <ChevronRight /> : <ChevronLeft />}\n              variant=\"borderless\"\n              onAction={() =>\n                scrollNext(\n                  direction,\n                  overflowContainerRef.current,\n                  overflowContainerRef.current?.clientWidth\n                )\n              }\n            />\n          </TabbableModeContext.Provider>\n        </div>\n      )}\n    </div>\n  );\n};\n"],"names":["isMobile","deviceType","getClientHints","children","scrollPosition","onScrollPositionChanged","arrowVisibility","canPaginateNext","setCanPaginateNext","useState","canPaginatePrevious","setCanPaginatePrevious","overflowContainerRef","useRef","contentContainerRef","nextButtonContainerRef","prevButtonContainerRef","baseRef","leftRef","rightRef","observerRef","direction","useUser","buttonsHidden","setButtonsHidden","scrollEndHandler","useCallback","current","scrollLeft","useEffect","scrollTo","left","overflowContainer","leftGuard","rightGuard","IntersectionObserver","entries","forEach","entry","target","getAttribute","isIntersecting","root","observe","addEventListener","removeEventListener","unobserve","_jsxs","ref","className","clsx","styles","baseStyle","_jsx","jsx","class","buttonContainer","previousButton","nextButton","TabbableModeContext","Provider","value","isTabbable","Button","startIcon","ChevronLeft","ChevronRight","variant","onAction","scrollAmount","scrollPrevious","clientWidth","style","clipPath","xUnits","contentContainer","minWidth","SvgChevronLeft","behavior","scrollNext"],"mappings":"4hGAwCA,SAASA,KACP,MAAMC,EAAaC,mBAAiBD,WACpC,MAAsB,UAAfA,GAAyC,WAAfA,CACnC,gBA2C4B,EAC1BE,WACAC,iBACAC,0BACAC,kBAAkB,WAElB,MAAOC,EAAiBC,GAAsBC,EAAQA,UAAC,IAChDC,EAAqBC,GAA0BF,EAAQA,UAAC,GACzDG,EAAuBC,SAA8B,MACrDC,EAAsBD,SAA8B,MACpDE,EAAyBF,SAA8B,MACvDG,EAAyBH,SAA8B,MACvDI,EAAUJ,SAA8B,MACxCK,EAAUL,SAA8B,MACxCM,EAAWN,SAA8B,MACzCO,EAAcP,SAAY,OAC1BQ,UAAEA,GAAcC,EAAAA,WACfC,EAAeC,GAAoBf,WACvCT,MAAkC,SAApBM,GAAmD,WAApBA,GAG1CmB,EAAmBC,EAAAA,aAAY,KAC/BrB,GAAyBA,EAAwBO,EAAqBe,SAASC,WAAW,GAC7F,CAACvB,IAiDJ,OA/CAwB,EAAAA,WAAU,KACRL,EAAkBxB,MAAkC,SAApBM,GAAmD,WAApBA,EAA6B,GAC3F,CAACA,IAEJuB,EAAAA,WAAU,KACHjB,EAAqBe,SAC1Bf,EAAqBe,QAAQG,SAAS,CACpCC,KAAM3B,GACN,GACD,CAACA,IAEJyB,EAAAA,WAAU,KACR,MAAMG,EAAoBpB,EAAqBe,QACzCM,EAAYf,EAAQS,QACpBO,EAAaf,EAASQ,QAyB5B,OAvBIK,GAAqBC,GAAaC,IAC/BX,IACHH,EAAYO,QAAU,IAAIQ,sBACvBC,IACCA,EAAQC,SAASC,IAC2C,SAAtDA,EAAMC,OAAOC,aAAa,wBAC5B7B,GAAwB2B,EAAMG,gBAE9BjC,GAAoB8B,EAAMG,eAC3B,GACD,GAEJ,CACEC,KAAMV,IAGVZ,EAAYO,QAAQgB,QAAQV,GAC5Bb,EAAYO,QAAQgB,QAAQT,IAE9BF,EAAkBY,iBAAiB,YAAanB,IAI3C,KACAO,IACLA,EAAkBa,oBAAoB,YAAapB,GACnDL,EAAYO,QAAQmB,UAAUb,GAC9Bb,EAAYO,QAAQmB,UAAUZ,GAAW,CAC1C,GACA,CAACX,EAAeE,IAGjBsB,OAAA,MAAA,CAAKC,IAAK/B,EAASgC,UAAWC,EAAAA,WAAK,CAACC,EAAAA,OAAOC,YACxCjD,SAAA,CAAAO,IAAwBa,GACvB8B,EACeC,IAAA,MAAA,CAAA,eAAA,EACbN,IAAKhC,EACLuC,MAAOL,EAAAA,WAAK,CACVC,EAAAA,OAAOK,gBACO,QAAdnC,EAAsB8B,EAAAA,OAAOM,eAAiBN,EAAMA,OAACO,aAEvDvD,SAAAkD,EAAAA,IAACM,EAAmBA,oBAACC,SAAQ,CAACC,MAAO,CAAEC,YAAY,GACjD3D,SAAAkD,MAACU,EAAAA,OAAM,CACLC,UAAyB,QAAd3C,EAAsBgC,EAACC,IAAAW,iBAAc,CAAA,GAAGZ,EAAAA,IAACa,EAAAA,gBAAY,CAAA,GAChEC,QAAQ,aACRC,SAAU,IA/HxB,SACE/C,EACAW,EACAqC,GAEIrC,GAAqBqC,IACL,QAAdhD,EACFW,EAAkBF,SAAS,CACzBC,KAAMC,EAAkBJ,WAAayC,IAGvCrC,EAAkBF,SAAS,CACzBC,KAAMC,EAAkBJ,WAAayC,IAI7C,CAgHgBC,CACEjD,EACAT,EAAqBe,QACrBf,EAAqBe,SAAS4C,mBAO1ClB,EAAAC,IAAA,MAAA,CACEkB,MAAO,CACLC,SAAwB,QAAdpD,EAAsB,cAAcd,EAAkBmE,EAAMA,OAAC,IAAM,eAC3EhE,EAAsBgE,EAAMA,OAAC,IAAM,KAC/B,cAAchE,EAAsBgE,EAAMA,OAAC,IAAM,eACrDnE,EAAkBmE,EAAMA,OAAC,IAAM,MAGnCzB,UAAWE,EAAAA,OAAOnB,kBAClBgB,IAAKpC,WACLmC,EAAAA,KAAK,MAAA,CAAAE,UAAWE,EAAAA,OAAOwB,iBAAkB3B,IAAKlC,EAAmBX,SAAA,CAC/DkD,MAA0B,MAAA,CAAA,uBAAA,OAAOL,IAAK9B,EAASsD,MAAO,CAAEI,SAAU,KACjEzE,EACDkD,EAAAC,IAAA,MAAA,CAAA,uBAA0B,QAAQN,IAAK7B,EAAUqD,MAAO,CAAEI,SAAU,UAGvErE,IAAoBgB,GACnB8B,EACeC,IAAA,MAAA,CAAA,eAAA,EACbN,IAAKjC,EACLwC,MAAOL,EAAAA,WAAK,CACVC,EAAAA,OAAOK,gBACO,QAAdnC,EAAsB8B,EAAAA,OAAOO,WAAaP,EAAMA,OAACM,iBAEnDtD,SAAAkD,EAAAA,IAACM,EAAmBA,oBAACC,SAAQ,CAACC,MAAO,CAAEC,YAAY,GACjD3D,SAAAkD,EAAAC,IAACS,EAAMA,OAAA,CACLC,UAAyB,QAAd3C,EAAsBgC,EAAAA,IAACa,EAAAA,gBAAe,CAAA,GAAGb,EAAAA,IAACY,EAAWY,eAAA,CAAA,GAChEV,QAAQ,aACRC,SAAU,IApJxB,SACE/C,EACAW,EACAqC,GAEIrC,GAAqBqC,IACL,QAAdhD,EACFW,EAAkBF,SAAS,CACzBC,KAAMC,EAAkBJ,WAAayC,EACrCS,SAAU,WAGZ9C,EAAkBF,SAAS,CACzBC,KAAMC,EAAkBJ,WAAayC,EACrCS,SAAU,WAIlB,CAmIgBC,CACE1D,EACAT,EAAqBe,QACrBf,EAAqBe,SAAS4C,qBAQ5C"}