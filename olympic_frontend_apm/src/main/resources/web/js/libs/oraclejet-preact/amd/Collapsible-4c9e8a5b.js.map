{"version":3,"file":"Collapsible-4c9e8a5b.js","sources":["../../src/UNSAFE_Collapsible/CollapsibleHeaderIcon.tsx","../../src/UNSAFE_Collapsible/CollapsibleHeader.tsx","../../src/UNSAFE_Collapsible/CollapsibleContent.tsx","../../src/UNSAFE_Collapsible/Collapsible.tsx"],"sourcesContent":["import { ExpandIcon } from '../PRIVATE_ThemedIcons/ExpandIcon';\nimport { CollapseIcon } from '../PRIVATE_ThemedIcons/CollapseIcon';\nimport { CollapseUpIcon } from '../PRIVATE_ThemedIcons/CollapseUpIcon';\n\ntype IconProps = {\n  isExpanded: boolean;\n  isDisabled?: boolean;\n  iconPosition?: 'start' | 'end';\n};\n\n/**\n * Header icon subcomponent\n */\nexport const CollapsibleHeaderIcon = ({ isExpanded, isDisabled, iconPosition }: IconProps) => {\n  const color = isDisabled ? 'disabled' : 'primary';\n  const startIcon = iconPosition === 'start' && isExpanded ? ExpandIcon : CollapseIcon;\n  const endIcon = iconPosition === 'end' && isExpanded ? CollapseUpIcon : ExpandIcon;\n  const Icon = iconPosition === 'start' ? startIcon : endIcon;\n\n  return <Icon size=\"6x\" color={color} />;\n};\n","import { Fragment } from 'preact';\nimport { useCallback, useState, useRef } from 'preact/hooks';\n\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { CollapsibleVariantOptions, CollapsibleStyles } from './themes/CollapsibleStyles.css';\n\nimport { Flex } from '../UNSAFE_Flex';\nimport { Separator } from '../UNSAFE_Separator';\nimport { CollapsibleHeaderIcon } from './CollapsibleHeaderIcon';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { usePress } from '../hooks/UNSAFE_usePress';\nimport { CollapsibleRedwoodTheme } from './themes/redwood/CollapsibleTheme';\n\ntype IntrinsicProps = Pick<HTMLAttributesSignalExcluded<HTMLDivElement>, 'id' | 'children'>;\n\ntype HeaderProps = IntrinsicProps & {\n  id: string;\n  contentId: string;\n  isDisabled: boolean;\n  isExpanded: boolean;\n  iconPosition?: 'start' | 'end';\n  variant?: 'basic' | 'horizontal-rule';\n  toggleHandler: (target: EventTarget | null) => void;\n  accessibleLabel?: string;\n  accessibleLabelId?: string;\n};\n\n/**\n * Header subcomponent\n */\n\nexport const CollapsibleHeader = ({\n  children,\n  id,\n  contentId,\n  isDisabled,\n  isExpanded,\n  iconPosition,\n  variant = 'basic',\n  toggleHandler,\n  accessibleLabel,\n  accessibleLabelId\n}: HeaderProps) => {\n  const [hasFocus, setFocus] = useState<boolean>(false);\n  const isMouseDown = useRef<boolean>(false);\n\n  const { classes, styles } = useComponentTheme<CollapsibleVariantOptions, CollapsibleStyles>(\n    CollapsibleRedwoodTheme,\n    {\n      disabled: isDisabled ? 'isDisabled' : 'notDisabled',\n      divider: variant === 'horizontal-rule' ? 'hasDivider' : 'noDivider',\n      focused: hasFocus ? 'isFocused' : 'notFocused'\n    }\n  );\n\n  const childrenClasses = classNames([\n    styles.headerChildrenStyle,\n    iconPosition === 'end' && styles.iconEndStyle,\n    iconPosition === 'start' && styles.iconStartStyle\n  ]);\n\n  const pressHandler = useCallback(\n    (event: Event) => {\n      toggleHandler(event.target);\n      // if the header has focus highlight and the toggle was caused by a pointer action,\n      // remove focus highlight from the header div\n      // the test environment may not support PointerEvent, make sure it is supported\n      if (hasFocus) {\n        const hasPointerEvent = window && 'PointerEvent' in window;\n        if ((hasPointerEvent && event instanceof PointerEvent) || event instanceof MouseEvent) {\n          setFocus(false);\n        }\n      }\n    },\n    [toggleHandler, hasFocus]\n  );\n\n  const { pressProps } = usePress(pressHandler, {\n    isDisabled,\n    isRepeat: false\n  });\n\n  // if focused, we want to render the focus highlight on the collapsible header div\n  const onFocus = useCallback((event: Event) => {\n    if (event.type === 'focusin' && !isMouseDown.current) {\n      setFocus(true);\n    } else {\n      setFocus(false);\n    }\n  }, []);\n\n  const mouseDownHandler = () => {\n    isMouseDown.current = true;\n  };\n\n  const mouseUpHandler = () => {\n    isMouseDown.current = false;\n  };\n\n  // Resolve accessible label. By default, the expand button is labelled by the header content.\n  // If accessibleLabel or accessibleLabeleId is specified, they get used instead.\n  const ariaLabelProp = accessibleLabel\n    ? { 'aria-label': accessibleLabel }\n    : accessibleLabelId\n    ? { 'aria-labelledby': accessibleLabelId }\n    : { 'aria-labelledby': id };\n\n  const getHeader = () => (\n    <Fragment>\n      {iconPosition === 'end' && <div className={childrenClasses}>{children}</div>}\n      <div\n        tabIndex={0}\n        role={'button'}\n        aria-controls={contentId}\n        aria-expanded={isExpanded}\n        onFocus={onFocus}\n        onBlur={onFocus}\n        onMouseDown={mouseDownHandler}\n        onMouseUp={mouseUpHandler}\n        className={styles.chevronStyle}\n        {...ariaLabelProp}>\n        <CollapsibleHeaderIcon\n          iconPosition={iconPosition}\n          isExpanded={isExpanded}\n          isDisabled={isDisabled}\n        />\n      </div>\n      {iconPosition === 'start' && <div className={childrenClasses}>{children}</div>}\n    </Fragment>\n  );\n\n  return (\n    <>\n      <div id={id} className={classes} {...pressProps}>\n        <Flex align=\"center\" justify={iconPosition === 'start' ? 'start' : 'between'}>\n          {getHeader()}\n        </Flex>\n      </div>\n      {variant === 'horizontal-rule' && <Separator />}\n    </>\n  );\n};\n","import { JSX } from 'preact';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { useAnimation, UseAnimationConfig } from '../hooks/UNSAFE_useAnimation';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { CollapsibleStyles } from './themes/CollapsibleStyles.css';\n\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { CollapsibleRedwoodTheme } from './themes/redwood/CollapsibleTheme';\n\ntype IntrinsicProps = Pick<HTMLAttributesSignalExcluded<HTMLDivElement>, 'children'>;\n\ntype ContentProps = IntrinsicProps & {\n  id: string;\n  isExpanded: boolean;\n  onTransitionEnd: () => void;\n};\n\n/**\n * The 'collapsing' and 'expanding' states are related to the animation. The 'unmounted' state\n * is used for conditional rendering. In this state, the Collapsible content is completely removed\n * from the DOM. The 'unmounted' state is set either as an initial state or when collapsing\n * animation ends.\n */\ntype Status = 'collapsing' | 'expanding' | 'unmounted';\n\nexport const CollapsibleContent = ({ children, id, isExpanded, onTransitionEnd }: ContentProps) => {\n  const [state, setState] = useState<Status>(isExpanded ? 'expanding' : 'unmounted');\n\n  const { styles } = useComponentTheme<never, CollapsibleStyles>(CollapsibleRedwoodTheme);\n\n  /**\n   * 1. On initial render, Preact sets style.maxHeight field to 0 or 'none'.\n   * 2. During expanding animation, useAnimation hook uses WAAPI to animate the maxHeight out\n   *    to the expanded value.\n   * 3. On subsequent re-renders, Preact does never updates the style.maxHeight value\n   *    because even though we are telling Preact that maxHeight should be 0 or 'none', Preact\n   *    considers the maxHeight value is 0 or 'none' as it is not aware that we changed this value\n   *    in step 2. So from Preact's perspective there is no difference.\n   */\n  const contentInitialStyle = useRef<JSX.CSSProperties>({\n    overflowY: 'hidden',\n    maxHeight: isExpanded ? 'none' : '0'\n  });\n\n  useEffect(() => {\n    // Ignore state update on initial render\n    if (state === 'unmounted' && !isExpanded) {\n      return;\n    }\n    setState(isExpanded ? 'expanding' : 'collapsing');\n  }, [isExpanded, state]);\n\n  const { nodeRef } = useAnimation<Status, HTMLDivElement>(state, {\n    animationStates,\n    onAnimationEnd: ({ animationState }) => {\n      if (animationState === 'collapsing') {\n        setState('unmounted');\n      }\n      onTransitionEnd?.();\n    }\n  });\n\n  return (\n    <div\n      className={styles.contentChildrenStyle}\n      ref={nodeRef}\n      id={id}\n      tabIndex={-1}\n      style={contentInitialStyle.current}\n      aria-hidden={!isExpanded || undefined}>\n      {state !== 'unmounted' && children}\n    </div>\n  );\n};\n\n/**\n * The transition from collapsed to expanded works as follows:\n * 1. When the component is initially rendered in the collapsed state, we\n *    explicitly set maxHeight and overflowY from \"to\" configuration.\n * 2. When the expanded prop changes from false to true, we first mount the content children.\n * 3. Once this is mounted we trigger an animation updating animationState value of useAnimationHook.\n * 4. Configuration is represented inside hook. Passed config depends if previous animation was completed or not.\n *    We could check that based on node.style.maxHeight.\n *\n * The transition from expanded to collapsed is similar:\n * 1. We trigger an animation updating animationState value of useAnimationHook.\n * 2. Once animation is completed, with the help of end config,we set max-Height as 'none'.\n *    This will allow us to keep adding content.\n * 3. Once this is done, onAnimationEnd is called(as 'from collapsed to expanded\"). Here, content children are unmouunted.\n */\nconst animationStates: UseAnimationConfig<Status, HTMLDivElement>['animationStates'] = {\n  expanding: (node) => ({\n    to: {\n      maxHeight: `${node.scrollHeight}px`\n    },\n    options: {\n      duration: 400\n    },\n    end: {\n      maxHeight: 'none'\n    }\n  }),\n  collapsing: (node) => ({\n    ...(node.style.maxHeight === 'none' && {\n      from: {\n        maxHeight: `${node.scrollHeight}px`\n      }\n    }),\n    to: {\n      maxHeight: '0'\n    },\n    options: {\n      duration: 400\n    }\n  })\n};\n","import { ComponentChildren } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { CollapsibleHeader } from './CollapsibleHeader';\nimport { CollapsibleContent } from './CollapsibleContent';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\n\ntype Props = {\n  /**\n   * Collapsible's header. If not specified, the header contains only an open/close icon. Note that the header text is required for JET collapsible for accessibility purposes.\n   */\n  header?: ComponentChildren;\n\n  /**\n   * The content node to be collapsed\n   */\n  children?: ComponentChildren;\n\n  /**\n   * Disables the collapsible if set to true\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Specifies if the content is expanded\n   */\n  isExpanded?: boolean;\n\n  /**\n   * Changes chevron icon placement at the end of the collapsible header\n   */\n  iconPosition?: 'start' | 'end';\n\n  /**\n   * Controls the header display which con include a divider below the collapsible header\n   */\n  variant?: 'basic' | 'horizontal-rule';\n\n  /**\n   * Property that triggers a callback immediately when toggle happens and value of expanded property should be updated\n   */\n  onToggle?: (details: ToggleDetail) => void;\n\n  /**\n   * Property that triggers a callback after toggle animation is done\n   */\n  onTransitionEnd?: (details: TransitionEnd) => void;\n\n  /**\n   * An alternative accessible label. By default, the header content is used as Collapsible's accessible label.\n   * If required, the user can set a custom 'accessibleLabel' value.\n   */\n  'aria-label'?: string;\n\n  /**\n   * An alternative accessible label id. By default, the header content is used as Collapsible's accessible label.\n   * If required, the user can specify an element id within the header to be used as the accessible label.\n   * If both 'accessibleLabel' and 'accessibilityId' are specified, the 'accessibleLabelId' is ignored.\n   */\n  'aria-labelledby'?: string;\n} & TestIdProps;\n\ntype ToggleDetail = TransitionEnd & {\n  target: EventTarget | null;\n};\n\ntype TransitionEnd = {\n  value: boolean;\n};\n\n/**\n * A collapsible displays a header that can be expanded to show its content.\n */\n\nexport const Collapsible = ({\n  header,\n  children,\n  isDisabled = false,\n  isExpanded = false,\n  iconPosition = 'start',\n  variant = 'basic',\n  onToggle,\n  onTransitionEnd,\n  'aria-label': accessibleLabel,\n  'aria-labelledby': accessibleLabelId,\n  testId\n}: Props) => {\n  const uniqueID = useId();\n  const headerId = `oj-collapsible-header-${uniqueID}`;\n  const contentId = `oj-collapsible-content-${uniqueID}`;\n\n  const testIdProps = useTestId(testId);\n\n  /**\n   * Function handling toggle and invoking callback for collapsing/expanding\n   */\n  const toggleHandler = useCallback(\n    (target: EventTarget | null) => {\n      if (isDisabled) {\n        return;\n      }\n      onToggle?.({\n        value: !isExpanded,\n        target\n      });\n    },\n    [isDisabled, onToggle, isExpanded]\n  );\n\n  /**\n   * Function that is triggerd when animation ends\n   */\n  const transitionEndHandler = useCallback(() => {\n    onTransitionEnd?.({\n      value: isExpanded\n    });\n  }, [onTransitionEnd, isExpanded]);\n\n  return (\n    <div {...testIdProps}>\n      <CollapsibleHeader\n        id={headerId}\n        contentId={contentId}\n        toggleHandler={toggleHandler}\n        isDisabled={isDisabled}\n        isExpanded={isExpanded}\n        iconPosition={iconPosition}\n        variant={variant}\n        accessibleLabel={accessibleLabel}\n        accessibleLabelId={accessibleLabelId}>\n        {header}\n      </CollapsibleHeader>\n      <CollapsibleContent\n        id={contentId}\n        isExpanded={isExpanded}\n        onTransitionEnd={transitionEndHandler}>\n        {children}\n      </CollapsibleContent>\n    </div>\n  );\n};\n"],"names":["CollapsibleHeaderIcon","isExpanded","isDisabled","iconPosition","color","startIcon","ExpandIcon","CollapseIcon","endIcon","CollapseUpIcon","Icon","_jsx","size","CollapsibleHeader","children","id","contentId","variant","toggleHandler","accessibleLabel","accessibleLabelId","hasFocus","setFocus","useState","isMouseDown","useRef","classes","styles","useComponentTheme","CollapsibleRedwoodTheme","disabled","divider","focused","childrenClasses","classNames","headerChildrenStyle","iconEndStyle","iconStartStyle","pressHandler","useCallback","event","target","window","PointerEvent","MouseEvent","pressProps","usePress","isRepeat","onFocus","type","current","mouseDownHandler","mouseUpHandler","ariaLabelProp","_jsxs","jsx","className","Flex","align","justify","Fragment","tabIndex","role","onBlur","onMouseDown","onMouseUp","chevronStyle","Separator","CollapsibleContent","onTransitionEnd","state","setState","contentInitialStyle","overflowY","maxHeight","useEffect","nodeRef","useAnimation","animationStates","onAnimationEnd","animationState","contentChildrenStyle","ref","style","undefined","expanding","node","to","scrollHeight","options","duration","end","collapsing","from","header","onToggle","testId","uniqueID","useId","headerId","testIdProps","useTestId","value","transitionEndHandler","jsxs"],"mappings":"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"}