{"version":3,"file":"UNSAFE_useCategories.js","sources":["../../../src/hooks/UNSAFE_useCategories/useCategories.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useMemo, useRef } from 'preact/hooks';\n\n/**\n * Compares if two sets are equal.\n */\nconst isEqual = <T>(setA: Set<T>, setB: Set<T>) => {\n  return setA.size === setB.size && [...setA].every((value) => setB.has(value));\n};\n\n/**\n * Toggles the existing categories/id with updated categories/id.\n * @param original The set of original ids/categories\n * @param updated The set of updated ids/categories\n * @returns\n */\nconst toggle = <T>(original: Set<T>, updated: Set<T>) => {\n  const matches = new Set(original);\n  updated.forEach((item) => {\n    if (!original.has(item)) {\n      matches.add(item);\n    } else {\n      matches.delete(item);\n    }\n  });\n  return matches;\n};\n\n/**\n * Creates initial map of category and data items.\n * @param items Data item objects. If 'categories' field is not present, id will be assumed to be default category.\n */\nfunction getCategoryMap<K extends number | string>(\n  items: any[],\n  getCategory: (item: any) => string[]\n) {\n  const categoryToItem: Map<string, Set<K>> = new Map();\n  const itemToCategory: Map<K, Set<string>> = new Map();\n  items.forEach((item: any) => {\n    const id: K = item.id;\n    const categories: string[] = getCategory(item);\n    itemToCategory.set(id, new Set(categories));\n    categories.forEach((category) => {\n      if (categoryToItem.has(category)) {\n        categoryToItem.get(category)?.add(id);\n      } else {\n        categoryToItem.set(category, new Set([id]));\n      }\n    });\n  });\n  return { categoryToItem, itemToCategory };\n}\n\n/**\n * Returns the items for a given categories.\n * @param categoryToItemMap Map of categories to Item.\n * @param matchCriteria Whether to match any or all categories.\n * @param categories categories\n * @returns\n */\nfunction getItemsFromCategories<K>(\n  categoryToItemMap: Map<string, Set<K>>,\n  matchCriteria: 'any' | 'all' = 'any',\n  categories: Set<string>\n) {\n  return [...categories].reduce((acc: Set<K>, cur: string, index: number) => {\n    const curItems = categoryToItemMap.get(cur)!;\n    if (matchCriteria === 'any') {\n      return curItems ? new Set([...acc, ...curItems]) : acc;\n    }\n\n    if (!index) return curItems;\n    return new Set([...acc].filter((item) => curItems.has(item)));\n  }, new Set<K>());\n}\n\n/**\n * A hook that helps to manage getting ids that match specific categories or criterias in a set of data. It also handles partial versus exact matching.\n *\n * @param items The array of items.\n * @param getCategoriesFromItem The function that returns the categories array for given item.\n * @param initialCategories The initial categories.\n * @param matchCriteria  The matching condition for the categories.\n * By default, matchCriteria is 'all' and only items whose categories match all of the values specified in the categories array will be matched.\n * If matchCriteria is 'any', then items that match at least one of the categories values will be matched.\n * @param replace Whether the new categories should completely replace the old categories (for highlighting) or just toggle previous categories (for hideAndShow)\n * @param onCategoriesChange The callback to invoke when categories change.\n * @returns\n */\nexport const useCategories = <K extends string | number>(\n  items: any[],\n  getCategoriesFromItem: (item: any) => string[],\n  initialCategories: string[] = [],\n  matchCriteria: 'any' | 'all' = 'all',\n  replace = true,\n  onCategoriesChange?: (categories: string[]) => void\n) => {\n  const categoryMap = useMemo(\n    () => getCategoryMap<K>(items, getCategoriesFromItem),\n    [items, getCategoriesFromItem]\n  );\n\n  const initialCategoriesSet = new Set(initialCategories);\n  const newIds = getItemsFromCategories(\n    categoryMap.categoryToItem,\n    matchCriteria,\n    initialCategoriesSet\n  );\n\n  const categoriesRef = useRef(initialCategoriesSet);\n  const idsRef = useRef(newIds);\n\n  if (!isEqual(newIds, idsRef.current)) {\n    idsRef.current = newIds;\n  }\n\n  if (!isEqual(categoriesRef.current, initialCategoriesSet)) {\n    categoriesRef.current = initialCategoriesSet;\n    onCategoriesChange?.([...initialCategoriesSet]);\n  }\n\n  const updateCategories = (id: K | undefined) => {\n    let updatedCategories = id != null ? categoryMap.itemToCategory.get(id)! : new Set([]);\n    let updatedItems = getItemsFromCategories(\n      categoryMap.categoryToItem,\n      matchCriteria,\n      updatedCategories\n    );\n\n    if (!replace) {\n      updatedItems = toggle(idsRef.current, updatedItems);\n      updatedCategories = toggle(categoriesRef.current, updatedCategories);\n    }\n\n    if (!isEqual(updatedItems, idsRef.current)) {\n      idsRef.current = updatedItems;\n    }\n\n    if (updatedCategories && !isEqual(updatedCategories, categoriesRef.current)) {\n      categoriesRef.current = updatedCategories;\n      onCategoriesChange?.([...updatedCategories]);\n    }\n  };\n\n  return {\n    ids: [...idsRef.current],\n    updateCategories\n  };\n};\n"],"names":["isEqual","setA","setB","size","every","value","has","toggle","original","updated","matches","Set","forEach","item","delete","add","getItemsFromCategories","categoryToItemMap","matchCriteria","categories","reduce","acc","cur","index","curItems","get","filter","items","getCategoriesFromItem","initialCategories","replace","onCategoriesChange","categoryMap","useMemo","getCategory","categoryToItem","Map","itemToCategory","id","set","category","getCategoryMap","initialCategoriesSet","newIds","categoriesRef","useRef","idsRef","current","ids","updateCategories","updatedCategories","updatedItems"],"mappings":"8DAaA,MAAMA,EAAU,CAAIC,EAAcC,IACzBD,EAAKE,OAASD,EAAKC,MAAQ,IAAIF,GAAMG,OAAOC,GAAUH,EAAKI,IAAID,KASlEE,EAAS,CAAIC,EAAkBC,KACnC,MAAMC,EAAU,IAAIC,IAAIH,GAQxB,OAPAC,EAAQG,SAASC,IACVL,EAASF,IAAIO,GAGhBH,EAAQI,OAAOD,GAFfH,EAAQK,IAAIF,EAGb,IAEIH,CAAO,EAmChB,SAASM,EACPC,EACAC,EAA+B,MAC/BC,GAEA,MAAO,IAAIA,GAAYC,QAAO,CAACC,EAAaC,EAAaC,KACvD,MAAMC,EAAWP,EAAkBQ,IAAIH,GACvC,MAAsB,QAAlBJ,EACKM,EAAW,IAAIb,IAAI,IAAIU,KAAQG,IAAaH,EAGhDE,EACE,IAAIZ,IAAI,IAAIU,GAAKK,QAAQb,GAASW,EAASlB,IAAIO,MADnCW,CAC0C,GAC5D,IAAIb,IACT,iBAe6B,CAC3BgB,EACAC,EACAC,EAA8B,GAC9BX,EAA+B,MAC/BY,GAAU,EACVC,KAEA,MAAMC,EAAcC,WAClB,IAlEJ,SACEN,EACAO,GAEA,MAAMC,EAAsC,IAAIC,IAC1CC,EAAsC,IAAID,IAahD,OAZAT,EAAMf,SAASC,IACb,MAAMyB,EAAQzB,EAAKyB,GACbnB,EAAuBe,EAAYrB,GACzCwB,EAAeE,IAAID,EAAI,IAAI3B,IAAIQ,IAC/BA,EAAWP,SAAS4B,IACdL,EAAe7B,IAAIkC,GACrBL,EAAeV,IAAIe,IAAWzB,IAAIuB,GAElCH,EAAeI,IAAIC,EAAU,IAAI7B,IAAI,CAAC2B,IACvC,GACD,IAEG,CAAEH,iBAAgBE,iBAC3B,CA+CUI,CAAkBd,EAAOC,IAC/B,CAACD,EAAOC,IAGJc,EAAuB,IAAI/B,IAAIkB,GAC/Bc,EAAS3B,EACbgB,EAAYG,eACZjB,EACAwB,GAGIE,EAAgBC,SAAOH,GACvBI,EAASD,SAAOF,GAEjB3C,EAAQ2C,EAAQG,EAAOC,WAC1BD,EAAOC,QAAUJ,GAGd3C,EAAQ4C,EAAcG,QAASL,KAClCE,EAAcG,QAAUL,EACxBX,IAAqB,IAAIW,KA0B3B,MAAO,CACLM,IAAK,IAAIF,EAAOC,SAChBE,iBAzBwBX,IACxB,IAAIY,EAA0B,MAANZ,EAAaN,EAAYK,eAAeZ,IAAIa,GAAO,IAAI3B,IAAI,IAC/EwC,EAAenC,EACjBgB,EAAYG,eACZjB,EACAgC,GAGGpB,IACHqB,EAAe5C,EAAOuC,EAAOC,QAASI,GACtCD,EAAoB3C,EAAOqC,EAAcG,QAASG,IAG/ClD,EAAQmD,EAAcL,EAAOC,WAChCD,EAAOC,QAAUI,GAGfD,IAAsBlD,EAAQkD,EAAmBN,EAAcG,WACjEH,EAAcG,QAAUG,EACxBnB,IAAqB,IAAImB,IAC1B,EAMF"}