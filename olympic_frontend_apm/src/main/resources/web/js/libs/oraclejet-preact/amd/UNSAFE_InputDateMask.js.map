{"version":3,"file":"UNSAFE_InputDateMask.js","sources":["../../src/UNSAFE_InputDateMask/DateSegment.tsx","../../src/UNSAFE_InputDateMask/LiteralSegment.tsx","../../src/UNSAFE_InputDateMask/dateReducer.ts","../../src/UNSAFE_InputDateMask/DateField.tsx","../../src/UNSAFE_InputDateMask/useDateField.ts","../../src/UNSAFE_InputDateMask/useDateFieldHandlers.ts","../../src/UNSAFE_InputDateMask/InputDateMask.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useCallback, useEffect, useRef } from 'preact/hooks';\nimport { AriaAttributesSignalExcluded } from '#utils/UNSAFE_attributeUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { DateFieldAction } from './dateReducer';\nimport { EditableDateSegment } from './types';\nimport { isBackspaceOrDelete } from '#utils/PRIVATE_keyboardUtils';\nimport { isNumberOnlyString } from '#utils/PRIVATE_dayUtils';\nimport { segmentStyles } from './themes/SegmentStyles.css';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { useUser } from '#hooks/UNSAFE_useUser';\n\ntype AriaProps = Pick<\n  AriaAttributesSignalExcluded,\n  'aria-label' | 'aria-valuemax' | 'aria-valuemin' | 'aria-valuenow' | 'aria-valuetext'\n>;\n\ntype Props = AriaProps & {\n  /**\n   * True if the segment is complete in the sense that it contains a complete valid value.\n   * For instance, entering '0' and then '1-9' is considered a complete value for month and day.\n   * Also true if typing any additional digit would cause the segment value to exceed the max.\n   */\n  isComplete?: boolean;\n\n  /**\n   * True if the segment is disabled.\n   */\n  isDisabled?: boolean;\n\n  /**\n   * True if the segment should be hidden.\n   */\n  isHidden?: boolean;\n\n  /**\n   * True if the segment is highlighted.\n   */\n  isHighlighted?: boolean;\n\n  /**\n   * True if the segment is invalid.\n   */\n  isInvalid?: boolean;\n\n  /**\n   * Specifies for accessibility purposes whether a value is required.\n   */\n  isRequired?: boolean;\n\n  /**\n   * True if the segment is selected.\n   */\n  isSelected?: boolean;\n\n  /**\n   * Placeholder displayed when the segment has no display value.\n   */\n  placeholder?: string;\n\n  /**\n   * The text to display for this segment.\n   */\n  text?: string;\n\n  /**\n   * The segment of a calendar date which is being represented, i.e. the month, day, or year.\n   */\n  type: EditableDateSegment;\n\n  /**\n   * Callback invoked when a change to the segment is requested via user action, such as typing\n   * a new value or pressing the Backspace or Delete keys.\n   */\n  onChange?: (action: DateFieldAction) => void;\n};\n\n/**\n * A DateSegment renders a part of a calendar date, e.g. the day, month, or year.\n * It can be used as a spinbutton to step or spin its value.\n */\nexport const DateSegment = ({\n  'aria-label': ariaLabel,\n  'aria-valuemax': ariaValueMax,\n  'aria-valuemin': ariaValueMin,\n  'aria-valuenow': ariaValueNow,\n  'aria-valuetext': ariaValueText,\n  isComplete,\n  isDisabled,\n  isHidden,\n  isHighlighted,\n  isInvalid,\n  isRequired,\n  isSelected,\n  onChange,\n  placeholder,\n  text,\n  type\n}: Props) => {\n  const hasDisplayValue = text && text.length > 0;\n  const rootClasses = classNames([\n    segmentStyles.base,\n    isSelected && segmentStyles.selected,\n    isHighlighted && segmentStyles.highlighted\n  ]);\n  const placeholderClasses = classNames([\n    segmentStyles.placeholder,\n    isHidden || hasDisplayValue ? segmentStyles.hidden : segmentStyles.notHidden\n  ]);\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const emptySegmentValueText = translations.inputDateMask_empty_segment();\n\n  const hasLeadingZero = useRef<boolean>(false);\n  const segmentRef = useRef<HTMLDivElement>(null);\n  const { locale } = useUser();\n\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (\n        isDisabled ||\n        isHighlighted ||\n        event.key === 'Tab' ||\n        event.key === 'ArrowLeft' ||\n        event.key === 'ArrowRight' ||\n        event.key === 'Enter'\n      ) {\n        // Let the event pass through.\n        return;\n      }\n\n      if (event.key === '0' && (isComplete || text === undefined)) {\n        // Typing '0' is considered a leading zero if the segment is complete, in which case\n        // the user is typing a new value, or if there is no current value.\n        hasLeadingZero.current = true;\n      } else if (isNumberOnlyString(event.key)) {\n        onChange?.({\n          actionType: 'updateSegment',\n          data: { type, text: event.key, hasLeadingZero: hasLeadingZero.current, locale }\n        });\n        hasLeadingZero.current = false;\n      } else if (isBackspaceOrDelete(event)) {\n        onChange?.({ actionType: 'clearSegment', data: { type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'ArrowUp') {\n        onChange?.({ actionType: 'step', data: { direction: 'increase', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'ArrowDown') {\n        onChange?.({ actionType: 'step', data: { direction: 'decrease', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'PageUp') {\n        onChange?.({ actionType: 'page', data: { direction: 'increase', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'PageDown') {\n        onChange?.({ actionType: 'page', data: { direction: 'decrease', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'Home') {\n        onChange?.({ actionType: 'goToHome', data: { locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'End') {\n        onChange?.({ actionType: 'goToEnd', data: { locale, type } });\n        hasLeadingZero.current = false;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n    },\n    [isComplete, isDisabled, isHighlighted, locale, onChange, text, type]\n  );\n\n  // Used to focus the segment when isSelected is true.\n  useEffect(() => {\n    if (isSelected) {\n      segmentRef.current?.focus();\n    }\n  }, [isSelected]);\n\n  // This attribute is used to distinguish between segments when clicked (see DateField.tsx).\n  const customDataAttribute = { 'data-segment': [type] };\n\n  // If ariaValueText is undefined, substitute a string that indicates the segment is empty.\n  // If ariaValueNow and ariaValueText represent the same value, omit the value text; this\n  // is the same as what we do in NumberInputText.\n  const valueText =\n    ariaValueText === undefined\n      ? emptySegmentValueText\n      : ariaValueNow?.toString() === ariaValueText\n      ? undefined\n      : ariaValueText;\n\n  return (\n    <div\n      ref={segmentRef}\n      role=\"spinbutton\"\n      aria-disabled={isDisabled}\n      aria-invalid={isInvalid || undefined}\n      aria-label={ariaLabel}\n      aria-required={isRequired}\n      aria-valuemin={ariaValueMin}\n      aria-valuemax={ariaValueMax}\n      aria-valuenow={ariaValueNow}\n      aria-valuetext={valueText}\n      autocapitalize=\"off\"\n      autocorrect=\"off\"\n      class={rootClasses}\n      contentEditable={!isDisabled && isSelected}\n      {...customDataAttribute}\n      enterkeyhint={isDisabled ? undefined : 'done'}\n      inputMode={isDisabled ? 'none' : 'numeric'}\n      onKeyDown={onKeyDown}\n      spellcheck={false}\n      tabIndex={isSelected ? 0 : -1}>\n      <span aria-hidden=\"true\" class={placeholderClasses} {...customDataAttribute}>\n        {placeholder}\n      </span>\n      {text}\n    </div>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { segmentStyles } from './themes/SegmentStyles.css';\n\ntype Props = {\n  /**\n   * True if the segment should be hidden.\n   */\n  isHidden?: boolean;\n\n  /**\n   * True if the segment should be highlighted.\n   */\n  isHighlighted?: boolean;\n\n  /**\n   * True if the literal is part of a date placeholder, such as mm/dd/yyyy.\n   * If the date is partially specified or complete, this is false.\n   */\n  isPlaceholder?: boolean;\n\n  /**\n   * The text to display for this segment.\n   */\n  text: string;\n};\n\n/**\n * LiteralSegment is used to represent a literal separator in a calendar date,\n * such as the '/' in 11/29/2023.\n */\nexport const LiteralSegment = ({ isHidden, isHighlighted, isPlaceholder, text }: Props) => {\n  const spanClasses = classNames([\n    segmentStyles.literalBase,\n    isPlaceholder && segmentStyles.placeholder,\n    isHighlighted && segmentStyles.highlighted,\n    isHidden ? segmentStyles.hidden : segmentStyles.notHidden\n  ]);\n\n  return (\n    <span aria-hidden=\"true\" class={spanClasses}>\n      {text}\n    </span>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { DateFieldState, DateSegmentState } from './useDateField';\nimport { BCP47Locale } from '#UNSAFE_IntlDateTime';\nimport { CalendarDate, EditableDateSegment, IsoMonth } from './types';\nimport { getMonthName, getTodayAsCalendarDate } from '#utils/PRIVATE_dayUtils';\nimport { getDaysInMonth, getMonthsInYear, MAX_ISO_YEAR } from '#utils/UNSAFE_calendarDateUtils';\n\ntype DateFieldActionData = Partial<DateSegmentState> & {\n  direction?: 'increase' | 'decrease';\n  hasLeadingZero?: boolean;\n  locale?: BCP47Locale;\n};\n\ntype DateFieldAction = {\n  actionType:\n    | 'clearDate'\n    | 'clearSegment'\n    | 'commit'\n    | 'goToEnd'\n    | 'goToHome'\n    | 'page'\n    | 'selectDateOrSegment'\n    | 'selectFirst'\n    | 'selectNext'\n    | 'selectPrevious'\n    | 'selectSegment'\n    | 'step'\n    | 'updateSegment';\n  data?: DateFieldActionData;\n};\n\ntype ResetAction = {\n  actionType: 'reset';\n  data: DateFieldState;\n};\n\ntype DateReducerAction = DateFieldAction | ResetAction;\n\n/**\n * Reducer function for updating DateFieldState per the specified DateFieldAction.\n * @param state\n * @param action\n */\nconst dateReducer = (state: DateFieldState, action: DateReducerAction) => {\n  // On mount, the reducer is initialized with initial state derived from the DateField's value.\n  // If that value is changed programmatically afterwards, the only way to push that update\n  // into the reducer is to define a \"reset\" action.\n  if (action.actionType === 'reset') {\n    return action.data;\n  }\n\n  const segmentType = action.data?.type!;\n  const segmentState = findSegment(state.segments, segmentType);\n\n  switch (action.actionType) {\n    case 'clearDate': {\n      const updatedSegments = selectFirst(clearDate(state.segments), state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'clearSegment': {\n      const updatedSegment = clearSegment(segmentState);\n      return createDateFieldState(state, segmentType, updatedSegment);\n    }\n    case 'commit': {\n      const updatedSegments = clearSelectionAndComplete(state.segments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'goToEnd': {\n      const updatedSegment = goToEnd(\n        segmentType,\n        segmentState,\n        state.segments,\n        action.data?.locale!\n      );\n      return createDateFieldState(state, segmentType, updatedSegment, false);\n    }\n    case 'goToHome': {\n      const updatedSegment = goToHome(\n        segmentType,\n        segmentState,\n        state.segments,\n        action.data?.locale!\n      );\n      return createDateFieldState(state, segmentType, updatedSegment, false);\n    }\n    case 'page': {\n      const direction = action.data?.direction;\n      const locale = action.data?.locale!;\n      const updatedSegment = doStepOrPage(\n        segmentType,\n        segmentState,\n        state.segments,\n        'page',\n        direction,\n        locale\n      );\n      return createDateFieldState(state, segmentType, updatedSegment, false);\n    }\n    case 'selectDateOrSegment': {\n      return selectDateOrSegment(state);\n    }\n    case 'selectFirst': {\n      const updatedSegments = selectFirst(state.segments, state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'selectNext': {\n      const updatedSegments = selectNext(state.segments, state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'selectPrevious': {\n      const updatedSegments = selectPrevious(state.segments, state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'selectSegment': {\n      const updatedSegments = selectSegment(state.segments, segmentType);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'step': {\n      const direction = action.data?.direction;\n      const locale = action.data?.locale!;\n      const updatedSegment = doStepOrPage(\n        segmentType,\n        segmentState,\n        state.segments,\n        'step',\n        direction,\n        locale\n      );\n      return createDateFieldState(state, segmentType, updatedSegment, false);\n    }\n    case 'updateSegment': {\n      const updatedSegment = updateSegment(segmentType, segmentState, action, state.segments);\n      return createDateFieldState(state, segmentType, updatedSegment);\n    }\n    default: {\n      throw new Error('Unknown action type');\n    }\n  }\n};\n\nconst stringToNumber = (s: string) => +s;\nconst numberToString = (n: number) => n.toString();\nconst withinRange = (n: number, min: number, max: number) => n >= min && n <= max;\n\nconst findSegment = (segments: DateSegmentState[], type: EditableDateSegment): DateSegmentState => {\n  return segments.find((segment) => segment.type === type)!;\n};\n\n// A segment is considered complete if appending a zero to the current value causes it\n// to exceed the max. For instance, if you type 2-9 into month or 4-9 into day, the\n// segment is complete because you can't type any more digits and have it be a valid value.\nconst isSegmentComplete = (val: number, max: number) => {\n  const num = stringToNumber(numberToString(val) + '0');\n  return num > max;\n};\n\n// A date is considered complete if all of its segments have values.\nconst isDateComplete = (allSegments: DateSegmentState[]) => {\n  return allSegments.every((seg) => seg.text && seg.text.length > 0);\n};\n\n// A date is considered a partial date if at least one segment has a value.\nconst isPartialDate = (allSegments: DateSegmentState[]) => {\n  return allSegments.some((seg) => seg['aria-valuenow'] !== undefined);\n};\n\n// Construct a calendar date that reflects the values of each segment.\n// If none of the segments have a value, return undefined.\nconst createCalendarDateFromSegments = (segments: DateSegmentState[]) => {\n  const hasAnySegmentWithAValue = isPartialDate(segments);\n  if (!hasAnySegmentWithAValue) {\n    return undefined;\n  }\n\n  // This returns something that looks like [ {month: 12}, {day: 25}, {year: 2020} ].\n  // Note: we use the aria-valuenow to get the current value as a number (not string).\n  const segmentValues = segments.map((seg) => {\n    return { [seg.type]: seg['aria-valuenow'] };\n  });\n\n  // Iterate over segmentValues and spread each value to get {month: 12, day:25, year: 2020}.\n  const iterator = segmentValues.values();\n  let cd: CalendarDate = {};\n  for (const segValue of iterator) {\n    cd = { ...cd, ...segValue };\n  }\n  return cd;\n};\n\n// Find the current value for year.\nconst getYearValue = (segments: DateSegmentState[]) => {\n  const yearState = findSegment(segments, 'year');\n  return yearState['aria-valuenow'];\n};\n\n// Find the current value for month.\nconst getMonthValue = (segments: DateSegmentState[]) => {\n  const monthState = findSegment(segments, 'month');\n  return monthState['aria-valuenow'] as IsoMonth;\n};\n\n// Determine the aria-valuetext for the given month, which includes the month name.\nconst getMonthAria = (locale: BCP47Locale, month: IsoMonth, year: number | undefined) => {\n  const monthName = getMonthName(locale, month, year ?? '*', 'long');\n  return `${month} - ${monthName}`;\n};\n\n// Return a copy of the ordered segments array.\nconst getOrderedSegments = (currentState: DateFieldState) => {\n  return [...currentState.orderedSegments];\n};\n\n// Replace the updated segment and return a new DateSegmentState[].\nconst replaceDateSegment = (\n  existingSegments: DateSegmentState[],\n  updatedSegmentType: EditableDateSegment,\n  updatedSegment: DateSegmentState\n) => {\n  return existingSegments.map((seg) => (seg.type === updatedSegmentType ? updatedSegment : seg));\n};\n\n// Return a new DateSegmentState[] that reflects changes across all segments.\n// When you change the month this can affect the day, for instance.\nconst createDateSegmentStates = (\n  existingSegments: DateSegmentState[],\n  orderedSegments: EditableDateSegment[],\n  updatedSegmentType: EditableDateSegment,\n  updatedSegment: DateSegmentState,\n  autoAdvance: boolean\n) => {\n  const modifiedSegments = replaceDateSegment(existingSegments, updatedSegmentType, updatedSegment);\n  let updatedSegments = modifiedSegments;\n\n  if (updatedSegmentType === 'month' || updatedSegmentType === 'year') {\n    // If month was changed, update the day as needed; this includes adjusting the\n    // day value if it now exceeds the max number of days in the month.\n    // If year was changed, that can also affect the max number of days (if month is February).\n    const daySeg = findSegment(modifiedSegments, 'day');\n    if (daySeg) {\n      const monthValue =\n        updatedSegmentType == 'month'\n          ? (updatedSegment['aria-valuenow'] as IsoMonth)\n          : getMonthValue(modifiedSegments);\n      const yearValue =\n        updatedSegmentType === 'year'\n          ? updatedSegment['aria-valuenow']\n          : getYearValue(modifiedSegments);\n      const dayMax = getDaysInMonth(monthValue ?? '*', yearValue ?? '*');\n      const currentDay = daySeg['aria-valuenow'];\n      const dayValue = !!currentDay && currentDay > dayMax ? dayMax : currentDay;\n      const dayValueStr = !!dayValue ? numberToString(dayValue) : undefined;\n      const updatedDaySeg = {\n        ...daySeg,\n        'aria-valuemax': dayMax,\n        'aria-valuenow': dayValue,\n        'aria-valuetext': dayValueStr,\n        text: dayValueStr\n      };\n      updatedSegments = replaceDateSegment(modifiedSegments, 'day', updatedDaySeg);\n    }\n  }\n\n  // If the updatedSegment is complete, automatically select the next segment.\n  updatedSegments =\n    updatedSegment.isComplete && autoAdvance\n      ? selectNext(updatedSegments, orderedSegments)\n      : updatedSegments;\n\n  return updatedSegments;\n};\n\n// Construct a new DateFieldState from a set of updated segments.\nconst createDateFieldStateFromSegments = (\n  currentState: DateFieldState,\n  updatedSegments: DateSegmentState[]\n) => {\n  return {\n    currentDate: createCalendarDateFromSegments(updatedSegments),\n    isCompleteDate: isDateComplete(updatedSegments),\n    isDateSelected: currentState.isDateSelected,\n    isPartialDate: isPartialDate(updatedSegments),\n    orderedSegments: getOrderedSegments(currentState),\n    segments: updatedSegments\n  };\n};\n\n// Construct a new DateFieldState given an updated segment, which may affect other segments.\nconst createDateFieldState = (\n  currentState: DateFieldState,\n  updatedSegmentType: EditableDateSegment,\n  updatedSegment: DateSegmentState,\n  autoAdvance = true\n): DateFieldState => {\n  const updatedSegments = createDateSegmentStates(\n    currentState.segments,\n    currentState.orderedSegments,\n    updatedSegmentType,\n    updatedSegment,\n    autoAdvance\n  );\n\n  return createDateFieldStateFromSegments(currentState, updatedSegments);\n};\n\n// Return a new copy of the segment with the value cleared.\nconst clearSegment = (segmentState: DateSegmentState) => {\n  return {\n    ...segmentState,\n    'aria-valuetext': undefined,\n    'aria-valuenow': undefined,\n    text: undefined,\n    isComplete: false\n  };\n};\n\n// Return a new copy of segments with all values cleared and aria-valuemax adjusted.\nconst clearDate = (segments: DateSegmentState[]) => {\n  return segments.map((segmentState) => {\n    const cleared = clearSegment(segmentState);\n    const valueMax =\n      cleared.type === 'year'\n        ? MAX_ISO_YEAR\n        : cleared.type === 'month'\n        ? getMonthsInYear('*')\n        : getDaysInMonth('*', '*');\n    return { ...cleared, 'aria-valuemax': valueMax };\n  });\n};\n\n// Return a new copy of the segment with updated values.\nconst updateSegment = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  action: DateFieldAction,\n  segments: DateSegmentState[]\n) => {\n  const actionText = action.data?.text!;\n  const hasLeadingZero = action.data?.hasLeadingZero;\n  const locale = action.data?.locale!;\n  const minValue = segmentState['aria-valuemin']!;\n  const maxValue = segmentState['aria-valuemax']!;\n  const wasComplete = segmentState.isComplete;\n\n  // If the segment was already complete, replace any existing text with actionText.\n  // Otherwise append actionText onto existing text to get the requested string.\n  // For instance if the existing text is '1' and actionText (i.e. that the user typed)\n  // is '2' then requestedValStr is '12'.\n  const requestedValStr = wasComplete ? actionText : segmentState.text + actionText;\n\n  // If the requested value is out of range, discard the existing text/value and only\n  // keep the new one. Check if the segment is complete.\n  const requestedVal = stringToNumber(requestedValStr);\n  const inRange = withinRange(requestedVal, minValue, maxValue);\n  const newValStr = inRange ? requestedValStr : actionText;\n  const newVal = inRange ? requestedVal : stringToNumber(actionText);\n  const isComplete =\n    isSegmentComplete(newVal, maxValue) || (!!hasLeadingZero && segmentType !== 'year');\n\n  // For month changes, aria-valuetext includes the month name.\n  const ariaValueText =\n    segmentType === 'month'\n      ? getMonthAria(locale, newVal as IsoMonth, getYearValue(segments))\n      : newValStr;\n\n  // Create a new segment state that reflects the updated value.\n  return {\n    ...segmentState,\n    'aria-valuetext': ariaValueText,\n    'aria-valuenow': newVal,\n    text: newValStr,\n    isComplete\n  };\n};\n\n// Return a new DateSegmentState[] where the specified segment is selected, all others cleared.\nconst selectSegment = (segments: DateSegmentState[], segmentType: EditableDateSegment) => {\n  return segments.map((seg) => {\n    return { ...seg, isSelected: seg.type === segmentType ? true : false };\n  });\n};\n\n// Return a new DateSegmentState[] where the first segment is selected.\nconst selectFirst = (segments: DateSegmentState[], orderedSegments: EditableDateSegment[]) => {\n  return selectSegment(segments, orderedSegments[0]);\n};\n\n// Find the index of the selected segment in the ordered list; return -1 if there is no selection.\nconst getSelectedSegmentIndex = (\n  segments: DateSegmentState[],\n  orderedSegments: EditableDateSegment[]\n) => {\n  const sel = segments.find((seg) => seg.isSelected === true);\n  return sel === undefined ? -1 : orderedSegments.findIndex((type) => type === sel.type);\n};\n\n// Convenience function to mark the selected segment complete.\nconst markSelectedSegmentComplete = (segments: DateSegmentState[]) => {\n  return segments.map((seg) => (seg.isSelected ? { ...seg, isComplete: true } : seg));\n};\n\n// Select the segment following the one that is currently selected.\nconst selectNext = (segments: DateSegmentState[], orderedSegments: EditableDateSegment[]) => {\n  const selectedIndex = getSelectedSegmentIndex(segments, orderedSegments);\n  const max = orderedSegments.length - 1;\n\n  // If we're already at the last position, do nothing. Note if nothing was currently selected\n  // then selectedIndex is -1. The first segment will be selected.\n  return selectedIndex === max\n    ? segments\n    : selectSegment(markSelectedSegmentComplete(segments), orderedSegments[selectedIndex + 1]);\n};\n\n// Select the segment prior to the one that is currently selected.\nconst selectPrevious = (segments: DateSegmentState[], orderedSegments: EditableDateSegment[]) => {\n  const selectedIndex = getSelectedSegmentIndex(segments, orderedSegments);\n  return selectedIndex === 0\n    ? segments\n    : selectedIndex === -1\n    ? selectFirst(segments, orderedSegments)\n    : selectSegment(markSelectedSegmentComplete(segments), orderedSegments[selectedIndex - 1]);\n};\n\n// Return a new DateSegmentState[] where all segments are unselected and any values are\n// marked complete. We want to do this when the user commits the DateField value (on blur).\nconst clearSelectionAndComplete = (segments: DateSegmentState[]) => {\n  return segments.map((seg) => {\n    return { ...seg, isSelected: false, isComplete: !!seg.text };\n  });\n};\n\n// Return a new DateSegmentState[] where all segments are unselected.\nconst clearSelection = (segments: DateSegmentState[]) => {\n  return segments.map((seg) => {\n    return { ...seg, isSelected: false };\n  });\n};\n\n// Return a new DateFieldState where the entire date is selected if the date is complete,\n// or the first segment is selected.\nconst selectDateOrSegment = (currentState: DateFieldState) => {\n  if (currentState.isCompleteDate) {\n    return createDateFieldStateWithSelectedDate(\n      currentState,\n      clearSelection(currentState.segments),\n      true\n    );\n  } else {\n    const updatedSegments = selectFirst(currentState.segments, currentState.orderedSegments);\n    return createDateFieldStateFromSegments(currentState, updatedSegments);\n  }\n};\n\n// Create a new DateFieldState from the updatedSegments and isDateSelected params.\nconst createDateFieldStateWithSelectedDate = (\n  currentState: DateFieldState,\n  updatedSegments: DateSegmentState[],\n  isDateSelected: boolean\n) => {\n  return {\n    currentDate: createCalendarDateFromSegments(updatedSegments),\n    isCompleteDate: isDateComplete(updatedSegments),\n    isDateSelected,\n    isPartialDate: isPartialDate(updatedSegments),\n    orderedSegments: getOrderedSegments(currentState),\n    segments: updatedSegments\n  };\n};\n\nconst YEAR_HOME_VALUE = 1900;\nconst YEAR_END_VALUE = 2100;\n\n// If a segment is empty, use today's date as a starting point for any step or page action.\nconst getDefaultSegmentValue = (segmentType: EditableDateSegment) => {\n  const { year: yearDefault, month: monthDefault, day: dayDefault } = getTodayAsCalendarDate();\n  const defaults = { year: yearDefault, month: monthDefault, day: dayDefault };\n  return defaults[segmentType];\n};\n\n// Get the minimum value for the segment.\nconst getHomeSegmentValue = (segmentType: EditableDateSegment, segmentState: DateSegmentState) => {\n  return segmentType === 'year' ? YEAR_HOME_VALUE : segmentState['aria-valuemin']!;\n};\n\n// Get the maximum value for the segment (for year, this is YEAR_END_VALUE).\nconst getEndSegmentValue = (segmentType: EditableDateSegment, segmentState: DateSegmentState) => {\n  return segmentType === 'year' ? YEAR_END_VALUE : segmentState['aria-valuemax']!;\n};\n\n// Return the result of stepping currentValue in the requested direction, taking into account min and max.\nconst getSteppedSegmentValue = (\n  currentValue: number,\n  direction: DateFieldActionData['direction'],\n  min: number,\n  max: number\n) => {\n  const newValue =\n    direction === 'increase'\n      ? currentValue + 1 > max\n        ? min\n        : currentValue + 1\n      : currentValue - 1 < min\n      ? max\n      : currentValue - 1;\n  return newValue;\n};\n\n// Return the result of paging the value up or down, taking into account min and max.\nconst getPagedSegmentValue = (\n  currentValue: number,\n  direction: DateFieldActionData['direction'],\n  min: number,\n  max: number,\n  segmentType: EditableDateSegment\n) => {\n  const step = segmentType === 'month' ? 2 : segmentType === 'year' ? 5 : 7;\n  const newValue =\n    direction === 'increase'\n      ? currentValue + step > max\n        ? (currentValue + step) % max\n        : currentValue + step\n      : currentValue - step < min\n      ? currentValue - step + max\n      : currentValue - step;\n  return newValue;\n};\n\n// Create a new segment with an updated value from a keyboard action such as step, page, Home, or End.\nconst createSegmentFromKeyboardAction = (\n  newVal: number,\n  locale: BCP47Locale,\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[]\n) => {\n  const newValStr = numberToString(newVal);\n  // For month changes, aria-valuetext includes the month name.\n  const ariaValueText =\n    segmentType === 'month'\n      ? getMonthAria(locale, newVal as IsoMonth, getYearValue(segments))\n      : newValStr;\n\n  // Create a new segment state that reflects the updated value.\n  // After any keyboard action, the value is complete so that if the user types anything,\n  // it will replace the stepped value.\n  return {\n    ...segmentState,\n    'aria-valuetext': ariaValueText,\n    'aria-valuenow': newVal,\n    text: newValStr,\n    isComplete: true\n  };\n};\n\n// Set the segment to its minimum value.\nconst goToHome = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[],\n  locale: BCP47Locale\n) => {\n  const newValue = getHomeSegmentValue(segmentType, segmentState);\n  return createSegmentFromKeyboardAction(newValue, locale, segmentType, segmentState, segments);\n};\n\n// Set the segment to its maximum value.\nconst goToEnd = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[],\n  locale: BCP47Locale\n) => {\n  const newValue = getEndSegmentValue(segmentType, segmentState);\n  return createSegmentFromKeyboardAction(newValue, locale, segmentType, segmentState, segments);\n};\n\n// Step or page a segment's value.\nconst doStepOrPage = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[],\n  type: 'step' | 'page',\n  direction: DateFieldActionData['direction'],\n  locale: BCP47Locale\n) => {\n  const valueNow = segmentState['aria-valuenow'];\n  const min = segmentState['aria-valuemin']!;\n  const max = segmentState['aria-valuemax']!;\n  const newValue =\n    valueNow === undefined\n      ? getDefaultSegmentValue(segmentType)\n      : type === 'page'\n      ? getPagedSegmentValue(valueNow, direction, min, max, segmentType)\n      : getSteppedSegmentValue(valueNow, direction, min, max);\n\n  return createSegmentFromKeyboardAction(newValue, locale, segmentType, segmentState, segments);\n};\n\nexport { dateReducer, getMonthAria, numberToString, stringToNumber };\nexport type { DateFieldAction, DateFieldActionData };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComponentProps, Ref } from 'preact';\nimport {\n  AriaAttributesSignalExcluded,\n  HTMLAttributesSignalExcluded\n} from '#utils/UNSAFE_attributeUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { DateSegment } from './DateSegment';\nimport { DateSegmentState } from './useDateField';\nimport { Flex } from '#UNSAFE_Flex';\nimport { HiddenAccessible } from '#UNSAFE_HiddenAccessible';\nimport { InputDateMask } from './InputDateMask';\nimport { LiteralSegment } from './LiteralSegment';\nimport { LiveRegion } from '#UNSAFE_LiveRegion';\nimport { merge } from '#utils/UNSAFE_stringUtils';\nimport { useComponentTheme } from '#hooks/UNSAFE_useComponentTheme';\nimport { useDateField } from './useDateField';\nimport { useDateFieldHandlers } from './useDateFieldHandlers';\nimport { useFormFieldContext } from '#hooks/UNSAFE_useFormFieldContext';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { TextFieldInputVariantOptions } from '#UNSAFE_TextField/themes/TextFieldInputStyles.css';\nimport { TextFieldInputRedwoodTheme } from '#UNSAFE_TextField/themes/redwood/TextFieldInputTheme';\nimport type { DatePlaceholders, EditableDateSegment } from './types';\nimport { formatFullCalendarDate } from '#utils/UNSAFE_calendarDateUtils';\n\ntype InputDateMaskProps = ComponentProps<typeof InputDateMask>;\n\ntype AriaProps = Pick<\n  AriaAttributesSignalExcluded,\n  'aria-describedby' | 'aria-invalid' | 'aria-label' | 'aria-labelledby'\n>;\n\ntype HTMLElementProps = Pick<HTMLAttributesSignalExcluded<HTMLElement>, 'onBlur' | 'onFocus'>;\n\nexport type Props = AriaProps &\n  HTMLElementProps & {\n    /**\n     * A base id prefix.\n     */\n    baseId: string;\n\n    /**\n     * A ref to the outer div element.\n     */\n    fieldRef?: Ref<HTMLDivElement>;\n\n    /**\n     * Specifies the smallest date unit that is displayed by the component.\n     * If set to month, only month and year are shown.\n     * If set to day then month, day, and year are shown.\n     */\n    granularity?: InputDateMaskProps['granularity'];\n\n    /**\n     * True if the component has an inside label.\n     */\n    hasInsideLabel?: boolean;\n\n    /**\n     * Specifies for accessibility purposes whether a value is required.\n     */\n    isRequired?: InputDateMaskProps['isRequired'];\n\n    /**\n     * The placeholder masks used by the date field.\n     */\n    masks: DatePlaceholders;\n\n    /**\n     * Specifies how to align text within the field.\n     */\n    textAlign?: InputDateMaskProps['textAlign'];\n\n    /**\n     * The current display value of the component.\n     */\n    value?: InputDateMaskProps['value'];\n\n    /**\n     * The style variant of the component.\n     */\n    variant?: InputDateMaskProps['variant'];\n\n    /**\n     * Callback invoked each time the user changes the value of a segment For example, if the user\n     * types '12' into the month segment, this callback will be called twice to change the month\n     * first to '1' and then '12'.\n     */\n    onInput: InputDateMaskProps['onInput'];\n\n    /**\n     * Callback invoked when the user commits the entered value by blurring or hitting the enter key.\n     */\n    onCommit: InputDateMaskProps['onCommit'];\n  };\n\nconst findSegment = (segments: DateSegmentState[], type: EditableDateSegment): DateSegmentState => {\n  return segments.find((segment) => segment.type === type)!;\n};\n\n/**\n * Container for Segment children that represent different parts of a date with no time.\n */\nconst DateField = ({\n  'aria-describedby': describedBy,\n  'aria-invalid': ariaInvalid,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  baseId,\n  fieldRef,\n  granularity = 'day',\n  hasInsideLabel,\n  isRequired,\n  masks: dateMasks,\n  onBlur,\n  onCommit,\n  onFocus,\n  onInput,\n  textAlign,\n  value,\n  variant = 'default'\n}: Props) => {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const announceDateCleared = translations.inputDateMask_date_cleared();\n  const labels = {\n    month: translations.formControl_month(),\n    day: translations.formControl_day(),\n    year: translations.formControl_year()\n  };\n\n  const { direction, locale } = useUser();\n\n  const { isDisabled, isFocused, isInputFocused } = useFormFieldContext();\n  const hasValue = value !== undefined;\n\n  // DateField is similar to TextFieldInput for styling. The main difference\n  // is TextFieldInput renders a textarea or input and DateField renders a div, so the positioning with\n  // padding is different. DateField and TextFieldInput are both the mainContent\n  // of a TextField component.\n  const { classes } = useComponentTheme<TextFieldInputVariantOptions>(TextFieldInputRedwoodTheme, {\n    type: 'notPassword',\n    styleVariant: variant,\n    textarea: 'notTextArea',\n    input: 'notInput',\n    div: 'isDiv',\n    prefix: 'noPrefix',\n    suffix: 'noSuffix',\n    startContent: 'noStartContent',\n    endContent: 'noEndContent',\n    insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',\n    value: hasValue ? 'hasValue' : 'noValue',\n    focused: isFocused ? 'isFocused' : 'notFocused',\n    disabled: isDisabled ? 'isDisabled' : 'notDisabled'\n  });\n\n  const compClasses = classNames([classes]);\n\n  const { state, dispatch, dateResetRef } = useDateField({\n    ariaLabels: labels,\n    dateMasks,\n    granularity,\n    locale,\n    value\n  });\n  const { isDateSelected, isPartialDate, segments: editableSegments } = state;\n  const yearSegment = findSegment(editableSegments, 'year');\n  const monthSegment = findSegment(editableSegments, 'month');\n  const daySegment = granularity === 'day' ? findSegment(editableSegments, 'day') : undefined;\n  const segmentsMap = {\n    year: yearSegment,\n    month: monthSegment,\n    day: daySegment\n  };\n\n  const { dateClearedRef, dateFieldHandlers, segmentHandlers, tabIndex } = useDateFieldHandlers({\n    dateResetRef,\n    direction,\n    dispatch,\n    isDisabled,\n    isFocused,\n    isInputFocused,\n    onCommit,\n    onInput,\n    state\n  });\n\n  // Like other form components, don't show placeholders for inside labels unless focused.\n  // This flag causes the segment placeholders to be hidden.\n  const isHidden = value === undefined && hasInsideLabel && !isFocused;\n\n  // If the date is complete, create a hidden accessible region with the full formatted date.\n  const formattedDateStr = !state.isCompleteDate\n    ? ''\n    : formatFullCalendarDate(locale, state.currentDate!, granularity);\n\n  const formattedDateAriaId = `${baseId}-date`;\n  const formattedDateAria = state.isCompleteDate ? (\n    <HiddenAccessible id={formattedDateAriaId}>{formattedDateStr}</HiddenAccessible>\n  ) : undefined;\n  const ariaDescribedBy = state.isCompleteDate\n    ? merge([describedBy, formattedDateAriaId])\n    : describedBy;\n\n  // Add an announcement to the live region if the date was cleared.\n  // Note: we deliberately do not reset dateClearedRef because there are multiple\n  // rerenders after clearing the date and we want to make sure the announcement\n  // has time to be heard.\n  const announceText = dateClearedRef.current ? announceDateCleared : '';\n\n  return (\n    <div\n      aria-describedby={ariaDescribedBy}\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      class={compClasses}\n      onfocusin={onFocus}\n      onfocusout={onBlur}\n      role=\"group\"\n      ref={fieldRef}\n      tabIndex={tabIndex}\n      {...dateFieldHandlers}>\n      <Flex direction=\"row\" wrap=\"nowrap\" justify={textAlign}>\n        {dateMasks.map(({ type, value: placeholder }) => {\n          const segmentProps = type !== 'literal' ? segmentsMap[type] : {};\n          if (type === 'literal') {\n            return (\n              <LiteralSegment\n                isHidden={isHidden}\n                isHighlighted={isDateSelected}\n                isPlaceholder={!isPartialDate}\n                text={placeholder}></LiteralSegment>\n            );\n          } else {\n            return (\n              <DateSegment\n                isDisabled={isDisabled}\n                isInvalid={!!ariaInvalid}\n                isHidden={isHidden}\n                isHighlighted={isDateSelected}\n                isRequired={isRequired}\n                placeholder={placeholder}\n                type={type}\n                {...segmentHandlers}\n                {...segmentProps}></DateSegment>\n            );\n          }\n        })}\n      </Flex>\n      {formattedDateAria}\n      <LiveRegion>{announceText}</LiveRegion>\n    </div>\n  );\n};\n\nexport { DateField, findSegment };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComponentProps } from 'preact';\nimport { useReducer, useRef } from 'preact/hooks';\nimport { BCP47Locale } from '#UNSAFE_IntlDateTime';\nimport { DateField } from './DateField';\nimport { CalendarDate, DateGranularity, DatePlaceholders, EditableDateSegment } from './types';\nimport { DateSegment } from './DateSegment';\nimport { dateReducer, getMonthAria, numberToString } from './dateReducer';\nimport { calendarDatesAreDifferent } from '../utils/PRIVATE_dayUtils';\nimport {\n  getDaysInMonth,\n  getMonthsInYear,\n  MIN_ISO_YEAR,\n  MAX_ISO_YEAR,\n  MIN_ISO_DAY,\n  MIN_ISO_MONTH\n} from '../utils/UNSAFE_calendarDateUtils';\n\ntype DateFieldType = ComponentProps<typeof DateField>;\n\ntype useDateFieldProps = {\n  ariaLabels: Record<EditableDateSegment, string>;\n  dateMasks: DatePlaceholders;\n  granularity: DateGranularity;\n  locale: BCP47Locale;\n  value: DateFieldType['value'];\n};\n\ntype DateSegmentState = Readonly<ComponentProps<typeof DateSegment>>;\n\ntype DateFieldState = {\n  readonly currentDate: CalendarDate | undefined;\n  readonly isCompleteDate: boolean;\n  readonly isDateSelected: boolean;\n  readonly isPartialDate: boolean;\n  readonly orderedSegments: EditableDateSegment[];\n  readonly segments: DateSegmentState[];\n};\n\n/**\n * Hook that returns a DateFieldState and a dispatch method to request changes to that state.\n */\nconst useDateField = ({\n  ariaLabels,\n  dateMasks,\n  granularity,\n  locale,\n  value: currentValue\n}: useDateFieldProps) => {\n  // Construct an ordered list of the editable segments, i.e. ['month', 'day', 'year'].\n  const fdm = dateMasks.filter(({ type }) => type !== 'literal');\n  const orderedSegments = fdm.map(({ type }) => type) as EditableDateSegment[];\n\n  // Derive some data from currentValue that will become part of our initial state.\n  const yearValue = currentValue?.year;\n  const monthValue = currentValue?.month;\n  const dayValue = currentValue?.day;\n  const monthMax = getMonthsInYear(yearValue ?? '*');\n  const dayMax = getDaysInMonth(monthValue ?? '*', yearValue ?? '*');\n  const isCompleteDate = !!yearValue && !!monthValue && (granularity === 'month' || !!dayValue);\n  const isPartialDate = !!yearValue || !!monthValue || !!dayValue;\n  const yearValueStr = yearValue ? numberToString(yearValue) : undefined;\n  const monthValueStr = monthValue ? numberToString(monthValue) : undefined;\n  const dayValueStr = dayValue ? numberToString(dayValue) : undefined;\n  const monthAria = monthValue ? getMonthAria(locale, monthValue, yearValue) : undefined;\n\n  const daySeg = [\n    {\n      type: 'day' as EditableDateSegment,\n      'aria-label': ariaLabels.day,\n      'aria-valuemin': MIN_ISO_DAY,\n      'aria-valuemax': dayMax,\n      'aria-valuenow': dayValue,\n      'aria-valuetext': dayValueStr,\n      isComplete: !!dayValue,\n      isSelected: false,\n      text: dayValueStr\n    }\n  ];\n\n  // Create state for each editable segment of a date, i.e. year, month, or day.\n  const editableSegments = [\n    {\n      type: 'year' as EditableDateSegment,\n      'aria-label': ariaLabels.year,\n      'aria-valuemin': MIN_ISO_YEAR,\n      'aria-valuemax': MAX_ISO_YEAR,\n      'aria-valuenow': yearValue,\n      'aria-valuetext': yearValueStr,\n      isComplete: !!yearValue,\n      isSelected: false,\n      text: yearValueStr\n    },\n    {\n      type: 'month' as EditableDateSegment,\n      'aria-label': ariaLabels.month,\n      'aria-valuemin': MIN_ISO_MONTH,\n      'aria-valuemax': monthMax,\n      'aria-valuenow': monthValue,\n      'aria-valuetext': monthAria,\n      isComplete: !!monthValue,\n      isSelected: false,\n      text: monthValueStr\n    },\n    ...(granularity === 'day' ? daySeg : [])\n  ];\n\n  // Create the initial state to pass to our reducer.\n  const initialState: DateFieldState = {\n    currentDate: currentValue,\n    isCompleteDate,\n    isDateSelected: false,\n    isPartialDate,\n    orderedSegments,\n    segments: editableSegments\n  };\n\n  const [state, dispatch] = useReducer(dateReducer, initialState);\n\n  // currentValue is the controlled value passed from the parent.\n  const lastValueFromParentRef = useRef<CalendarDate | undefined>(currentValue);\n  const dateResetRef = useRef<boolean>(false);\n\n  // If a new value is being pushed from the parent, and that value differs from\n  // the current value of the reducer, then this is a programmatic update\n  // and we need to call 'reset' to update the reducer state. Otherwise, the only\n  // time the reducer state is updated from the value is on mount.\n  if (calendarDatesAreDifferent(lastValueFromParentRef.current, currentValue)) {\n    lastValueFromParentRef.current = currentValue;\n    if (calendarDatesAreDifferent(currentValue, state.currentDate)) {\n      dispatch({ actionType: 'reset', data: initialState });\n      dateResetRef.current = true;\n    }\n  }\n\n  return { dateResetRef, dispatch, state };\n};\n\nexport { useDateField };\nexport type { DateFieldState, DateSegmentState };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComponentProps } from 'preact';\nimport { Dispatch, MutableRef, useCallback, useEffect, useRef } from 'preact/hooks';\nimport { calendarDatesAreDifferent } from '#utils/PRIVATE_dayUtils';\nimport { DateFieldAction } from './dateReducer';\nimport { DateFieldState } from './useDateField';\nimport { CalendarDate, EditableDateSegment } from './types';\nimport { isBackspaceOrDelete } from '#utils/PRIVATE_keyboardUtils';\nimport { InputDateMask } from './InputDateMask';\nimport { useTabbableMode } from '#hooks/UNSAFE_useTabbableMode';\n\ntype InputDateMaskProps = ComponentProps<typeof InputDateMask>;\n\ntype Props = {\n  dateResetRef: MutableRef<boolean>;\n  direction: 'ltr' | 'rtl';\n  dispatch: Dispatch<DateFieldAction>;\n  isDisabled?: boolean;\n  isFocused?: boolean;\n  isInputFocused?: boolean;\n  onCommit: InputDateMaskProps['onCommit'];\n  onInput: InputDateMaskProps['onInput'];\n  state: DateFieldState;\n};\n\n/**\n * A hook that creates various handlers and manages effects for a DateField.\n */\nconst useDateFieldHandlers = ({\n  dateResetRef,\n  direction,\n  dispatch,\n  isDisabled,\n  isFocused,\n  isInputFocused,\n  onCommit,\n  onInput,\n  state\n}: Props) => {\n  const { tabbableModeProps } = useTabbableMode();\n  const { tabIndex: tabbableModeIndex } = tabbableModeProps;\n  const anySegmentSelected = state.segments.some((segment) => !!segment.isSelected);\n\n  // If any segment is selected, it is contenteditable=true and it has the focus. If you shift-Tab, you will\n  // land on the outer div (DateField) first meaning it takes 2 shift-tab keys to get the previous element.\n  // To prevent this, if any segment is selected the tabindex on the div is set to -1.\n  // We also need to set tabindex to -1 for the disabled case, since we are dealing with a div instead\n  // of an intrinsic input and have to handle it directly.\n  const updatedTabIndex = tabbableModeIndex === -1 || anySegmentSelected || isDisabled ? -1 : 0;\n\n  // Keep track of the last changed and last committed date values.\n  const lastDateRef = useRef<CalendarDate | undefined>(state.currentDate);\n  const lastCommittedDateRef = useRef<CalendarDate | undefined>(state.currentDate);\n  // Keep track whether the date was cleared.\n  const dateClearedRef = useRef<boolean>(false);\n  const lastFocusedRef = useRef<boolean>(!!isFocused);\n\n  // Handle requested segment changes by calling the reducer dispatch function.\n  const onChange = useCallback(\n    (action: DateFieldAction) => {\n      dispatch(action);\n    },\n    [dispatch]\n  );\n\n  // If the user clicked on a segment, dispatch a request to select it.\n  // If they clicked on the date field itself, select the first segment.\n  const onClick = useCallback(\n    (e: Event) => {\n      const segmentType = (e.target as HTMLElement).getAttribute(\n        'data-segment'\n      ) as EditableDateSegment;\n      !!segmentType\n        ? dispatch({ actionType: 'selectSegment', data: { type: segmentType } })\n        : dispatch({ actionType: 'selectFirst' });\n    },\n    [dispatch]\n  );\n\n  // Double click selects the entire date, if complete, or the first segment.\n  const onDoubleClick = () => {\n    dispatch({ actionType: 'selectDateOrSegment' });\n  };\n\n  // Handle arrow key navigation between segments. If no segment is currently selected, then select the first one.\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (\n        (direction === 'ltr' && event.key === 'ArrowLeft') ||\n        (direction === 'rtl' && event.key === 'ArrowRight')\n      ) {\n        // Select the previous segment when pressing Left arrow (or Right arrow in rtl).\n        dispatch({ actionType: 'selectPrevious' });\n        event.stopPropagation();\n      } else if (\n        (direction === 'ltr' && event.key === 'ArrowRight') ||\n        (direction === 'rtl' && event.key === 'ArrowLeft')\n      ) {\n        // Select the next segment when pressing Right arrow (or Left arrow in rtl).\n        dispatch({ actionType: 'selectNext' });\n        event.stopPropagation();\n      } else if (isBackspaceOrDelete(event)) {\n        // Clear the entire date.\n        dispatch({ actionType: 'clearDate' });\n        dateClearedRef.current = true;\n        event.stopPropagation();\n      } else if (event.key === 'Enter') {\n        // Hitting Enter commits any changes.\n        if (calendarDatesAreDifferent(lastCommittedDateRef.current, lastDateRef.current)) {\n          onCommit?.({ value: lastDateRef.current });\n          lastCommittedDateRef.current = lastDateRef.current;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    },\n    [direction, dispatch, onCommit]\n  );\n\n  // Blurring commits the date value; clear any selected segments and mark non-empty segments as complete.\n  useEffect(() => {\n    if (lastFocusedRef.current && !isFocused) {\n      dispatch({ actionType: 'commit' });\n      if (calendarDatesAreDifferent(lastCommittedDateRef.current, lastDateRef.current)) {\n        onCommit?.({ value: lastDateRef.current });\n        lastCommittedDateRef.current = lastDateRef.current;\n      }\n    }\n    lastFocusedRef.current = !!isFocused;\n  }, [dispatch, isFocused, onCommit]);\n\n  // If you try to call onInput from onChange directly it doesn't work. The value of\n  // state.currentDate is from the current render, not the render *after* the dispatch.\n  // So wait for the state to finish updating.\n  useEffect(() => {\n    if (\n      calendarDatesAreDifferent(lastDateRef.current, state.currentDate) &&\n      !dateResetRef.current\n    ) {\n      const frozenDate =\n        state.currentDate !== undefined\n          ? Object.freeze({ ...state.currentDate })\n          : state.currentDate;\n      onInput({ value: frozenDate });\n      lastDateRef.current = frozenDate;\n    }\n    dateResetRef.current = false;\n  }, [onInput, state.currentDate, dateResetRef]);\n\n  // The following is a simplified version of how we detect keyboard vs. mouse focus\n  // in the useCollectionFocusRing hook. If the user tabs onto the field, we want to\n  // automatically select the first segment.\n  const recentPointerRef = useRef<boolean>(false);\n  const pointerDownTimerRef = useRef<ReturnType<typeof setTimeout> | undefined>();\n  const onPointerDown = () => {\n    recentPointerRef.current = true;\n    clearTimeout(pointerDownTimerRef.current);\n\n    pointerDownTimerRef.current = setTimeout(() => {\n      recentPointerRef.current = false;\n    }, 200);\n  };\n\n  useEffect(() => {\n    // If we receive focus that is *not* due to the user clicking in the field, i.e. the user\n    // tabbed onto the field, then select the first segment.\n    // Note: we cannot check isFocused because it includes the ? icon in compact UAD, and we don't\n    // want the date selected when the help icon is focused.\n    isInputFocused && !recentPointerRef.current && dispatch({ actionType: 'selectFirst' });\n\n    // If we lose focus due to the keyboard, i.e. shift-tabbing onto the compact UAD help icon,\n    // then 'commit' which will clear any selected segments.\n    !isInputFocused && !recentPointerRef.current && dispatch({ actionType: 'commit' });\n    recentPointerRef.current = false;\n  }, [dispatch, isInputFocused]);\n\n  return {\n    dateClearedRef,\n    dateFieldHandlers: isDisabled ? {} : { onClick, onDoubleClick, onKeyDown, onPointerDown },\n    segmentHandlers: isDisabled ? {} : { onChange },\n    tabIndex: updatedTabIndex\n  };\n};\n\nexport { useDateFieldHandlers };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComponentProps, Ref } from 'preact';\nimport { forwardRef } from 'preact/compat';\nimport { useCallback, useMemo, useRef } from 'preact/hooks';\n\nimport { AriaAttributesSignalExcluded } from '#utils/UNSAFE_attributeUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport type { CalendarDate, DatePlaceholders } from './types';\nimport {\n  CompactUserAssistance,\n  InlineUserAssistance,\n  UserAssistanceDensityType\n} from '#UNSAFE_UserAssistance';\nimport { DateField } from './DateField';\nimport { FormFieldContext } from '#hooks/UNSAFE_useFormFieldContext';\nimport { getDatePlaceholderMasks, formatShortCalendarDate } from '#utils/UNSAFE_calendarDateUtils';\nimport { translateCustomMasks } from '#utils/PRIVATE_dayUtils';\nimport { Label } from '#UNSAFE_Label';\nimport { ReadonlyTextField, ReadonlyTextFieldInput, TextField } from '#UNSAFE_TextField';\nimport { Size } from '#utils/UNSAFE_size';\nimport type { TestIdProps } from '#hooks/UNSAFE_useTestId';\nimport type { TextProps } from '#utils/UNSAFE_interpolations/text';\nimport { useFocusableTextField, FocusableHandle } from '#hooks/UNSAFE_useFocusableTextField';\nimport { useFormContext } from '#hooks/UNSAFE_useFormContext';\nimport { useTextField } from '#hooks/UNSAFE_useTextField';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { ValueUpdateDetail } from '#utils/UNSAFE_valueUpdateDetail';\nimport { LayoutColumnSpan } from '../utils/UNSAFE_styles/Layout';\n\ntype InlineUserAssistanceProps = ComponentProps<typeof InlineUserAssistance>;\n\ntype Props = TestIdProps & {\n  /**\n   * The ID of an element (or space separated IDs of multiple elements) that\n   * describes the input.\n   */\n  'aria-describedby'?: AriaAttributesSignalExcluded['aria-describedby'];\n\n  /**\n   * Text to provide guidance to help the user understand what data to enter.\n   */\n  assistiveText?: InlineUserAssistanceProps['assistiveText'];\n\n  /**\n   * Specifies how many columns to span in a FormLayout with direction === 'row'\n   */\n  columnSpan?: LayoutColumnSpan;\n\n  /**\n   * Specifies the smallest date unit that is displayed by the component.\n   * If set to month, only month and year are shown.\n   * If set to day then month, day, and year are shown.\n   */\n  granularity?: 'month' | 'day';\n\n  /**\n   * Help source URL associated with the component.\n   */\n  helpSourceLink?: InlineUserAssistanceProps['helpSourceLink'];\n\n  /**\n   * Custom text to be rendered for the <code>helpSourceLink</code>.\n   */\n  helpSourceText?: InlineUserAssistanceProps['helpSourceText'];\n\n  /**\n   * Specifies whether the component is disabled.\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Specifies whether the component is readonly.\n   */\n  isReadonly?: boolean;\n\n  /**\n   * Specifies for accessibility purposes whether a value is required.\n   *\n   * Setting this property to <code>false</code> means that a value is not required to be\n   * committed by the user. Setting this property to <code>true</code> means that a value\n   * is required to be committed by the user.\n   */\n  isRequired?: boolean;\n\n  /**\n   * Specifies whether to show an indicator on screen that a value is required, for example\n   * before the user has committed a value.\n   */\n  isRequiredShown?: InlineUserAssistanceProps['isRequiredShown'];\n\n  /**\n   * Specifies the label associated with the field.\n   */\n  label: string;\n\n  /**\n   * Specifies where the label is positioned relative to the field.\n   */\n  labelEdge?: 'inside' | 'start' | 'top' | 'none';\n\n  /**\n   * Specifies the width of the label when <code>labelEdge</code> is <code>\"start\"</code>.\n   */\n  labelStartWidth?: Size;\n\n  /**\n   * If specified, overrides the locale specific order of the individual date segments as\n   * well as the locale specific separator. The value of each placeholder is only used\n   * when the type is 'literal', otherwise it is replaced with a translated placeholder\n   * for month, day, or year. If masks are specified and granularity = day, then the\n   * placeholders must include month, day, and year. If granularity = month, then the\n   * placeholders must include month and year, but not day.\n   */\n  masks?: DatePlaceholders;\n\n  /**\n   * Messages to show on screen that are associated with the component.\n   */\n  messages?: InlineUserAssistanceProps['messages'];\n\n  /**\n   * Specifies how to align text within the field.\n   */\n  textAlign?: TextProps['textAlign'];\n\n  /**\n   * Specifies the density of the user assistance presentation. It can be set to:\n   * <ul>\n   * <li><code>'efficient'</code>: Show inline and reserve space to prevent layout reflow when user\n   * assistance text is displayed.</li>\n   * <li><code>'reflow'</code>: Show inline. Layout will reflow when text is displayed.</li>\n   * <li><code>'compact'</code>: Messages, help, hints, and required will not be shown inline; they will show in a mode that keeps the screen more compact, like a popup for the messages, and a required icon to indicate Required. </li>\n   * </ul>\n   */\n  userAssistanceDensity?: UserAssistanceDensityType;\n\n  /**\n   * The current display value of the component.\n   */\n  value?: CalendarDate;\n\n  /**\n   * The style variant of the component.\n   */\n  variant?: 'default' | 'embedded';\n\n  /**\n   * Callback invoked when the user commits the entered value by blurring or hitting the enter key.\n   */\n  onCommit?: (detail: ValueUpdateDetail<CalendarDate>) => void;\n\n  /**\n   * Callback invoked each time the user changes the value of a segment For example, if the user\n   * types '12' into the month segment, this callback will be called twice to change the month\n   * first to '1' and then '12'.\n   */\n  onInput: (detail: ValueUpdateDetail<CalendarDate>) => void;\n};\n\n/**\n * An InputDateMask allows you to edit the month, day, and year fields of a calendar date.\n */\nexport const InputDateMask = forwardRef(\n  (\n    {\n      'aria-describedby': ariaDescribedBy,\n      assistiveText,\n      columnSpan,\n      granularity = 'day',\n      helpSourceLink,\n      helpSourceText,\n      isDisabled: propIsDisabled,\n      isReadonly: propIsReadonly,\n      isRequired,\n      isRequiredShown,\n      label,\n      labelEdge: propLabelEdge,\n      labelStartWidth: propLabelStartWidth,\n      messages,\n      masks,\n      testId,\n      textAlign: propTextAlign,\n      userAssistanceDensity: propUserAssistanceDensity,\n      value,\n      variant,\n      onCommit,\n      onInput\n    }: Props,\n    ref?: Ref<FocusableHandle>\n  ) => {\n    const {\n      isDisabled: isFormDisabled,\n      isReadonly: isFormReadonly,\n      labelEdge: formLabelEdge,\n      labelStartWidth: formLabelStartWidth,\n      textAlign: formTextAlign,\n      userAssistanceDensity: formUserAssistanceDensity\n    } = useFormContext();\n    // default to FormContext values if component properties are not specified\n    const isDisabled = propIsDisabled ?? isFormDisabled;\n    const isReadonly = propIsReadonly ?? isFormReadonly;\n    const labelEdge = propLabelEdge ?? formLabelEdge;\n    const labelStartWidth = propLabelStartWidth ?? formLabelStartWidth;\n    const textAlign = propTextAlign ?? formTextAlign;\n    const userAssistanceDensity = propUserAssistanceDensity ?? formUserAssistanceDensity;\n\n    const { enabledElementRef, readonlyElementRef, focusProps, isFocused } = useFocusableTextField<\n      HTMLDivElement,\n      HTMLDivElement\n    >({ isDisabled, isReadonly, ref });\n\n    const {\n      baseId,\n      formFieldContext,\n      inputProps,\n      labelProps: origLabelProps,\n      textFieldProps,\n      userAssistanceProps\n    } = useTextField({\n      ariaDescribedBy,\n      helpSourceLink,\n      helpSourceText,\n      isDisabled,\n      isFocused,\n      isReadonly,\n      isRequiredShown,\n      labelEdge,\n      messages,\n      styleVariant: variant,\n      userAssistanceDensity,\n      value\n    });\n\n    // When using a div with role=group (i.e. DateField), you need aria-labelledby instead of a\n    // for-id association with a label. Remove forId and id and use aria-labelledby instead.\n    const { forId, ...labelProps } = origLabelProps;\n    const { id, ...dateFieldProps } = inputProps;\n    const ariaLabelledBy = labelProps.id;\n    // Because we don't use for-id, clicking the label does not automatically focus the field.\n    // We have to do it manually.\n    const onClick = useCallback(() => {\n      enabledElementRef.current?.focus();\n    }, [enabledElementRef]);\n\n    const labelComp =\n      labelEdge !== 'none' ? (\n        <Label {...(!isDisabled && !isReadonly ? { onClick } : {})} {...labelProps}>\n          {label}\n        </Label>\n      ) : undefined;\n\n    const fieldLabelProps = {\n      label: labelEdge !== 'none' ? labelComp : undefined,\n      labelEdge: labelEdge !== 'none' ? labelEdge : undefined,\n      labelStartWidth: labelEdge !== 'none' ? labelStartWidth : undefined\n    };\n\n    const ariaLabel = labelEdge === 'none' ? label : undefined;\n    const hasInsideLabel = label !== undefined && labelEdge === 'inside';\n    const isInlineDensity =\n      userAssistanceDensity === 'efficient' || userAssistanceDensity === 'reflow';\n\n    const inlineUserAssistance = isInlineDensity ? (\n      isDisabled || isReadonly ? (\n        // save space for user assistance if density is 'efficient', even though we don't\n        // render user assistance for disabled or readonly fields\n        userAssistanceDensity !== 'efficient' ? undefined : (\n          <InlineUserAssistance\n            userAssistanceDensity={userAssistanceDensity}\n            {...userAssistanceProps}\n          />\n        )\n      ) : (\n        <InlineUserAssistance\n          assistiveText={assistiveText}\n          fieldLabel={label}\n          helpSourceLink={helpSourceLink}\n          helpSourceText={helpSourceText}\n          messages={messages}\n          isRequiredShown={isRequiredShown}\n          userAssistanceDensity={userAssistanceDensity}\n          {...userAssistanceProps}\n        />\n      )\n    ) : undefined;\n\n    const anchorRef = useRef<HTMLDivElement>(null);\n\n    const compactUserAssistance =\n      userAssistanceDensity === 'compact' ? (\n        <CompactUserAssistance\n          anchorRef={anchorRef}\n          messages={messages}\n          assistiveText={assistiveText}\n          {...userAssistanceProps}\n        />\n      ) : undefined;\n\n    const { locale } = useUser();\n\n    const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n    const monthPlaceholder = translations.inputDateMask_monthPlaceholder();\n    const dayPlaceholder = translations.inputDateMask_dayPlaceholder();\n    const yearPlaceholder = translations.inputDateMask_yearPlaceholder();\n\n    // The DatePlaceholders type already ensures the masks contain the right placeholders,\n    // for either full calendar dates or month-year dates. This check ensures the masks,\n    // if provided, match the granularity. E.g. for granularity=month, you should pass\n    // month and year placeholders, and a separator.\n    if (\n      masks &&\n      ((granularity === 'day' && masks.length !== 5) ||\n        (granularity === 'month' && masks.length !== 3))\n    ) {\n      throw new Error('Specified masks must match the granularity');\n    }\n\n    const dateMasks = useMemo(() => {\n      // Determine the locale specific placeholder masks and separators in the correct order\n      // for the locale, unless a custom set of masks was passed in. Each mask represents a\n      // placeholder for a segment of a date (i.e. mm/dd/yyyy). Memoize because we shouldn't\n      // need to recreate this data often.\n      const placeholderMasks = masks\n        ? translateCustomMasks(masks, monthPlaceholder, dayPlaceholder, yearPlaceholder)\n        : getDatePlaceholderMasks(\n            locale,\n            granularity,\n            monthPlaceholder,\n            dayPlaceholder,\n            yearPlaceholder\n          );\n\n      return placeholderMasks;\n    }, [masks, locale, granularity, dayPlaceholder, monthPlaceholder, yearPlaceholder]);\n\n    if (isReadonly) {\n      return (\n        <FormFieldContext.Provider value={formFieldContext}>\n          <ReadonlyTextField\n            role=\"presentation\"\n            columnSpan={columnSpan}\n            compactUserAssistance={compactUserAssistance}\n            inlineUserAssistance={inlineUserAssistance}\n            onBlur={focusProps.onfocusout}\n            onFocus={focusProps.onfocusin}\n            ref={anchorRef}\n            testId={testId}\n            {...fieldLabelProps}>\n            <ReadonlyTextFieldInput\n              aria-describedby={dateFieldProps['aria-describedby']}\n              aria-label={ariaLabel}\n              aria-labelledby={labelProps.id}\n              as=\"div\"\n              elementRef={readonlyElementRef}\n              textAlign={textAlign}\n              value={\n                value === undefined ? '' : formatShortCalendarDate(value, granularity, dateMasks)\n              }\n              hasEmptyLabel={label === '' && labelEdge === 'none'}\n              hasInsideLabel={hasInsideLabel}\n            />\n          </ReadonlyTextField>\n        </FormFieldContext.Provider>\n      );\n    }\n\n    // The main content inside TextField is a DateField (not TextFieldInput) in this case.\n    // We reuse the TextField building blocks and hooks, but recompose them.\n    const mainContent = (\n      <DateField\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        baseId={baseId}\n        fieldRef={enabledElementRef}\n        granularity={granularity}\n        hasInsideLabel={labelComp !== undefined && labelEdge === 'inside'}\n        isRequired={isRequired}\n        masks={dateMasks}\n        onCommit={onCommit}\n        onInput={onInput}\n        textAlign={textAlign}\n        value={value}\n        {...dateFieldProps}\n      />\n    );\n\n    return (\n      <FormFieldContext.Provider value={formFieldContext}>\n        <TextField\n          columnSpan={columnSpan}\n          compactUserAssistance={compactUserAssistance}\n          inlineUserAssistance={inlineUserAssistance}\n          mainContent={mainContent}\n          onBlur={focusProps.onfocusout}\n          onFocus={focusProps.onfocusin}\n          mainFieldRef={anchorRef}\n          testId={testId}\n          {...textFieldProps}\n          {...fieldLabelProps}\n        />\n      </FormFieldContext.Provider>\n    );\n  }\n);\n"],"names":["DateSegment","ariaLabel","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","isComplete","isDisabled","isHidden","isHighlighted","isInvalid","isRequired","isSelected","onChange","placeholder","text","type","hasDisplayValue","length","rootClasses","classNames","segmentStyles","base","selected","highlighted","placeholderClasses","hidden","notHidden","emptySegmentValueText","useTranslationBundle","inputDateMask_empty_segment","hasLeadingZero","useRef","segmentRef","locale","useUser","onKeyDown","useCallback","event","key","undefined","isNumberOnlyString","actionType","data","current","isBackspaceOrDelete","direction","preventDefault","stopPropagation","useEffect","focus","customDataAttribute","valueText","toString","_jsxs","ref","role","autocapitalize","autocorrect","class","contentEditable","enterkeyhint","inputMode","spellcheck","tabIndex","children","_jsx","jsx","LiteralSegment","isPlaceholder","spanClasses","literalBase","dateReducer","state","action","segmentType","segmentState","findSegment","segments","updatedSegments","selectFirst","clearDate","orderedSegments","createDateFieldStateWithSelectedDate","updatedSegment","clearSegment","createDateFieldState","clearSelectionAndComplete","goToEnd","goToHome","doStepOrPage","selectDateOrSegment","selectNext","selectPrevious","selectSegment","updateSegment","Error","stringToNumber","s","numberToString","n","find","segment","isDateComplete","allSegments","every","seg","isPartialDate","some","createCalendarDateFromSegments","iterator","map","values","cd","segValue","getYearValue","getMonthAria","month","year","getMonthName","getOrderedSegments","currentState","replaceDateSegment","existingSegments","updatedSegmentType","createDateSegmentStates","autoAdvance","modifiedSegments","daySeg","monthValue","yearValue","dayMax","getDaysInMonth","currentDay","dayValue","dayValueStr","updatedDaySeg","createDateFieldStateFromSegments","currentDate","isCompleteDate","isDateSelected","cleared","valueMax","MAX_ISO_YEAR","getMonthsInYear","actionText","minValue","maxValue","requestedValStr","requestedVal","inRange","max","newValStr","newVal","val","isSegmentComplete","getSelectedSegmentIndex","sel","findIndex","markSelectedSegmentComplete","selectedIndex","createSegmentFromKeyboardAction","newValue","getHomeSegmentValue","getEndSegmentValue","valueNow","min","yearDefault","monthDefault","day","dayDefault","getTodayAsCalendarDate","getDefaultSegmentValue","currentValue","step","getPagedSegmentValue","getSteppedSegmentValue","DateField","describedBy","ariaInvalid","ariaLabelledBy","baseId","fieldRef","granularity","hasInsideLabel","masks","dateMasks","onBlur","onCommit","onFocus","onInput","textAlign","value","variant","translations","announceDateCleared","inputDateMask_date_cleared","labels","formControl_month","formControl_day","formControl_year","isFocused","isInputFocused","useFormFieldContext","hasValue","classes","useComponentTheme","TextFieldInputRedwoodTheme","styleVariant","textarea","input","div","prefix","suffix","startContent","endContent","insideLabel","focused","disabled","compClasses","dispatch","dateResetRef","ariaLabels","filter","monthMax","yearValueStr","monthValueStr","monthAria","MIN_ISO_DAY","initialState","MIN_ISO_YEAR","MIN_ISO_MONTH","useReducer","lastValueFromParentRef","calendarDatesAreDifferent","useDateField","editableSegments","segmentsMap","dateClearedRef","dateFieldHandlers","segmentHandlers","tabbableModeProps","useTabbableMode","tabbableModeIndex","anySegmentSelected","updatedTabIndex","lastDateRef","lastCommittedDateRef","lastFocusedRef","onClick","e","target","getAttribute","frozenDate","Object","freeze","recentPointerRef","pointerDownTimerRef","onDoubleClick","onPointerDown","clearTimeout","setTimeout","useDateFieldHandlers","formattedDateStr","formatFullCalendarDate","formattedDateAriaId","formattedDateAria","HiddenAccessible","id","ariaDescribedBy","merge","announceText","jsxs","onfocusin","onfocusout","Flex","wrap","justify","segmentProps","LiveRegion","InputDateMask","forwardRef","assistiveText","columnSpan","helpSourceLink","helpSourceText","propIsDisabled","isReadonly","propIsReadonly","isRequiredShown","label","labelEdge","propLabelEdge","labelStartWidth","propLabelStartWidth","messages","testId","propTextAlign","userAssistanceDensity","propUserAssistanceDensity","isFormDisabled","isFormReadonly","formLabelEdge","formLabelStartWidth","formTextAlign","formUserAssistanceDensity","useFormContext","enabledElementRef","readonlyElementRef","focusProps","useFocusableTextField","formFieldContext","inputProps","labelProps","origLabelProps","textFieldProps","userAssistanceProps","useTextField","forId","dateFieldProps","labelComp","Label","fieldLabelProps","inlineUserAssistance","InlineUserAssistance","fieldLabel","anchorRef","compactUserAssistance","CompactUserAssistance","monthPlaceholder","inputDateMask_monthPlaceholder","dayPlaceholder","inputDateMask_dayPlaceholder","yearPlaceholder","inputDateMask_yearPlaceholder","useMemo","translateCustomMasks","getDatePlaceholderMasks","FormFieldContext","Provider","ReadonlyTextField","ReadonlyTextFieldInput","as","elementRef","formatShortCalendarDate","hasEmptyLabel","mainContent","TextField","mainFieldRef"],"mappings":"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"}