{"version":3,"file":"calendarDateUtils-8c0b5ccf.js","sources":["../../src/utils/UNSAFE_calendarDateUtils/calendarDateUtils.ts"],"sourcesContent":["import {\n  CalendarDate,\n  DateGranularity,\n  DatePlaceholders,\n  IsoDay,\n  IsoMonth\n} from '#UNSAFE_InputDateMask/types';\n\nimport {\n  BCP47Locale,\n  DateISOStr,\n  DateTimeUtils,\n  NativeDateTimeOptions,\n  getFormatParse\n} from '#UNSAFE_IntlDateTime';\n\nconst MAX_ISO_YEAR = 9999;\nconst MIN_ISO_YEAR = 0;\nconst MIN_ISO_DAY = 1;\nconst MIN_ISO_MONTH = 1;\n\nconst checkNoCalendarExtension = (locale: BCP47Locale) => {\n  if (locale.indexOf('-u-ca-') !== -1) {\n    throw new Error('Calendar not allowed in locale');\n  }\n};\n\nconst toJSDate = (year: number, month: IsoMonth, day: IsoDay) => {\n  // Date uses 0-based index for month.\n  return new Date(year, month - 1, day);\n};\n\n/**\n * This function formats a test date using Intl.DateTimeFormat for the given locale.\n * It then uses Intl.DateTimeFormat.formatToParts to get the parts of the date in a\n * locale specific order, substitutes translated placeholders, and filters out\n * unwanted parts of the date. If granularity = month, then the placeholder for day\n * is removed. The shape of the return value matches what is returned by formatToParts.\n *\n * @param locale The BCP47Locale\n * @param granularity Specifies whether you want placeholders for month, year OR day, month, year\n * @param monthPlaceholder The translated month placeholder\n * @param dayPlaceholder The translated day placeholder\n * @param yearPlaceholder The translated year placeholder\n */\nconst getDatePlaceholderMasks = (\n  locale: BCP47Locale,\n  granularity: 'month' | 'day',\n  monthPlaceholder: string,\n  dayPlaceholder: string,\n  yearPlaceholder: string\n): DatePlaceholders => {\n  checkNoCalendarExtension(locale);\n  const testDate = new Date('2022-11-30');\n  const formatter = new Intl.DateTimeFormat(locale, { dateStyle: 'short' });\n\n  // Filter out anything that is not month, day, year, or literal (e.g. a separator).\n  const filterByType = (p: Intl.DateTimeFormatPart) => {\n    return (\n      (granularity === 'day' && p.type === 'day') ||\n      p.type === 'month' ||\n      p.type === 'year' ||\n      p.type === 'literal'\n    );\n  };\n\n  // Substitute translated placeholders. Trim literals for visual consistency (they can include whitespace)\n  // so the date looks more like a string when the placeholders are rendered next to each other.\n  const mapTranslatedPlaceholders = (p: Intl.DateTimeFormatPart) => {\n    switch (p.type) {\n      case 'month':\n        return { ...p, value: monthPlaceholder };\n      case 'day':\n        return { ...p, value: dayPlaceholder };\n      case 'year':\n        return { ...p, value: yearPlaceholder };\n      default:\n        return { ...p, value: p.value.trim() };\n    }\n  };\n\n  const parts = formatter.formatToParts(testDate).filter(filterByType);\n  let placeholders = parts.map(mapTranslatedPlaceholders);\n\n  // Remove any repeated literals, which can occur after filtering (such as mm//yyyy).\n  const index = placeholders.findIndex((element, index, array) => {\n    return element.type === 'literal' && index > 0 && array[index - 1].type === 'literal';\n  });\n  if (index !== -1) {\n    placeholders = placeholders.slice(0, index).concat(placeholders.slice(index + 1));\n  }\n\n  // Remove any leading or trailing literals. Leading literals can occur after filtering,\n  // and certain locales include trailing literals such as mm.dd.yyyy. which we don't want.\n  if (placeholders[placeholders.length - 1].type === 'literal') {\n    placeholders = placeholders.slice(0, -1);\n  }\n  if (placeholders[0].type === 'literal') {\n    placeholders = placeholders.slice(1);\n  }\n\n  return placeholders as DatePlaceholders;\n};\n\n/**\n * Return the number of days in a given month and year. Pass '*' if you don't know a value.\n * If neither month or year are known, then return the maximum number of days in any month in any year.\n * If only month is known, return the maximum number of days for that month in any year.\n * For Gregorian calendar:\n *   getDaysInMonth(2, *) => returns 29\n *   getDaysInMonth(*, *) => returns 31\n *   getDaysInMonth(*, 2023) => returns 31\n */\nconst getDaysInMonth = (month: IsoMonth | '*', year: number | '*') => {\n  if (month === '*') {\n    return 31;\n  } else if (year === '*') {\n    return getDaysInMonthGregorian(month);\n  } else {\n    checkIsValidIsoYear(year);\n    // DateTimeUtils.getDaysInMonth uses a 0-based index.\n    return DateTimeUtils.getDaysInMonth(year, month - 1);\n  }\n};\n\n/**\n * Return the number of months in a given year. Pass '*' if you don't know the year.\n * In a Gregorian calendar the number of months is always 12. We'll have to revisit this\n * when multiple calendars are supported; in some cases the number of months can vary by year.\n */\nconst getMonthsInYear = (year: number | '*') => {\n  if (year !== '*') {\n    checkIsValidIsoYear(year);\n  }\n  return 12;\n};\n\n/**\n * Return the number of days in a month in the Gregorian calendar, without knowing the year.\n */\nconst getDaysInMonthGregorian = (month: IsoMonth) => {\n  switch (month) {\n    case 1:\n    case 3:\n    case 5:\n    case 7:\n    case 8:\n    case 10:\n    case 12:\n      return 31;\n    case 2:\n      return 29; // Since we don't know the year, return the maximum possible number of days.\n    default:\n      return 30;\n  }\n};\n\n/**\n * Throw an error if year is not a valid ISO year (0-9999).\n * The allowed range is too large to express using Typescript.\n */\nconst checkIsValidIsoYear = (year: number) => {\n  if (year < MIN_ISO_YEAR || year > MAX_ISO_YEAR) {\n    throw new Error('Invalid year value');\n  }\n};\n\n/**\n * This utility method uses Intl.DateTimeFormat directly to format with month: long and\n * year: numeric. It returns something like 'May 2025'.\n */\nconst getLongFormattedYearMonth = (locale: BCP47Locale, year: number, month: IsoMonth) => {\n  const formatter = new Intl.DateTimeFormat(locale, { month: 'long', year: 'numeric' });\n  return formatter.format(toJSDate(year, month, 1));\n};\n\n/**\n * Construct and return an IS0 date string from year, month, and day.\n */\nconst getIsoDateStr = (year: number, month: IsoMonth, day: IsoDay) => {\n  checkIsValidIsoYear(year);\n\n  // Month and day must be 2 digits and year must be 4 digits to be a valid ISO 8601 string.\n  const parts = [\n    year.toString().padStart(4, '0'),\n    month.toString().padStart(2, '0'),\n    day.toString().padStart(2, '0')\n  ];\n  return parts.join('-');\n};\n\n/**\n * Parse a DateIsoStr and return an equivalent CalendarDate.\n */\nconst getCalendarDateFromIso = (str: DateISOStr) => {\n  if (!DateTimeUtils.isDateOnlyIsoString(str)) {\n    return undefined;\n  }\n\n  const parts = str.split('-');\n  return { year: +parts[0], month: +parts[1], day: +parts[2] } as unknown as CalendarDate;\n};\n\n/**\n * Return the calendar date for year, month, and day formatted using the specified date style\n * in the given locale.\n */\nconst getFormattedYearMonthDay = (\n  locale: BCP47Locale,\n  year: number,\n  month: IsoMonth,\n  day: IsoDay,\n  style: NonNullable<Intl.DateTimeFormatOptions['dateStyle']>\n) => {\n  checkNoCalendarExtension(locale);\n  const dateIsoStr = getIsoDateStr(year, month, day);\n\n  const dateFormatOptions: NativeDateTimeOptions = {\n    locale,\n    dateStyle: style,\n    dateStyleShortYear: style === 'short' ? 'numeric' : undefined\n  };\n  const { format } = getFormatParse(dateFormatOptions);\n  return format(dateIsoStr);\n};\n\n/**\n * Format and return the calendar date as a string. If the date is not a complete\n * date, i.e. any of its segments are missing, return an empty string.\n */\nconst formatCalendarDateAsString = (\n  locale: BCP47Locale,\n  calendarDate: CalendarDate,\n  style: NonNullable<Intl.DateTimeFormatOptions['dateStyle']>\n) => {\n  if (!calendarDate.year || !calendarDate.month || !calendarDate.day) {\n    return '';\n  }\n  return getFormattedYearMonthDay(\n    locale,\n    calendarDate.year,\n    calendarDate.month,\n    calendarDate.day,\n    style\n  );\n};\n\n/**\n * Format an example DateISOStr in short format.\n */\nconst formatIsoDateStrAsExample = (\n  locale: BCP47Locale,\n  str: DateISOStr,\n  masks?: DatePlaceholders\n) => {\n  const calDate = getCalendarDateFromIso(str);\n  // The placeholders aren't used for formatting, so use dummy values.\n  const dateMasks = masks ?? getDatePlaceholderMasks(locale, 'day', 'mm', 'dd', 'yyyy');\n  return calDate === undefined ? '' : formatShortCalendarDate(calDate, 'day', dateMasks);\n};\n\n/**\n * Format a CalendarDate in short format.\n */\nconst formatShortCalendarDate = (\n  cd: CalendarDate,\n  granularity: DateGranularity,\n  masks: DatePlaceholders\n) => {\n  if (!cd.year || !cd.month || (granularity === 'day' && !cd.day)) {\n    return '';\n  }\n  const dateValues = masks.map(({ type, value }) =>\n    type === 'year' ? cd.year : type === 'month' ? cd.month : type === 'day' ? cd.day : value.trim()\n  );\n  return dateValues.join('');\n};\n\n/**\n * Format a CalendarDate in full format.\n */\nconst formatFullCalendarDate = (\n  locale: BCP47Locale,\n  cd: CalendarDate,\n  granularity: DateGranularity\n) => {\n  if (!cd.year || !cd.month || (granularity === 'day' && !cd.day)) {\n    return '';\n  }\n  checkNoCalendarExtension(locale);\n\n  return granularity === 'day'\n    ? getFormattedYearMonthDay(locale, cd.year, cd.month, cd.day!, 'full')\n    : getLongFormattedYearMonth(locale, cd.year, cd.month);\n};\n\n// returns true if undefined or if the value has a year, month and day property that are valid based on granularity.\n// The day property can be undefined if granularity is month.\nconst isValidCalendarDate = (value: any, granularity: DateGranularity = 'day') => {\n  if (value === undefined) return true;\n  if (value === null) return false;\n  // if not undefined, then it must be all empty or a complete date based on granularity\n  const { year, month, day } = value;\n\n  const isValidNumber = (num: number | undefined, max: number | undefined): boolean => {\n    return (\n      typeof num === 'number' &&\n      Number.isInteger(num) &&\n      num > 0 &&\n      (max === undefined || num <= max)\n    );\n  };\n\n  // Empty object is not ok.\n  if (year === undefined && month === undefined && (granularity === 'month' || day === undefined)) {\n    return false;\n  }\n\n  // Check if the value is a complete object and its month and day dates are valid\n  if (month !== undefined && year !== undefined) {\n    if (\n      granularity === 'day' &&\n      isValidNumber(year, MAX_ISO_YEAR) &&\n      isValidNumber(month, getMonthsInYear(year)) &&\n      isValidNumber(day, getDaysInMonth(month, year))\n    ) {\n      return true;\n    } else if (\n      granularity === 'month' &&\n      isValidNumber(year, MAX_ISO_YEAR) &&\n      isValidNumber(month, getMonthsInYear(year))\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst isCompleteCalendarDate = (value: CalendarDate) => {\n  const { year, month, day } = value;\n\n  // Check if the value is a complete object and its month and day dates are valid\n  return year !== undefined && month !== undefined && day !== undefined;\n};\n\n// Given a pattern, return a DatePlaceholder array.\nconst getDatePlaceholdersFromPattern = (pattern: string) => {\n  const arr = getMaskArrayFromPattern(pattern);\n  const datePlaceholders = convertMaskArrayToDatePlaceholders(arr);\n  return datePlaceholders;\n};\n\n// Given a pattern, like 'd-m-yyyy', return an array like ['d', '-', 'm', '-', 'yyyy']\nconst getMaskArrayFromPattern = (pattern: string) => {\n  const result: Array<string> = [];\n  let currentSegmentStr = '';\n  let currentLiteral = '';\n\n  const addSegment = () => {\n    if (currentSegmentStr !== '') {\n      result.push(currentSegmentStr);\n      currentSegmentStr = '';\n    }\n  };\n\n  const addLiteral = () => {\n    if (currentLiteral !== '') {\n      // InputDateMask does not want spaces in its literals. Even if InputDateMask\n      // trims its literals for the masks property, we do so here as well\n      // since we could end up using this for things that are\n      // outside of InputDateMasks masks property.\n      result.push(currentLiteral.trim());\n      currentLiteral = '';\n    }\n  };\n\n  for (let i = 0; i < pattern.length; i++) {\n    const char = pattern[i];\n\n    if (char.toLowerCase() === 'm' || char.toLowerCase() === 'd' || char.toLowerCase() === 'y') {\n      addLiteral();\n      currentSegmentStr += char;\n    } else {\n      addSegment();\n      currentLiteral += char;\n    }\n  }\n\n  // Add the last components\n  addSegment();\n  addLiteral();\n\n  return result;\n};\n\n// converts an array into the object that is needed to set on the InputDateMask's masks property, DatePlaceholder[];\nconst convertMaskArrayToDatePlaceholders = (array: Array<string>) => {\n  return array.map((item) => {\n    if (item.toLowerCase()[0] === 'd') {\n      return { type: 'day', value: item };\n    } else if (item.toLowerCase()[0] === 'm') {\n      return { type: 'month', value: item };\n    } else if (item.toLowerCase()[0] === 'y') {\n      return { type: 'year', value: item };\n    } else {\n      // Default to literal for anything else\n      return { type: 'literal', value: item };\n    }\n  }) as DatePlaceholders;\n};\n\nexport {\n  MIN_ISO_DAY,\n  MIN_ISO_MONTH,\n  MIN_ISO_YEAR,\n  MAX_ISO_YEAR,\n  checkIsValidIsoYear,\n  checkNoCalendarExtension,\n  formatCalendarDateAsString,\n  formatShortCalendarDate,\n  formatFullCalendarDate,\n  formatIsoDateStrAsExample,\n  getCalendarDateFromIso,\n  getDatePlaceholderMasks,\n  getFormattedYearMonthDay,\n  getDaysInMonth,\n  getDatePlaceholdersFromPattern,\n  getIsoDateStr,\n  getMonthsInYear,\n  isCompleteCalendarDate,\n  isValidCalendarDate\n};\n"],"names":["MAX_ISO_YEAR","checkNoCalendarExtension","locale","indexOf","Error","getDatePlaceholderMasks","granularity","monthPlaceholder","dayPlaceholder","yearPlaceholder","testDate","Date","placeholders","Intl","DateTimeFormat","dateStyle","formatToParts","filter","p","type","map","value","trim","index","findIndex","element","array","slice","concat","length","getDaysInMonth","month","year","getDaysInMonthGregorian","checkIsValidIsoYear","DateTimeUtils.getDaysInMonth","getMonthsInYear","getLongFormattedYearMonth","format","day","toJSDate","getIsoDateStr","toString","padStart","join","getCalendarDateFromIso","str","DateTimeUtils.isDateOnlyIsoString","parts","split","getFormattedYearMonthDay","style","dateIsoStr","dateFormatOptions","dateStyleShortYear","undefined","getFormatParse","formatShortCalendarDate","cd","masks","getMaskArrayFromPattern","pattern","result","currentSegmentStr","currentLiteral","addSegment","push","addLiteral","i","char","toLowerCase","convertMaskArrayToDatePlaceholders","item","calendarDate","calDate","dateMasks","arr","isValidNumber","num","max","Number","isInteger"],"mappings":"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"}