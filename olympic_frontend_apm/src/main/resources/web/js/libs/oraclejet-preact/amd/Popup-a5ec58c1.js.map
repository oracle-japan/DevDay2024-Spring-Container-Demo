{"version":3,"file":"Popup-a5ec58c1.js","sources":["../../src/UNSAFE_Popup/usePopupAnimation.ts","../../src/UNSAFE_Popup/Popup.tsx"],"sourcesContent":["import { Placement, RtlSide } from '../UNSAFE_Floating';\nimport {\n  useAnimationStatus,\n  AnimationStatus,\n  AnimationStatusProps\n} from '../hooks/PRIVATE_useAnimationStatus';\nimport { normalizePosition } from '../utils/PRIVATE_floatingUtils';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useEffect } from 'preact/hooks';\n\n/**\n * The placement and direction aware HTML element\n * The useAnimation hook do not allow to change dynamically the animation states,\n * but allows a function that returns animation states config. The function takes\n * the animated node of type <E extends HTMLElement> as an argument. This could be used\n * to extend HTMLElement with placement and direction.\n */\ntype AnimationPopupElement = HTMLElement & {\n  placement?: Placement;\n  direction?: 'ltr' | 'rtl';\n};\n\ntype PopupAnimationProps = Omit<AnimationStatusProps, 'animationStates'> & {\n  placement: Placement;\n};\n\nconst animationStates = {\n  opening: (node: AnimationPopupElement) => {\n    const realPlacement = logicalSide(node.placement, node.direction);\n    return {\n      //zoomIn\n      from: {\n        scaleX: 0,\n        scaleY: 0,\n        opacity: 0,\n        transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]\n      },\n      to: {\n        scaleX: 1,\n        scaleY: 1,\n        opacity: 1,\n        transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]\n      },\n      options: {\n        duration: 200\n      }\n    };\n  },\n  closing: (node: AnimationPopupElement) => {\n    const realPlacement = logicalSide(node.placement, node.direction);\n    return {\n      //zoomOut\n      from: {\n        scaleX: 1,\n        scaleY: 1,\n        opacity: 1,\n        transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]\n      },\n      to: {\n        scaleX: 0,\n        scaleY: 0,\n        opacity: 0,\n        transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]\n      },\n      options: {\n        duration: 200\n      }\n    };\n  }\n};\n\nconst _ANIMATION_TRANSFORM_ORIGIN_RULES = {\n  top: 'center bottom',\n  'top-right': 'right bottom',\n  'top-left': 'left bottom',\n  'top-right-corner': 'left bottom',\n  'top-left-corner': 'right bottom',\n  right: 'left center',\n  'right-top': 'left top',\n  'right-bottom': 'left bottom',\n  'right-top-corner': 'left bottom',\n  'right-bottom-corner': 'left top',\n  bottom: 'center top',\n  'bottom-right': 'right top',\n  'bottom-left': 'left top',\n  'bottom-right-corner': 'left top',\n  'bottom-left-corner': 'right top',\n  left: 'right center',\n  'left-top': 'right top',\n  'left-bottom': 'right bottom',\n  'left-top-corner': 'right bottom',\n  'left-bottom-corner': 'right top'\n};\n\ntype RealPlacement =\n  | 'top'\n  | 'top-right'\n  | 'top-left'\n  | 'top-right-corner'\n  | 'top-left-corner'\n  | 'right'\n  | 'right-top'\n  | 'right-bottom'\n  | 'right-top-corner'\n  | 'right-bottom-corner'\n  | 'bottom'\n  | 'bottom-right'\n  | 'bottom-left'\n  | 'bottom-right-corner'\n  | 'bottom-left-corner'\n  | 'left'\n  | 'left-top'\n  | 'left-bottom'\n  | 'left-top-corner'\n  | 'left-bottom-corner';\n\nconst logicalSide = (\n  placement: Placement | undefined,\n  direction: 'rtl' | 'ltr' | undefined\n): RealPlacement => {\n  if (placement == null || direction == null) return 'bottom';\n  const side = placement.split('-')[0] as RtlSide;\n  const alignment = placement.split('-')[1] as RtlSide;\n  const corner = placement.split('-')[2];\n  const physicalSide = normalizePosition(side, direction);\n  const placements: Array<RealPlacement> = [\n    'top',\n    'top-right',\n    'top-left',\n    'top-right-corner',\n    'top-left-corner',\n    'right',\n    'right-top',\n    'right-bottom',\n    'right-top-corner',\n    'right-bottom-corner',\n    'bottom',\n    'bottom-right',\n    'bottom-left',\n    'bottom-right-corner',\n    'bottom-left-corner',\n    'left',\n    'left-top',\n    'left-bottom',\n    'left-top-corner',\n    'left-bottom-corner'\n  ];\n  const newPlacement: RealPlacement = placements.filter(\n    (placement) =>\n      (alignment &&\n        corner &&\n        placement === `${physicalSide}-${normalizePosition(alignment, direction)}-${corner}`) ||\n      (alignment &&\n        !corner &&\n        placement === `${physicalSide}-${normalizePosition(alignment, direction)}`) ||\n      (!alignment && placement === `${physicalSide}`)\n  )[0];\n  if (!newPlacement) {\n    return 'bottom';\n  }\n\n  return newPlacement;\n};\n\nexport function usePopupAnimation(props: PopupAnimationProps): {\n  status: AnimationStatus;\n  setAnimationElementRef: (node: HTMLElement | null) => void;\n} {\n  const { isOpen, isAnimatedOnMount, onTransitionEnd, placement } = props;\n  const { direction } = useUser();\n  const { setAnimationElementRef, animationElementRef, status } =\n    useAnimationStatus<AnimationPopupElement>({\n      isOpen: isOpen,\n      isAnimatedOnMount: isAnimatedOnMount,\n      animationStates,\n      onTransitionEnd\n    });\n  const popupElementRef = animationElementRef;\n\n  //This is needed for the case if popup flips and changes the placement.\n  useEffect(() => {\n    if (popupElementRef != null && popupElementRef.current != null && status != 'unmounted') {\n      popupElementRef.current.placement = placement;\n      popupElementRef.current.direction = direction;\n    }\n  }, [popupElementRef, placement, direction, status]);\n  return { setAnimationElementRef, status };\n}\n","import { JSX, RefObject } from 'preact';\nimport { useState, useEffect, useLayoutEffect, useMemo, useRef, useCallback } from 'preact/hooks';\nimport {\n  Floating,\n  Offset,\n  Placement,\n  Coords,\n  FlipOptions,\n  ShiftOptions,\n  PositionData\n} from '../UNSAFE_Floating';\nimport { focusOn, focusWithin, getActiveElement } from '../utils/PRIVATE_tabbableUtils';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport { Layer } from '../UNSAFE_Layer';\nimport { Modal } from '../UNSAFE_Modal';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { usePopupAnimation } from './usePopupAnimation';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { popupVars } from './themes/PopupContract.css';\nimport { getVarName } from '../utils/UNSAFE_stringUtils';\nimport { Property } from 'csstype';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { PopupRedwoodTheme } from './themes/redwood/PopupTheme';\n\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\n\ntype Props = IntrinsicProps & {\n  /**\n   * Specifies whether the Popup is open.\n   */\n  isOpen: boolean;\n  /**\n   * Specifies Popup's anchor. Popup is placed relatively to its anchor.\n   */\n  anchorRef: RefObject<HTMLElement | Coords>;\n  /**\n   * Specifies placement of the Popup relative to the anchor.\n   */\n  placement?: Placement;\n  /**\n   * Specifies displacement of the Popup from the anchor element placement along the specified axes.\n   * The offset object consists of mainAxis and crossAxis properties. The direction in which these properties\n   * are applied depends on the current value of the position property.\n   *\n   * The <code>mainAxis</code> property represents the distance between the Popup and the anchor.\n   * The <code>crossAxis</code> property represents the deviation in the opposite axis to the main axis - the skidding between the Popup and the anchor.\n   */\n  offset?: Offset;\n  /**\n   * Specifies modality of the Popup.\n   */\n  modality?: 'modal' | 'modeless';\n  /**\n   * Specifies whether a floating Popup changes placement to the opposite side to be kept in view when a collision is detected.\n   *\n   * The flipOptions object consists of mainAxis and crossAxis properties.\n   * The <code>mainAxis</code> runs along the side of the Popup element.\n   * The <code>crossAxis</code> runs along the alignment of the Popup element.\n   */\n  flipOptions?: FlipOptions;\n  /**\n   * Specifies whether a floating Popup shifts along axis to be kept in view when a collision is detected.\n   * Note that if both 'flip' and 'shift' are enabled on respective axis, the flip will take precedence.\n   *\n   * The shiftOptions object consists of mainAxis and crossAxis properties.\n   * The <code>mainAxis</code> runs along the side of the Popup element.\n   * The <code>crossAxis</code> runs along the alignment of the Popup element.\n   */\n  shiftOptions?: ShiftOptions;\n  /**\n   * Specifies if the Popup sets focus to its content when initially open.\n   * A value of none prevents the popup from setting focus when open.\n   *\n   * <code>auto</code> in modeless mode resolves to none.\n   * <code>none</code> prevents the popup from setting focus when open.\n   * <code>popup</code> sets focus to the root popup container (good choice for touch platforms).\n   * <code>firstFocusable</code> defines that a popup should set focus to the first focusable element within the popup's content.\n   */\n  initialFocus?: 'auto' | 'none' | 'popup' | 'firstFocusable';\n  /**\n   * Specifies callback triggered when a user clicks outside Popup.\n   */\n  onClickOutside?: (event: MouseEvent) => void;\n  /**\n   * Specifies callback triggered when a user tries to close a Popup through UI interaction.\n   * The parent should listen to this event and close the Popup. If the parent fails to remove\n   * the Popup, then no change will be done in the UI by the component.\n   */\n  onClose?: (event: KeyboardEvent) => void;\n  /**\n   * Specifies Popup's tail. Simple tail is an arrow pointing to Popup's anchor.\n   */\n  tail?: 'none' | 'simple';\n  /**\n   * Specifies callback triggered after the animation ends.\n   */\n  onTransitionEnd?: (value: boolean) => void;\n  /**\n   * Specifies the ARIA role type. Depending on how the popup is used in the page, the page developer should choose from the following:\n   * <code>tooltip</code> defines contextual popup that displays a description for an element. This is added automatically if not already specified.\n   * <code>dialog</code> defines an application window that is designed to interrupt the current processing of an application in order to prompt the user to enter information or require a response.\n   * <code>alertdialog</code> defines type of dialog that contains an alert message, where initial focus goes to an element within the dialog.\n   */\n  role?: HTMLAttributesSignalExcluded['role'];\n} & TestIdProps;\n\n/**\n * A popup temporarily 'pops up' content in the foreground.\n */\nexport const Popup = forwardRef(\n  (\n    {\n      anchorRef,\n      children,\n      isOpen = false,\n      modality = 'modeless',\n      offset = { mainAxis: 0, crossAxis: 0 },\n      flipOptions = { mainAxis: true, crossAxis: true },\n      shiftOptions = { mainAxis: false, crossAxis: false },\n      onClose,\n      initialFocus = 'auto',\n      onClickOutside,\n      placement = 'top',\n      tail = 'none',\n      onTransitionEnd,\n      role = 'tooltip',\n      testId\n    }: Props,\n    ref: ForwardedRef<HTMLElement | null>\n  ) => {\n    const [trapDisabled, setTrapDisabled] = useState<boolean>(true);\n    const launcherRef = useRef<HTMLElement | null>(null);\n    const [popupBgColor, setPopupBgColor] = useState<Property.BackgroundColor>();\n\n    const contentWrapperRef = useRef<HTMLDivElement | null>(null);\n\n    // testId support\n    const testIdProps = useTestId(testId);\n\n    //The animationPlacement is used for the case of flip.\n    const [animationPlacement, setAnimationPlacement] = useState<Placement>(placement);\n\n    function launcherKeyDownCallback(event: KeyboardEvent): void {\n      if (launcherRef.current === getActiveElement() && event.code === 'F6') {\n        // Prevent default F6 handlers.\n        // F6 is a standard Chrome address bar shortcut on Windows.\n        event.preventDefault();\n        event.stopPropagation();\n\n        focusWithin(contentWrapperRef.current as HTMLElement);\n      }\n    }\n\n    const _onTransitionEnd = (isOpen: boolean) => {\n      if (isOpen) {\n        setInitialFocus();\n        onTransitionEnd?.(true);\n      } else {\n        onTransitionEnd?.(false);\n      }\n    };\n\n    // Animation\n    const { setAnimationElementRef, status } = usePopupAnimation({\n      isOpen,\n      isAnimatedOnMount: true,\n      onTransitionEnd: _onTransitionEnd,\n      placement: animationPlacement\n    });\n    const stableRef = useMemo(\n      () => mergeRefs(setAnimationElementRef, ref),\n      [setAnimationElementRef, ref]\n    );\n\n    const returnFocus = useCallback(() => {\n      // Try to return focus to 1.launcher or 2.anchor\n      const launcherEl = launcherRef.current;\n      const anchorEl = anchorRef.current;\n\n      if (launcherEl) {\n        focusOn(launcherEl);\n        // Checking instanceof to avoid Coords type that can not be focused\n      } else if (anchorEl && anchorEl instanceof Element) {\n        focusOn(anchorEl);\n      }\n    }, [anchorRef]);\n\n    useEffect(() => {\n      // Init closing\n      if (!isOpen && status === 'opening') {\n        // Only actively return focus to the launcher or anchor if the popup contained focus.\n        // Otherwise, focus is already elsewhere on the page and should not be forced back\n        // because that could reopen the popup again, which essentially prevents the user from\n        // moving focus out of the launcher.\n        if (contentWrapperRef.current?.contains(getActiveElement())) {\n          returnFocus();\n        }\n      }\n    }, [isOpen, status, returnFocus]);\n\n    // Launcher handler\n    useEffect(() => {\n      if (isOpen && anchorRef.current instanceof Element) {\n        // Remember launcher\n        if (getActiveElement() === document.body) {\n          launcherRef.current = anchorRef.current as HTMLElement;\n        } else {\n          launcherRef.current = getActiveElement() as HTMLElement;\n        }\n\n        // Register F6 key handler to enter the Popup\n        launcherRef.current?.addEventListener('keydown', launcherKeyDownCallback);\n      }\n      return () => {\n        // Deregister F6 key handler\n        launcherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);\n      };\n    }, [isOpen, anchorRef]);\n\n    const setInitialFocus = () => {\n      let derivedInitialFocus = initialFocus;\n      if (initialFocus === 'auto') {\n        // Modeless mode - do not steal focus by default\n        derivedInitialFocus = 'none';\n      }\n\n      // Case: 'popup'\n      // Focus on Popup container\n      if (derivedInitialFocus === 'popup') {\n        focusOn(contentWrapperRef.current as HTMLElement);\n      }\n\n      // Case: 'firstFocusable'\n      // Focus on first tabbable in the Popup container or container itself if there is none\n      if (derivedInitialFocus === 'firstFocusable') {\n        focusWithin(contentWrapperRef.current as HTMLElement);\n      }\n    };\n\n    const getMainAxisOffset = (offset?: Offset) => {\n      let calcOffset = 0;\n      if (offset) {\n        // @ts-ignore as OffsetFunction is going to be removed\n        // Property 'mainAxis' does not exist on type 'OffsetFunction'.\n        calcOffset = typeof offset === 'number' ? offset : offset.mainAxis || 0;\n        if (tail === 'simple') {\n          calcOffset += 5;\n        }\n      }\n      return calcOffset;\n    };\n\n    const getCrossAxisOffset = (offset?: Offset) => {\n      if (!offset) {\n        return 0;\n      } else {\n        // @ts-ignore as OffsetFunction is going to be removed\n        // Property 'crossAxis' does not exist on type 'OffsetFunction'.\n        return typeof offset === 'number' ? 0 : offset.crossAxis || 0;\n      }\n    };\n\n    const finalOffset = {\n      mainAxis: getMainAxisOffset(offset),\n      crossAxis: getCrossAxisOffset(offset)\n    };\n\n    // Preact FocusEvent mapping\n    // onFocus - focusin\n    // onBlur - focusout\n    //\n    // https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/relatedTarget\n    // Event name   target                           relatedTarget\n    // blur         The EventTarget losing focus     The EventTarget receiving focus (if any).\n    // focus        The EventTarget receiving focus  The EventTarget losing focus (if any)\n    // focusin      The EventTarget receiving focus  The EventTarget losing focus (if any)\n    // focusout     The EventTarget losing focus     The EventTarget receiving focus (if any)\n    const handleOnFocus = (event: FocusEvent) => {\n      // Executing this listener means that element receiving focus lives within Popup.\n      // We are checking which element is loosing focus to avoid activating FocusTrap when focus\n      // travels among elements within FocusTrap.\n      // To enable FocusTrap the element that looses focus must live out of the Popup or is Popup's container.\n      if (\n        !contentWrapperRef.current?.contains(event.relatedTarget as Element) ||\n        event.relatedTarget === contentWrapperRef.current\n      ) {\n        // Do not activate focusTrap if the event.target is Popup itself - if we clicked on Popup's container\n        // We should be able to focus Popup container without activating FocusTrap\n        if (event.target != contentWrapperRef.current) {\n          // Enable FocusTrap.\n          setTrapDisabled(false);\n        }\n      }\n    };\n    const handleOnBlur = (event: FocusEvent) => {\n      // Executing this listener means that an element living within Popup is loosing focus.\n      // We are checking which element is receiving focus to avoid disabling FocusTrap when focs\n      // travels among elements within FocusTrap.\n      // To disable FocusTrap element the element that receives focus must live out of the Popup or is Popup's container.\n      if (\n        !contentWrapperRef.current?.contains(event.relatedTarget as Element) ||\n        event.relatedTarget === contentWrapperRef.current\n      ) {\n        // Disable FocusTrap.\n        setTrapDisabled(true);\n      }\n    };\n\n    const handlePopupKeyDown = (event: KeyboardEvent) => {\n      const currentlyFocusedEl = getActiveElement();\n      const wrapperEl = contentWrapperRef.current;\n      const launcherEl = launcherRef.current;\n      if (wrapperEl === currentlyFocusedEl || wrapperEl?.contains(currentlyFocusedEl)) {\n        switch (event.code) {\n          case 'Escape': {\n            onClose?.(event);\n            break;\n          }\n          case 'F6':\n            // Prevent default F6 handlers.\n            // F6 is a standard Chrome address bar shortcut on Windows.\n            event.preventDefault();\n            event.stopPropagation();\n\n            // Focus launcher\n            if (launcherEl) {\n              focusOn(launcherEl);\n            }\n            // Disable FocusTrap\n            setTrapDisabled(true);\n            break;\n          case 'Tab':\n            // If tabbing out of the popup when the popup itself has focus and the focus trap is\n            // disabled, transfer focus back to the launcher.  Don't let the browser then\n            // transfer focus itself from there like it normally would.\n            if (event.target === contentWrapperRef.current && trapDisabled) {\n              // Focus launcher\n              if (launcherEl) {\n                focusOn(launcherEl);\n\n                // Prevent the browser from transferring focus itself.\n                event.preventDefault();\n              }\n            }\n            break;\n        }\n      }\n    };\n\n    const onPosition = useCallback(\n      (data: PositionData) => {\n        if (placement !== data.placement) {\n          //if flips happens we need to change the placement in the animations.\n          setAnimationPlacement(data.placement);\n        }\n      },\n      [setAnimationPlacement, placement]\n    );\n\n    useLayoutEffect(() => {\n      if (\n        status === 'unmounted' ||\n        contentWrapperRef.current == null ||\n        popupBgColor != null ||\n        tail === 'none'\n      )\n        return;\n\n      const backgroundColorVar = getVarName(popupVars.backgroundColor);\n      const computedStyle = getComputedStyle(contentWrapperRef.current!);\n      setPopupBgColor(computedStyle.getPropertyValue(backgroundColorVar));\n    }, [status, contentWrapperRef, popupBgColor, tail]);\n\n    // Styles\n    const { baseTheme, classes } = useComponentTheme(PopupRedwoodTheme);\n    const isMounted = status !== 'unmounted';\n\n    const renderPopup = () => {\n      return (\n        <Floating\n          ref={stableRef}\n          backgroundColor={popupBgColor}\n          anchorRef={anchorRef}\n          placement={placement}\n          offsetValue={finalOffset}\n          flipOptions={flipOptions}\n          shiftOptions={shiftOptions}\n          onClickOutside={onClickOutside}\n          tail={tail}\n          onPosition={onPosition}>\n          <div\n            ref={contentWrapperRef}\n            tabIndex={-1}\n            role={role}\n            className={classNames([baseTheme, classes])}\n            onFocus={handleOnFocus}\n            onBlur={handleOnBlur}\n            onKeyDown={handlePopupKeyDown}\n            {...testIdProps}>\n            {/*Setting restoreFocusRef to false because otherwise FocusTrap is stealing the focus back when :*/}\n            {/*we click outside of modeless Popup (that keeps being open).*/}\n            <FocusTrap isDisabled={trapDisabled} restoreFocusRef={false}>\n              {children}\n            </FocusTrap>\n          </div>\n        </Floating>\n      );\n    };\n\n    if (isMounted) {\n      if (modality === 'modal') {\n        return <Modal isOpen={isMounted}>{renderPopup()}</Modal>;\n      } else {\n        return <Layer>{renderPopup()}</Layer>;\n      }\n    } else return null;\n  }\n);\n"],"names":["animationStates","opening","node","realPlacement","logicalSide","placement","direction","from","scaleX","scaleY","opacity","transformOrigin","_ANIMATION_TRANSFORM_ORIGIN_RULES","to","options","duration","closing","top","right","bottom","left","side","split","alignment","corner","physicalSide","normalizePosition","newPlacement","filter","Popup","forwardRef","anchorRef","children","isOpen","modality","offset","mainAxis","crossAxis","flipOptions","shiftOptions","onClose","initialFocus","onClickOutside","tail","onTransitionEnd","role","testId","ref","trapDisabled","setTrapDisabled","useState","launcherRef","useRef","popupBgColor","setPopupBgColor","contentWrapperRef","testIdProps","useTestId","animationPlacement","setAnimationPlacement","launcherKeyDownCallback","event","current","getActiveElement","code","preventDefault","stopPropagation","focusWithin","setAnimationElementRef","status","props","isAnimatedOnMount","useUser","animationElementRef","useAnimationStatus","popupElementRef","useEffect","usePopupAnimation","setInitialFocus","stableRef","useMemo","mergeRefs","returnFocus","useCallback","launcherEl","anchorEl","focusOn","Element","contains","document","body","addEventListener","removeEventListener","derivedInitialFocus","finalOffset","calcOffset","getMainAxisOffset","getCrossAxisOffset","handleOnFocus","relatedTarget","target","handleOnBlur","handlePopupKeyDown","currentlyFocusedEl","wrapperEl","onPosition","data","useLayoutEffect","backgroundColorVar","getVarName","popupVars","backgroundColor","computedStyle","getComputedStyle","getPropertyValue","baseTheme","classes","useComponentTheme","PopupRedwoodTheme","isMounted","renderPopup","_jsx","Floating","offsetValue","jsx","tabIndex","className","classNames","onFocus","onBlur","onKeyDown","FocusTrap","isDisabled","restoreFocusRef","Modal","Layer"],"mappings":"ijBA0BA,MAAMA,EAAkB,CACtBC,QAAUC,IACR,MAAMC,EAAgBC,EAAYF,EAAKG,UAAWH,EAAKI,WACvD,MAAO,CAELC,KAAM,CACJC,OAAQ,EACRC,OAAQ,EACRC,QAAS,EACTC,gBAAiBC,EAAkCT,IAErDU,GAAI,CACFL,OAAQ,EACRC,OAAQ,EACRC,QAAS,EACTC,gBAAiBC,EAAkCT,IAErDW,QAAS,CACPC,SAAU,KAEb,EAEHC,QAAUd,IACR,MAAMC,EAAgBC,EAAYF,EAAKG,UAAWH,EAAKI,WACvD,MAAO,CAELC,KAAM,CACJC,OAAQ,EACRC,OAAQ,EACRC,QAAS,EACTC,gBAAiBC,EAAkCT,IAErDU,GAAI,CACFL,OAAQ,EACRC,OAAQ,EACRC,QAAS,EACTC,gBAAiBC,EAAkCT,IAErDW,QAAS,CACPC,SAAU,KAEb,GAICH,EAAoC,CACxCK,IAAK,gBACL,YAAa,eACb,WAAY,cACZ,mBAAoB,cACpB,kBAAmB,eACnBC,MAAO,cACP,YAAa,WACb,eAAgB,cAChB,mBAAoB,cACpB,sBAAuB,WACvBC,OAAQ,aACR,eAAgB,YAChB,cAAe,WACf,sBAAuB,WACvB,qBAAsB,YACtBC,KAAM,eACN,WAAY,YACZ,cAAe,eACf,kBAAmB,eACnB,qBAAsB,aAyBlBhB,EAAc,CAClBC,EACAC,KAEA,GAAiB,MAAbD,GAAkC,MAAbC,EAAmB,MAAO,SACnD,MAAMe,EAAOhB,EAAUiB,MAAM,KAAK,GAC5BC,EAAYlB,EAAUiB,MAAM,KAAK,GACjCE,EAASnB,EAAUiB,MAAM,KAAK,GAC9BG,EAAeC,EAAAA,kBAAkBL,EAAMf,GAuBvCqB,EAtBmC,CACvC,MACA,YACA,WACA,mBACA,kBACA,QACA,YACA,eACA,mBACA,sBACA,SACA,eACA,cACA,sBACA,qBACA,OACA,WACA,cACA,kBACA,sBAE6CC,QAC5CvB,GACEkB,GACCC,GACAnB,IAAc,GAAGoB,KAAgBC,EAAAA,kBAAkBH,EAAWjB,MAAckB,KAC7ED,IACEC,GACDnB,IAAc,GAAGoB,KAAgBC,EAAiBA,kBAACH,EAAWjB,OAC9DiB,GAAalB,IAAc,GAAGoB,MAClC,GACF,OAAKE,GACI,QAGU,EC/CR,MAAAE,EAAQC,EAAAA,YACnB,EAEIC,YACAC,WACAC,UAAS,EACTC,WAAW,WACXC,SAAS,CAAEC,SAAU,EAAGC,UAAW,GACnCC,cAAc,CAAEF,UAAU,EAAMC,WAAW,GAC3CE,eAAe,CAAEH,UAAU,EAAOC,WAAW,GAC7CG,UACAC,eAAe,OACfC,iBACArC,YAAY,MACZsC,OAAO,OACPC,kBACAC,OAAO,UACPC,UAEFC,KAEA,MAAOC,EAAcC,GAAmBC,EAAQA,UAAU,GACpDC,EAAcC,SAA2B,OACxCC,EAAcC,GAAmBJ,EAAQA,WAE1CK,EAAoBH,SAA8B,MAGlDI,EAAcC,YAAUX,IAGvBY,EAAoBC,GAAyBT,EAAQA,SAAY7C,GAExE,SAASuD,EAAwBC,GAC3BV,EAAYW,UAAYC,EAAAA,oBAAqC,OAAfF,EAAMG,OAGtDH,EAAMI,iBACNJ,EAAMK,kBAENC,cAAYZ,EAAkBO,SAEjC,CAED,MAUMM,uBAAEA,EAAsBC,OAAEA,GDJ9B,SAA4BC,GAIhC,MAAMrC,OAAEA,EAAMsC,kBAAEA,EAAiB3B,gBAAEA,EAAevC,UAAEA,GAAciE,GAC5DhE,UAAEA,GAAckE,EAAAA,WAChBJ,uBAAEA,EAAsBK,oBAAEA,EAAmBJ,OAAEA,GACnDK,EAAAA,mBAA0C,CACxCzC,OAAQA,EACRsC,kBAAmBA,EACnBvE,kBACA4C,oBAEE+B,EAAkBF,EASxB,OANAG,EAAAA,WAAU,KACe,MAAnBD,GAAsD,MAA3BA,EAAgBb,SAA6B,aAAVO,IAChEM,EAAgBb,QAAQzD,UAAYA,EACpCsE,EAAgBb,QAAQxD,UAAYA,EACrC,GACA,CAACqE,EAAiBtE,EAAWC,EAAW+D,IACpC,CAAED,yBAAwBC,SACnC,CCnB+CQ,CAAkB,CAC3D5C,SACAsC,mBAAmB,EACnB3B,gBAbwBX,IACpBA,GACF6C,IACAlC,KAAkB,IAElBA,KAAkB,EACnB,EAQDvC,UAAWqD,IAEPqB,EAAYC,WAChB,IAAMC,YAAUb,EAAwBrB,IACxC,CAACqB,EAAwBrB,IAGrBmC,EAAcC,EAAAA,aAAY,KAE9B,MAAMC,EAAajC,EAAYW,QACzBuB,EAAWtD,EAAU+B,QAEvBsB,EACFE,EAAOA,QAACF,GAECC,GAAYA,aAAoBE,SACzCD,EAAOA,QAACD,EACT,GACA,CAACtD,IAEJ6C,EAAAA,WAAU,KAEH3C,GAAqB,YAAXoC,GAKTd,EAAkBO,SAAS0B,SAASzB,EAAAA,qBACtCmB,GAEH,GACA,CAACjD,EAAQoC,EAAQa,IAGpBN,EAAAA,WAAU,KACJ3C,GAAUF,EAAU+B,mBAAmByB,UAErCxB,EAAgBA,qBAAO0B,SAASC,KAClCvC,EAAYW,QAAU/B,EAAU+B,QAEhCX,EAAYW,QAAUC,EAAAA,mBAIxBZ,EAAYW,SAAS6B,iBAAiB,UAAW/B,IAE5C,KAELT,EAAYW,SAAS8B,oBAAoB,UAAWhC,EAAwB,IAE7E,CAAC3B,EAAQF,IAEZ,MAAM+C,EAAkB,KACtB,IAAIe,EAAsBpD,EACL,SAAjBA,IAEFoD,EAAsB,QAKI,UAAxBA,GACFP,UAAQ/B,EAAkBO,SAKA,mBAAxB+B,GACF1B,cAAYZ,EAAkBO,QAC/B,EA0BGgC,EAAc,CAClB1D,SAxBwB,CAACD,IACzB,IAAI4D,EAAa,EASjB,OARI5D,IAGF4D,EAA+B,iBAAX5D,EAAsBA,EAASA,EAAOC,UAAY,EACzD,WAATO,IACFoD,GAAc,IAGXA,CAAU,EAcPC,CAAkB7D,GAC5BE,UAZyB,CAACF,GACrBA,EAKsB,iBAAXA,EAAsB,EAAIA,EAAOE,WAAa,EAJrD,EAUE4D,CAAmB9D,IAa1B+D,EAAiBrC,IAMlBN,EAAkBO,SAAS0B,SAAS3B,EAAMsC,gBAC3CtC,EAAMsC,gBAAkB5C,EAAkBO,SAItCD,EAAMuC,QAAU7C,EAAkBO,SAEpCb,GAAgB,EAEnB,EAEGoD,EAAgBxC,IAMjBN,EAAkBO,SAAS0B,SAAS3B,EAAMsC,gBAC3CtC,EAAMsC,gBAAkB5C,EAAkBO,SAG1Cb,GAAgB,EACjB,EAGGqD,EAAsBzC,IAC1B,MAAM0C,EAAqBxC,EAAAA,mBACrByC,EAAYjD,EAAkBO,QAC9BsB,EAAajC,EAAYW,QAC/B,GAAI0C,IAAcD,GAAsBC,GAAWhB,SAASe,GAC1D,OAAQ1C,EAAMG,MACZ,IAAK,SACHxB,IAAUqB,GACV,MAEF,IAAK,KAGHA,EAAMI,iBACNJ,EAAMK,kBAGFkB,GACFE,EAAOA,QAACF,GAGVnC,GAAgB,GAChB,MACF,IAAK,MAICY,EAAMuC,SAAW7C,EAAkBO,SAAWd,GAE5CoC,IACFE,EAAOA,QAACF,GAGRvB,EAAMI,kBAKf,EAGGwC,EAAatB,eAChBuB,IACKrG,IAAcqG,EAAKrG,WAErBsD,EAAsB+C,EAAKrG,UAC5B,GAEH,CAACsD,EAAuBtD,IAG1BsG,EAAAA,iBAAgB,KACd,GACa,cAAXtC,GAC6B,MAA7Bd,EAAkBO,SACF,MAAhBT,GACS,SAATV,EAEA,OAEF,MAAMiE,EAAqBC,EAAAA,WAAWC,EAASA,UAACC,iBAC1CC,EAAgBC,iBAAiB1D,EAAkBO,SACzDR,EAAgB0D,EAAcE,iBAAiBN,GAAoB,GAClE,CAACvC,EAAQd,EAAmBF,EAAcV,IAG7C,MAAMwE,UAAEA,EAASC,QAAEA,IAAYC,EAAiBA,kBAACC,EAAiBA,mBAC5DC,GAAuB,cAAXlD,EAEZmD,GAAc,IAEhBC,MAACC,EAAQA,SAAA,CACP3E,IAAKgC,EACLgC,gBAAiB1D,EACjBtB,UAAWA,EACX1B,UAAWA,EACXsH,YAAa7B,EACbxD,YAAaA,EACbC,aAAcA,EACdG,eAAgBA,EAChBC,KAAMA,EACN8D,WAAYA,EACZzE,SAAAyF,EAAAG,IAAA,MAAA,CACE7E,IAAKQ,EACLsE,UAAW,EACXhF,KAAMA,EACNiF,UAAWC,EAAAA,WAAW,CAACZ,EAAWC,KAClCY,QAAS9B,EACT+B,OAAQ5B,EACR6B,UAAW5B,KACP9C,EAGJxB,SAAAyF,EAAAA,IAACU,EAAAA,UAAS,CAACC,WAAYpF,EAAcqF,iBAAiB,EAAKrG,SACxDA,QAOX,OAAIuF,GACe,UAAbrF,EACKuF,EAAAG,IAACU,EAAKA,MAAA,CAACrG,OAAQsF,GAAYvF,SAAAwF,OAE3BC,EAAAA,IAACc,EAAAA,MAAK,CAAAvG,SAAEwF,OAEL,IAAI"}