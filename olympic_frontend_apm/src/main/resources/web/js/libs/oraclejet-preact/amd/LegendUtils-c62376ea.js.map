{"version":3,"file":"LegendUtils-c62376ea.js","sources":["../../src/UNSAFE_Legend/LegendUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { ItemInfo, LegendItem, LegendSection } from './Legend.type';\nimport { LayoutInfo } from './useLegendLayout';\nimport { dvtVars } from '../Common/themes/themeContract.css';\nimport { xUnits } from '../UNSAFE_Theme/utils';\nimport { Font } from '../hooks/PRIVATE_useTextDimensions';\n\n/**\n * Returns the value of the data-oj-item-index attribute for a given element.\n * @param element The HTML element.\n * @returns\n */\nexport const getItemInfo = (element: HTMLElement) => {\n  const item = element.dataset['ojItem'];\n  const section = element.dataset['ojSection'];\n\n  if (item == null || section == null) {\n    return;\n  }\n  return {\n    itemIdx: Number(item),\n    sectionIdx: Number(section)\n  };\n};\n\n/**\n * Checks if the item is highlighted.\n * @param id Id of the item\n * @param highlighted The set of highlighted item\n */\nexport function isItemHighlighted<K>(id: K, highlighted?: K[]) {\n  if (!highlighted) {\n    return;\n  }\n  if (highlighted.length === 0) {\n    return true;\n  }\n  return new Set(highlighted).has(id);\n}\n\n/**\n * Checks if the item is hidden.\n * @param id Id of the item.\n * @param hiddenIds The set of hidden items.\n * @returns\n */\nexport function isItemHidden<K>(id: K, hiddenIds?: K[]) {\n  if (!hiddenIds) {\n    return;\n  }\n  return new Set(hiddenIds).has(id);\n}\n/**\n * Checks if the item is the currentItem and if the focus ring\n * is visible.\n * @param itemInfo ItemInfo\n * @param itemIdx Item index\n * @param sectionIdx Section index\n */\nexport const hasFocusRing = (itemInfo: ItemInfo, itemIdx: number, sectionIdx?: number) => {\n  if (!itemInfo.isFocusVisible) return false;\n  const { itemIdx: item, sectionIdx: section } = itemInfo;\n\n  if (sectionIdx == null) {\n    return item === itemIdx;\n  }\n  return item === itemIdx && section === sectionIdx;\n};\n\n/**\n * Returns the text for the legend datatip.\n * @param items The legend items data.\n * @param itemInfoRef The item currently hovered.\n * @param currentItem The item that is currently keyboard focused.\n */\nexport function getDatatipText<K>(\n  items: LegendItem<K>[] | LegendSection<K>[],\n  getItem: (\n    itemInfo: ItemInfo,\n    items: LegendItem<K>[] | LegendSection<K>[]\n  ) => LegendItem<K> | undefined,\n  focusedItem: ItemInfo,\n  hoveredItem?: ItemInfo\n) {\n  const isPointerActive = hoveredItem?.isCurrent;\n\n  if (isPointerActive && hoveredItem.itemIdx != null) {\n    return getItem(hoveredItem, items)?.datatip;\n  }\n  if (focusedItem && focusedItem.isCurrent) {\n    return getItem(focusedItem, items)?.datatip;\n  }\n  return;\n}\n\n/**\n * Returns the aria properties for the legend.\n * @param isReadOnly { boolean } If the legend is readonly.\n * @param ariaLabel { string } The aria-label set by the app.\n * @returns The aria props.\n */\nexport function getAriaProps<K>(\n  isReadOnly?: boolean,\n  ariaLabel?: string,\n  hiddenIds?: K[],\n  ariaDescribedBy?: string,\n  ariaLabelledBy?: string\n): {\n  'aria-label'?: HTMLAttributesSignalExcluded['aria-label'];\n  'aria-disabled'?: HTMLAttributesSignalExcluded['aria-disabled'];\n  'aria-describedBy': HTMLAttributesSignalExcluded['aria-describedby'];\n  'aria-LabelledBy': HTMLAttributesSignalExcluded['aria-labelledby'];\n  role?: HTMLAttributesSignalExcluded['role'];\n} {\n  const hideAndShow = hiddenIds && !isReadOnly;\n  return {\n    'aria-label': ariaLabel,\n    'aria-disabled': isReadOnly,\n    role: hideAndShow ? 'menu' : 'application',\n    'aria-describedBy': ariaDescribedBy,\n    'aria-LabelledBy': ariaLabelledBy\n  };\n}\n\n/**\n * Gererates randomId used for aria-activedescendant.\n * @returns\n */\nexport function getRandomId() {\n  return `_${Math.random().toString(36).slice(2)}`; //@RandomNumberOK\n}\n\n/**\n * Returns the item props for BaseLegendItem.\n * @param item The legend item.\n * @param itemIdx The item index of the item.\n * @param sectionIdx The section index of section of the item.\n * @param focusedItem The info of currently focused item.\n * @param isReadOnly Whether the legend is readonly.\n * @param hoveredItem The info of the currently hovered item.\n * @param hiddenIds The hidden ids.\n * @param highlightedIds The highlighted ids.\n */\nexport function getItemProps<K>(\n  item: LegendItem<K>,\n  itemIdx: number,\n  sectionIdx: number | undefined,\n  focusedItem: ItemInfo,\n  isReadOnly?: boolean,\n  hoveredItem?: ItemInfo,\n  hiddenIds?: K[],\n  highlightedIds?: K[]\n) {\n  let isCurrent = false;\n  if (!isReadOnly) {\n    const isFocusedItem = itemIdx === focusedItem.itemIdx && sectionIdx === focusedItem.sectionIdx;\n    const isHoveredItem =\n      itemIdx === hoveredItem?.itemIdx && sectionIdx === hoveredItem?.sectionIdx;\n    isCurrent = !!(\n      (isFocusedItem && focusedItem.isCurrent) ||\n      (isHoveredItem && hoveredItem?.isCurrent)\n    );\n  }\n\n  return {\n    isCurrent,\n    isHighlighted: isItemHighlighted(item.id, highlightedIds),\n    isHidden: isItemHidden(item.id, hiddenIds),\n    isFocused: hasFocusRing(focusedItem, itemIdx, sectionIdx),\n    key: item.id,\n    ...item\n  };\n}\n\n/**\n * Compares if two ItemInfo are equal\n * @param item1\n * @param item2\n * @returns\n */\nexport const isEqualItem = (item1?: ItemInfo, item2?: ItemInfo) => {\n  return item1?.itemIdx === item2?.itemIdx && item1?.sectionIdx === item2?.sectionIdx;\n};\n\n/**\n * Returns the num of cols and rows for the legend.\n */\nexport const getGridNums = (numItems: number, layoutInfo?: LayoutInfo) => {\n  let itemsPerRow;\n  let itemsPerCol;\n\n  if (layoutInfo?.isWrapped) {\n    itemsPerRow = layoutInfo.itemsPerRow;\n    itemsPerCol = Math.ceil(numItems / itemsPerRow);\n    itemsPerRow = Math.ceil(numItems / itemsPerCol);\n  }\n\n  return { itemsPerRow, itemsPerCol };\n};\n\n/**\n * Returns the grid row and column for given item.\n * @param noOfItems The number of items in the section.\n * @param index The index of the item.\n * @param itemsPerRow The num of items per row in the grid.\n * @param itemsPerCol The num of items per col in the grid.\n * @returns\n */\nexport function getGridCellIndices(\n  noOfItems: number,\n  index: number,\n  itemsPerRow?: number,\n  itemsPerCol?: number\n) {\n  let gridRow;\n  let gridCol;\n\n  if (itemsPerRow && itemsPerCol && noOfItems > itemsPerRow) {\n    gridRow = (index % itemsPerCol) + 1;\n    gridCol = Math.floor(index / itemsPerCol) + 1;\n  }\n  return { gridRow, gridCol };\n}\n\n/**\n * Returns the resolved values for the legend vars.\n */\n\nexport const legendVars = [\n  {\n    tokenVar: xUnits(1),\n    key: 'unit',\n    cssProp: 'padding'\n  },\n  {\n    tokenVar: dvtVars.label.sm.fontSize,\n    key: 'fontSize',\n    cssProp: 'font-size'\n  }\n];\n\n/**\n * Returns the resolved values for the legend vars.\n */\n\nexport function getLegendTextStyle(props: Font, resolvedVars: Record<string, any>) {\n  return {\n    fontStyle: props.fontStyle,\n    fontSize: (resolvedVars['fontSize'] ?? props.fontSize) as string | undefined,\n    fontWeight: props.fontWeight,\n    fontFamily: props.fontFamily\n  };\n}\n"],"names":["isItemHighlighted","id","highlighted","length","Set","has","isItemHidden","hiddenIds","hasFocusRing","itemInfo","itemIdx","sectionIdx","isFocusVisible","item","section","legendVars","tokenVar","xUnits","key","cssProp","dvtVars","label","sm","fontSize","isReadOnly","ariaLabel","ariaDescribedBy","ariaLabelledBy","role","items","getItem","focusedItem","hoveredItem","isPointerActive","isCurrent","datatip","noOfItems","index","itemsPerRow","itemsPerCol","gridRow","gridCol","Math","floor","numItems","layoutInfo","isWrapped","ceil","element","dataset","Number","highlightedIds","isFocusedItem","isHoveredItem","isHighlighted","isHidden","isFocused","props","resolvedVars","fontStyle","fontWeight","fontFamily","random","toString","slice","item1","item2"],"mappings":"wGAsCgB,SAAAA,EAAqBC,EAAOC,GAC1C,GAAKA,EAGL,OAA2B,IAAvBA,EAAYC,QAGT,IAAIC,IAAIF,GAAaG,IAAIJ,EAClC,CAQgB,SAAAK,EAAgBL,EAAOM,GACrC,GAAKA,EAGL,OAAO,IAAIH,IAAIG,GAAWF,IAAIJ,EAChC,CAQO,MAAMO,EAAe,CAACC,EAAoBC,EAAiBC,KAChE,IAAKF,EAASG,eAAgB,OAAO,EACrC,MAAQF,QAASG,EAAMF,WAAYG,GAAYL,EAE/C,OAAkB,MAAdE,EACKE,IAASH,EAEXG,IAASH,GAAWI,IAAYH,CAAU,EAkKtC,MAAAI,EAAa,CACxB,CACEC,SAAUC,EAAMA,OAAC,GACjBC,IAAK,OACLC,QAAS,WAEX,CACEH,SAAUI,EAAOA,QAACC,MAAMC,GAAGC,SAC3BL,IAAK,WACLC,QAAS,6BAxIP,SACJK,EACAC,EACAlB,EACAmB,EACAC,GASA,MAAO,CACL,aAAcF,EACd,gBAAiBD,EACjBI,KAJkBrB,IAAciB,EAIZ,OAAS,cAC7B,mBAAoBE,EACpB,kBAAmBC,EAEvB,mBA/CM,SACJE,EACAC,EAIAC,EACAC,GAEA,MAAMC,EAAkBD,GAAaE,UAErC,OAAID,GAA0C,MAAvBD,EAAYtB,QAC1BoB,EAAQE,EAAaH,IAAQM,QAElCJ,GAAeA,EAAYG,UACtBJ,EAAQC,EAAaF,IAAQM,aADtC,CAIF,uBAmHM,SACJC,EACAC,EACAC,EACAC,GAEA,IAAIC,EACAC,EAMJ,OAJIH,GAAeC,GAAeH,EAAYE,IAC5CE,EAAWH,EAAQE,EAAe,EAClCE,EAAUC,KAAKC,MAAMN,EAAQE,GAAe,GAEvC,CAAEC,UAASC,UACpB,gBAnC2B,CAACG,EAAkBC,KAC5C,IAAIP,EACAC,EAQJ,OANIM,GAAYC,YACdR,EAAcO,EAAWP,YACzBC,EAAcG,KAAKK,KAAKH,EAAWN,GACnCA,EAAcI,KAAKK,KAAKH,EAAWL,IAG9B,CAAED,cAAaC,cAAa,gBAzLTS,IAC1B,MAAMnC,EAAOmC,EAAQC,QAAgB,OAC/BnC,EAAUkC,EAAQC,QAAmB,UAE3C,GAAY,MAARpC,GAA2B,MAAXC,EAGpB,MAAO,CACLJ,QAASwC,OAAOrC,GAChBF,WAAYuC,OAAOpC,GACpB,0BA0HDD,EACAH,EACAC,EACAoB,EACAP,EACAQ,EACAzB,EACA4C,GAEA,IAAIjB,GAAY,EAChB,IAAKV,EAAY,CACf,MAAM4B,EAAgB1C,IAAYqB,EAAYrB,SAAWC,IAAeoB,EAAYpB,WAC9E0C,EACJ3C,IAAYsB,GAAatB,SAAWC,IAAeqB,GAAarB,WAClEuB,KACGkB,GAAiBrB,EAAYG,WAC7BmB,GAAiBrB,GAAaE,UAElC,CAED,MAAO,CACLA,YACAoB,cAAetD,EAAkBa,EAAKZ,GAAIkD,GAC1CI,SAAUjD,EAAaO,EAAKZ,GAAIM,GAChCiD,UAAWhD,EAAauB,EAAarB,EAASC,GAC9CO,IAAKL,EAAKZ,MACPY,EAEP,uBAyEgB,SAAmB4C,EAAaC,GAC9C,MAAO,CACLC,UAAWF,EAAME,UACjBpC,SAAWmC,EAAuB,UAAKD,EAAMlC,SAC7CqC,WAAYH,EAAMG,WAClBC,WAAYJ,EAAMI,WAEtB,2BA3HE,MAAO,IAAInB,KAAKoB,SAASC,SAAS,IAAIC,MAAM,IAC9C,gBAkD2B,CAACC,EAAkBC,IACrCD,GAAOvD,UAAYwD,GAAOxD,SAAWuD,GAAOtD,aAAeuD,GAAOvD"}