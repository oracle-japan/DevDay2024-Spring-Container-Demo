{"version":3,"file":"Diagram-c6d2d51b.js","sources":["../../src/UNSAFE_Diagram/utils/diagramUtils.ts","../../src/UNSAFE_Diagram/DiagramNodeElement.tsx","../../src/UNSAFE_Diagram/DiagramNodeLayer.tsx","../../src/UNSAFE_Diagram/DiagramLinkElement.tsx","../../src/UNSAFE_Diagram/DiagramLinkLayer.tsx","../../src/UNSAFE_Diagram/DiagramLabel.tsx","../../src/UNSAFE_Diagram/DiagramLabelLayer.tsx","../../src/UNSAFE_Diagram/DiagramLayers.tsx","../../src/UNSAFE_Diagram/DiagramPanZoomContainer.tsx","../../src/UNSAFE_Diagram/utils/navUtils.ts","../../src/UNSAFE_Diagram/hooks/useDiagramNavigation.ts","../../src/UNSAFE_Diagram/hooks/useEvents.ts","../../src/UNSAFE_Diagram/hooks/useDiagramDatatip.ts","../../src/UNSAFE_Diagram/hooks/usePointerGesture.ts","../../src/UNSAFE_Diagram/utils/panUtils.ts","../../src/UNSAFE_Diagram/hooks/useDragPan.ts","../../src/UNSAFE_Diagram/hooks/useDrag.ts","../../src/UNSAFE_Diagram/utils/zoomUtils.ts","../../src/UNSAFE_Diagram/hooks/usePinch.ts","../../src/UNSAFE_Diagram/hooks/usePinchZoom.ts","../../src/UNSAFE_Diagram/hooks/usePanZoom.ts","../../src/UNSAFE_Diagram/hooks/useWheelZoom.ts","../../src/UNSAFE_Diagram/hooks/useWheel.ts","../../src/UNSAFE_Diagram/hooks/useDiagramSelection.ts","../../src/UNSAFE_Diagram/Diagram.tsx"],"sourcesContent":["import type {\n  Pan,\n  Zoom,\n  DiagramNode,\n  DiagramLink,\n  DiagramLayoutOutput,\n  ItemInfo,\n  Bounds,\n  Position,\n  Dimensions,\n  DatatipContext,\n  DiagramLabelStyles,\n  DiagramLabelPosition\n} from '../Diagram.types';\nimport type { Ref } from 'preact/hooks';\nimport type { BundleType } from '../../resources/nls/bundle';\nimport type { Font, TextDimensions } from '../../hooks/PRIVATE_useTextDimensions';\n\nconst ZOOM_TO_FIT_PADDING = 20;\n/**\n * Returns the pan properties for the diagram.\n */\nexport function getPanProps(props: Pan, contentBounds: Bounds) {\n  return {\n    panning: props.panning ? props.panning : 'off',\n    panDirection: props.panDirection ? props.panDirection : 'any',\n    centerX: props.centerX !== undefined ? props.centerX : contentBounds.w / 2 + contentBounds.x,\n    centerY: props.centerY !== undefined ? props.centerY : contentBounds.h / 2 + contentBounds.y,\n    onPan: props.onPan\n  };\n}\n\n/**\n * Returns the zoom properties for the diagram.\n */\nexport function getZoomProps(props: Zoom, width: number, height: number, contentBounds: Bounds) {\n  const minZoom = props.minZoom ? props.minZoom : getZoomToFitZoom(width, height, contentBounds);\n  const maxZoom = props.maxZoom !== undefined ? props.maxZoom : 1;\n  const zoom = props.zoomValue ? props.zoomValue : getZoomToFitZoom(width, height, contentBounds);\n  return {\n    zooming: props.zooming ? props.zooming : 'off',\n    // default value of 0 indicates zoom-to-fit level\n    minZoom: minZoom,\n    maxZoom: maxZoom,\n    // zoom value of 0 will default to zoom to fit\n    zoomValue: constrainZoom(zoom, minZoom, maxZoom),\n    onZoom: props.onZoom\n  };\n}\n\n/**\n * Constructs the json object to be passed into the layout function\n */\nexport function constructLayoutJSON<K1, K2>(\n  nodes: DiagramNode<K1>[],\n  nodeItems: Map<K1, DiagramNode<K1>>,\n  linkItems: Map<K2, DiagramLink<K2, K1>>,\n  dimensions: Dimensions[],\n  width: number,\n  height: number,\n  getTextDimensions?: (textString: string, font?: Font) => TextDimensions\n) {\n  const labelDims: Map<K1 | K2, TextDimensions> = new Map();\n  const nodeKeys = Array.from(nodeItems.keys());\n  for (const id of nodeKeys) {\n    const item = nodeItems.get(id as K1);\n    if (item && getTextDimensions && item.label) {\n      const label = item.label;\n      const fontProps = _getFontProps(item.labelStyle);\n      labelDims.set(id as K1 | K2, getTextDimensions(label, fontProps));\n    }\n  }\n  const linkKeys = Array.from(linkItems.keys());\n  for (const id of linkKeys) {\n    const item = linkItems.get(id as K2);\n    if (item && getTextDimensions && item.label) {\n      const label = item.label;\n      const fontProps = _getFontProps(item.labelStyle);\n      labelDims.set(id as K1 | K2, getTextDimensions(label, fontProps));\n    }\n  }\n  const getLabelDimensions = function (data: DiagramNode<K1> | DiagramLink<K2, K1>) {\n    return labelDims.get(data.id);\n  };\n  const getNodeDimensions = function (data: DiagramNode<K1>) {\n    for (let i = 0; i < nodes.length; i++) {\n      if (data.id === nodes[i].id) {\n        return dimensions[i];\n      }\n    }\n    return dimensions[0];\n  };\n\n  return {\n    layoutJSON: {\n      getNodeDimensions: getNodeDimensions,\n      getLabelDimensions: getLabelDimensions,\n      componentSize: {\n        width: width,\n        height: height\n      }\n    },\n    labelDims: labelDims\n  };\n}\n\n/**\n * Deconstructs the output of the layout function\n */\nexport function deconstructLayoutJSON<K1, K2>(\n  layoutJSON: DiagramLayoutOutput,\n  nodeData: DiagramNode<K1>[],\n  linkData: DiagramLink<K2, K1>[]\n) {\n  const nodes = layoutJSON.nodes;\n  const links = layoutJSON.links;\n  const positions: Position[] = [];\n  const nodeLabelPos: (DiagramLabelPosition | undefined)[] = [];\n  const linkLabelPos: DiagramLabelPosition[] = [];\n  let hasNodeLabels = false;\n  let hasLinkLabels = false;\n  let node, link;\n  for (let i = 0; i < nodeData.length; i++) {\n    node = nodes[nodeData[i].id as string | number];\n    positions.push(node.position);\n    if (node.label) hasNodeLabels = true;\n    nodeLabelPos.push(node.label);\n  }\n  if (links) {\n    for (let i = 0; i < linkData.length; i++) {\n      link = links[linkData[i].id as string | number];\n      if (link.label) hasLinkLabels = true;\n      linkLabelPos.push(link.label);\n    }\n  }\n  return {\n    nodePoints: positions,\n    nodeLabelPos: hasNodeLabels ? nodeLabelPos : undefined,\n    linkLabelPos: hasLinkLabels ? linkLabelPos : undefined\n  };\n}\n\n/**\n * Merges the node points into the dimensions\n */\nexport function mergeDimensions(dimensions: Dimensions[], nodePoints: Position[]) {\n  const newBounds: Bounds[] = [];\n  for (let i = 0; i < dimensions.length; i++) {\n    const point = nodePoints[i];\n    const dim = dimensions[i];\n    newBounds.push({ x: point.x, y: point.y, w: dim.w, h: dim.h });\n  }\n  return newBounds;\n}\n\n/**\n * Returns the text for the diagram datatip.\n */\nexport function getDatatipText<K1, K2>(\n  nodesMap: Map<K1, DiagramNode<K1>>,\n  linksMap: Map<K2, DiagramLink<K2, K1>>,\n  focusedItem?: ItemInfo<K1, K2>,\n  hoveredItem?: ItemInfo<K1, K2>,\n  datatip?: (detail: DatatipContext<K1, K2>) => string\n) {\n  let itemInfo;\n  const isPointerActive = hoveredItem?.isCurrent;\n  if (isPointerActive && hoveredItem.id != null) {\n    itemInfo = hoveredItem;\n  }\n  if (focusedItem && focusedItem.isCurrent) {\n    itemInfo = focusedItem;\n  }\n  if (itemInfo && datatip) {\n    return datatip({\n      data: (itemInfo.isNode ? nodesMap.get(itemInfo.id as K1) : linksMap.get(itemInfo.id as K2))!,\n      type: itemInfo.isNode ? 'node' : 'link'\n    });\n  }\n  if (itemInfo)\n    return (itemInfo.isNode ? nodesMap.get(itemInfo.id as K1) : linksMap.get(itemInfo.id as K2))\n      ?.accessibleLabel;\n  return;\n}\n\n/**\n * Creates a map with key id and value node or link data\n */\nexport function createItemMap<K1, K2>(items: (DiagramNode<K1> | DiagramLink<K2, K1>)[]) {\n  const itemIdToDataMap = new Map();\n  const itemIdToIndexMap = new Map();\n  const itemIndexToIdMap = new Map();\n  for (let i = 0; i < items.length; i++) {\n    itemIdToDataMap.set(items[i].id, items[i]);\n    itemIdToIndexMap.set(items[i].id, i);\n    itemIndexToIdMap.set(i, items[i].id);\n  }\n  return {\n    itemIdToDataMap,\n    itemIdToIndexMap,\n    itemIndexToIdMap\n  };\n}\n\n/**\n * Filter out links with no start or end nodes\n */\nexport function filterLinksWithNoEndNodes<K2, K1>(\n  links: DiagramLink<K2, K1>[],\n  nodesMap: Map<K1, DiagramNode<K1>>\n) {\n  const newLinks: DiagramLink<K2, K1>[] = [];\n  for (let i = 0; i < links.length; i++) {\n    const link = links[i];\n    if (nodesMap.get(link.startNode) && nodesMap.get(link.endNode)) {\n      newLinks.push(link);\n    }\n  }\n  return newLinks;\n}\n\n/**\n * Pulls out the dimensions from an array of bounds\n */\nexport function getDimensionsFromBounds(bounds: Bounds[]) {\n  const dims: Dimensions[] = [];\n  for (let i = 0; i < bounds.length; i++) {\n    dims.push({ w: bounds[i].w, h: bounds[i].h });\n  }\n  return dims;\n}\n\n/**\n * Returns true if event is a selection event\n */\nexport function isSelectionEvent(event: KeyboardEvent): boolean {\n  if (event.altKey && (event.key === '≥' || event.key === '≤')) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns the center position of the node or link\n * For links, draws a straight line between the centers of the start/end node\n * and returns the center of that line\n */\nexport function getFocusedItemBounds<K1, K2>(\n  focusedItemInfo: ItemInfo<K1, K2>,\n  bounds: Bounds[],\n  links: DiagramLink<K2, K1>[],\n  nodeIdToIndexMap: Map<K1, number>,\n  linkIdToIndexMap: Map<K2, number>\n) {\n  if (focusedItemInfo.isNode) {\n    const idx = nodeIdToIndexMap.get(focusedItemInfo.id as K1);\n    // Return the first element if cannot find the Node index\n    return bounds[idx || 0];\n  } else {\n    // Center of a straight line between start/end node centers\n    const link = links[linkIdToIndexMap.get(focusedItemInfo.id as K2) || 0];\n    const startNB = bounds[nodeIdToIndexMap.get(link.startNode) || 0];\n    const endNB = bounds[nodeIdToIndexMap.get(link.endNode) || 0];\n    const startNCenter = { x: startNB.x + startNB.w / 2, y: startNB.y + startNB.h / 2 };\n    const endNCenter = { x: endNB.x + endNB.w / 2, y: endNB.y + endNB.h / 2 };\n    const minX = Math.min(startNCenter.x, endNCenter.x);\n    const minY = Math.min(startNCenter.y, endNCenter.y);\n    return {\n      x: minX,\n      y: minY,\n      w: Math.abs(startNCenter.x - endNCenter.x),\n      h: Math.abs(startNCenter.y - endNCenter.y)\n    };\n  }\n}\n/**\n * Combines the node and link ids into one array\n */\nexport function combineIds<K1, K2>(nodeIds?: K1[], linkIds?: K2[]) {\n  const combinedIds: (K1 | K2)[] = [];\n  if (nodeIds) {\n    for (let i = 0; i < nodeIds.length; i++) {\n      combinedIds.push(nodeIds[i]);\n    }\n  }\n  if (linkIds) {\n    for (let i = 0; i < linkIds.length; i++) {\n      combinedIds.push(linkIds[i]);\n    }\n  }\n  return combinedIds;\n}\n\n/**\n * Returns the bounds of the diagram content\n */\nexport function getContentBounds(nodeBounds: Bounds[], labelBounds?: Bounds): Bounds {\n  if (nodeBounds.length === 0) return { x: 0, w: Infinity, y: 0, h: Infinity };\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let dims;\n  for (let i = 0; i < nodeBounds.length; i++) {\n    dims = nodeBounds[i];\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.w > maxX ? dims.x + dims.w : maxX;\n    maxY = dims.y + dims.h > maxY ? dims.y + dims.h : maxY;\n  }\n  if (labelBounds) {\n    minX = labelBounds.x < minX ? labelBounds.x : minX;\n    minY = labelBounds.y < minY ? labelBounds.y : minY;\n    maxX = labelBounds.x + labelBounds.w > maxX ? labelBounds.x + labelBounds.w : maxX;\n    maxY = labelBounds.y + labelBounds.h > maxY ? labelBounds.y + labelBounds.h : maxY;\n  }\n  return { x: minX, w: maxX - minX, y: minY, h: maxY - minY };\n}\n\n/**\n * Returns the label bounds\n */\nexport function getAllLabelBounds<K1, K2>(\n  labelDims: Map<K1 | K2, TextDimensions>,\n  nodes: DiagramNode<K1>[],\n  links: DiagramLink<K2, K1>[],\n  nodeLabelPos: (DiagramLabelPosition | undefined)[] = [],\n  linkLabelPos: DiagramLabelPosition[] = [],\n  isRTL: boolean\n) {\n  if (nodeLabelPos.length === 0 && linkLabelPos.length === 0) return undefined;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let dims, label;\n  for (let i = 0; i < nodeLabelPos.length; i++) {\n    label = nodeLabelPos[i];\n    if (!label) continue;\n    dims = getLabelBounds(label, labelDims.get(nodes[i].id)!, isRTL);\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.w > maxX ? dims.x + dims.w : maxX;\n    maxY = dims.y + dims.h > maxY ? dims.y + dims.h : maxY;\n  }\n  for (let i = 0; i < linkLabelPos.length; i++) {\n    label = linkLabelPos[i];\n    if (!label) continue;\n    dims = getLabelBounds(label, labelDims.get(links[i].id)!, isRTL);\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.w > maxX ? dims.x + dims.w : maxX;\n    maxY = dims.y + dims.h > maxY ? dims.y + dims.h : maxY;\n  }\n  return { x: minX, w: maxX - minX, y: minY, h: maxY - minY };\n}\n\nfunction getLabelBounds(label: DiagramLabelPosition, dims: TextDimensions, isRTL: boolean) {\n  const labelPos = getLabelPosition(dims, label, isRTL);\n  const isRotating = label.rotationAngle;\n  if (!isRotating) {\n    return { x: labelPos.x, y: labelPos.y, w: dims.width, h: dims.height };\n  } else {\n    // Find the 4 corners of the label bounds relative to the rotation point\n    const rotationPoint = label.rotationPoint\n      ? label.rotationPoint\n      : { x: dims.width / 2, y: dims.height / 2 };\n    const angle = label.rotationAngle!;\n    const topLeft = getCoordsRelToRotPoint({ x: 0, y: 0 }, rotationPoint);\n    const topRight = getCoordsRelToRotPoint({ x: dims.width, y: 0 }, rotationPoint);\n    const bottomLeft = getCoordsRelToRotPoint({ x: 0, y: dims.height }, rotationPoint);\n    const bottomRight = getCoordsRelToRotPoint({ x: dims.width, y: dims.height }, rotationPoint);\n    const rotTopLeft = rotatePoint(topLeft, angle);\n    const rotBotLeft = rotatePoint(bottomLeft, angle);\n    const rotTopRight = rotatePoint(topRight, angle);\n    const rotBotRight = rotatePoint(bottomRight, angle);\n    const points = [rotTopLeft, rotBotLeft, rotTopRight, rotBotRight].map((pos: Position) => {\n      return {\n        x: pos.x + labelPos.x + rotationPoint.x,\n        y: pos.y + labelPos.y + rotationPoint.y\n      };\n    });\n    return getBoundsFromPoints(points);\n  }\n}\n\nfunction getCoordsRelToRotPoint(labelPoint: Position, rotPoint: Position) {\n  return { x: labelPoint.x - rotPoint.x, y: labelPoint.y - rotPoint.y };\n}\n\nfunction rotatePoint(pos: Position, angle: number) {\n  return {\n    x: pos.x * Math.cos(angle) - pos.y * Math.sin(angle),\n    y: pos.x * Math.sin(angle) + pos.y * Math.cos(angle)\n  };\n}\n\nfunction getBoundsFromPoints(points: Position[]) {\n  let minX = points[0].x;\n  let minY = points[0].y;\n  let maxX = points[0].x;\n  let maxY = points[0].y;\n  for (let i = 1; i < points.length; i++) {\n    const point = points[i];\n    if (point.x < minX) minX = point.x;\n    else if (point.x > maxX) maxX = point.x;\n    if (point.y < minY) minY = point.y;\n    else if (point.y > maxY) maxY = point.y;\n  }\n  return {\n    x: minX,\n    y: minY,\n    w: maxX - minX,\n    h: maxY - minY\n  };\n}\n\n/**\n * Returns the position of the label\n * @param dimensions\n * @param positionProps\n * @returns position of the label\n */\nexport function getLabelPosition(\n  dimensions: TextDimensions,\n  positionProps: DiagramLabelPosition,\n  isRTL: boolean\n) {\n  const position = positionProps.position;\n  const hAlign = positionProps.hAlign ? positionProps.hAlign : isRTL ? 'right' : 'left';\n  const vAlign = positionProps.vAlign;\n  let x, y;\n  if (hAlign === 'center') {\n    x = position.x - dimensions.width / 2;\n  } else if (hAlign === 'right') {\n    x = position.x - dimensions.width;\n  } else {\n    x = position.x;\n  }\n\n  if (vAlign === 'middle') {\n    y = position.y - dimensions.height / 2;\n  } else if (vAlign === 'bottom') {\n    y = position.y - dimensions.height;\n  } else if (vAlign === 'baseline') {\n    y = position.y + dimensions.y;\n  } else {\n    y = position.y;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\n\n/**\n * Converts centerX,Y coordinates to panX,Y coordinates\n */\nexport function centerXYToPanXY(\n  centerX: number,\n  centerY: number,\n  zoom: number,\n  width: number,\n  height: number\n) {\n  return {\n    panX: width / 2 - centerX * zoom,\n    panY: height / 2 - centerY * zoom\n  };\n}\n/**\n * Converts panX,Y coordinates to centerX,Y coordinates\n */\nexport function panXYToCenterXY(\n  panX: number,\n  panY: number,\n  zoom: number,\n  width: number,\n  height: number\n) {\n  return {\n    centerX: (width / 2 - panX) / zoom,\n    centerY: (height / 2 - panY) / zoom\n  };\n}\n\n/**\n * Compares if two ItemInfo are equal\n */\nexport function isEqualItem<K1, K2>(item1?: ItemInfo<K1, K2>, item2?: ItemInfo<K1, K2>) {\n  return item1?.id === item2?.id && item1?.isNode === item2?.isNode;\n}\n\n/**\n * Returns the item info of the data-oj-node or data-oj-link attribute for a given element.\n */\nexport function getNavigableInfo<K1, K2>(\n  element: HTMLElement,\n  rootElementRef?: Ref<HTMLDivElement>\n): ItemInfo<K1, K2> {\n  let isNode = false;\n  let elem = element;\n  let navigableId;\n  while (!navigableId) {\n    navigableId = elem.dataset['node'];\n    if (navigableId) {\n      isNode = true;\n    } else {\n      navigableId = elem.dataset['link'];\n    }\n    if (!navigableId) {\n      if (elem.parentElement && elem.parentElement !== rootElementRef?.current) {\n        elem = elem.parentElement;\n      } else {\n        break;\n      }\n    }\n  }\n  return {\n    id: navigableId as K1 | K2,\n    isNode: isNode\n  };\n}\n\n/**\n * Returns the id of the focused item.\n */\nexport function getFocusedItem<K1, K2>(\n  focusedItemInfo: ItemInfo<K1, K2>,\n  hoveredItemInfo?: ItemInfo<K1, K2>\n) {\n  let focused;\n  if (focusedItemInfo.isCurrent && focusedItemInfo.isFocusVisible) {\n    focused = focusedItemInfo.id;\n  } else if (hoveredItemInfo?.isCurrent) {\n    focused = hoveredItemInfo.id;\n  }\n  return focused;\n}\n\n/**\n * Returns the aria label\n */\nexport function getItemAriaLabel(\n  translations: BundleType,\n  supportsSelection: boolean,\n  isSelected?: boolean,\n  accessibleLabel?: string\n) {\n  translations.dataVisualization_stateSelected();\n  return supportsSelection\n    ? `${accessibleLabel}. ${\n        isSelected\n          ? translations.dataVisualization_stateSelected()\n          : translations.dataVisualization_stateUnselected()\n      }`\n    : accessibleLabel;\n}\n\n/**\n * Returns the zoom to fit zoom level\n */\nexport function getZoomToFitZoom(width: number, height: number, contentBounds: Bounds) {\n  const zoomX = (width - 2 * ZOOM_TO_FIT_PADDING) / contentBounds.w;\n  const zoomY = (height - 2 * ZOOM_TO_FIT_PADDING) / contentBounds.h;\n  return Math.min(zoomX, zoomY);\n}\n\n/**\n * Constrains the zoom level\n */\nfunction constrainZoom(zoom: number, minZoom: number, maxZoom: number) {\n  let newZoom = Math.max(minZoom, zoom);\n  newZoom = Math.min(maxZoom, newZoom);\n  return newZoom;\n}\n\n/**\n * Returns the font props for a node or link\n */\nfunction _getFontProps(styles?: DiagramLabelStyles) {\n  const fontProps: Font = {};\n  if (!styles) return fontProps;\n  if (styles.fontFamily) fontProps.fontFamily = styles.fontFamily;\n  if (styles.fontSize) fontProps.fontSize = styles.fontSize;\n  if (styles.fontStyle) fontProps.fontStyle = styles.fontStyle;\n  if (styles.fontWeight) fontProps.fontWeight = styles.fontWeight;\n  return fontProps;\n}\n\n/**\n * Returns the panX, panY, and zoom when zooming and centering an item\n */\nexport function zoomAndCenterItemFromInfo<K1, K2>(\n  info: ItemInfo<K1, K2>,\n  linkIdToDataMap: Map<K2, DiagramLink<K2, K1>>,\n  bounds: Bounds[],\n  nodeIdToIndex: Map<K1, number>,\n  width: number,\n  height: number,\n  maxZoom: number\n) {\n  const isNode = info.isNode;\n  let totalBounds;\n  if (isNode) {\n    const nodeIndex = nodeIdToIndex.get(info.id as K1)!;\n    totalBounds = bounds[nodeIndex];\n  } else {\n    const link = linkIdToDataMap.get(info.id as K2)!;\n    const startNodeBounds = bounds[nodeIdToIndex.get(link.startNode)!];\n    const endNodeBounds = bounds[nodeIdToIndex.get(link.endNode)!];\n    const minX = Math.min(startNodeBounds.x, endNodeBounds.x);\n    const minY = Math.min(startNodeBounds.y, endNodeBounds.y);\n    const maxX = Math.max(\n      startNodeBounds.x + startNodeBounds.w,\n      endNodeBounds.x + startNodeBounds.w\n    );\n    const maxY = Math.max(startNodeBounds.y + startNodeBounds.h, endNodeBounds.y + endNodeBounds.h);\n    totalBounds = { x: minX, y: minY, w: maxX - minX, h: maxY - minY };\n  }\n  return getPanZoomToCenterNode(totalBounds, maxZoom, width, height);\n}\n\n/**\n * Returns the pan and zoom values in order\n * to center a node or link\n */\nfunction getPanZoomToCenterNode(bounds: Bounds, maxZoom: number, width: number, height: number) {\n  const zoomX = (width - 2 * ZOOM_TO_FIT_PADDING) / bounds.w;\n  const zoomY = (height - 2 * ZOOM_TO_FIT_PADDING) / bounds.h;\n  const zoom = Math.min(zoomX, zoomY, maxZoom);\n  const cX = bounds.w / 2 + bounds.x;\n  const cY = bounds.h / 2 + bounds.y;\n  return { centerX: cX, centerY: cY, zoom: zoom };\n}\n","import type { Position, State, DiagramNode, NodeRendererContext } from './Diagram.types';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\nimport { useCallback, useRef } from 'preact/hooks';\nimport { getItemAriaLabel } from './utils/diagramUtils';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { itemStyles } from './themes/DiagramStyles.css';\nimport { ComponentChildren } from 'preact';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\n\n/**\n * Props for node component\n */\ntype NodeProps<K1> = {\n  id: K1;\n  position: Position;\n  label?: string;\n  state: State;\n  previousState: State;\n  isDimmed?: boolean;\n  activeId?: string;\n  accessibleLabel?: string;\n  nodeIndex: number;\n  data: DiagramNode<K1>;\n  nodeRenderer: (context: NodeRendererContext<K1>) => ComponentChildren;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  supportsSelection: boolean;\n};\n\nexport const DiagramNodeElement = <K1,>({\n  id,\n  state,\n  previousState,\n  position,\n  activeId,\n  nodeRenderer,\n  onNodeSizeChanged,\n  nodeIndex,\n  data,\n  accessibleLabel,\n  isDimmed,\n  supportsSelection\n}: NodeProps<K1>) => {\n  const { nodeStyles, dimmedItemStyle } = itemStyles;\n  const context = {\n    state: state,\n    previousState: previousState,\n    data: data\n  };\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const ref = useRef<HTMLDivElement>(null);\n  // TODO JET-62472 change to one resize observer function\n  const optionsRef = useRef({ box: 'border-box' as const });\n  useResizeObserver({\n    ref,\n    callback: useCallback(\n      (entry: ResizeObserverEntry) => {\n        const boxSize = entry.borderBoxSize;\n        const width = boxSize[0].inlineSize;\n        const height = boxSize[0].blockSize;\n        onNodeSizeChanged(width, height, nodeIndex);\n      },\n      [nodeIndex, onNodeSizeChanged]\n    ),\n    resizeObserverOptions: optionsRef.current\n  });\n  return (\n    <div\n      ref={ref}\n      key={id}\n      class={classNames([nodeStyles, isDimmed ? dimmedItemStyle : undefined])}\n      data-node={id}\n      role=\"img\"\n      aria-label={getItemAriaLabel(\n        translations,\n        supportsSelection,\n        state.selected,\n        accessibleLabel\n      )}\n      style={{\n        top: position.y,\n        left: position.x\n      }}\n      id={state.focused || state.hovered ? activeId : undefined}>\n      {nodeRenderer(context)}\n    </div>\n  );\n};\n","import { ComponentChildren } from 'preact';\nimport type { DiagramNode, States, NodeRendererContext, Bounds } from './Diagram.types';\nimport { DiagramNodeElement } from './DiagramNodeElement';\nimport { layerStyles } from './themes/DiagramStyles.css';\n\ntype Props<K1, K2> = {\n  nodes: DiagramNode<K1>[];\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  nodeRenderer: (context: NodeRendererContext<K1>) => ComponentChildren;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  nodeBounds?: Bounds[];\n  supportsSelection: boolean;\n};\n\nexport function DiagramNodeLayer<K1, K2>({\n  nodes,\n  states,\n  previousStates,\n  nodeRenderer,\n  nodeBounds,\n  onNodeSizeChanged,\n  supportsSelection\n}: Props<K1, K2>) {\n  return (\n    <div class={layerStyles}>\n      {nodes.map((node, i) => {\n        // this is for initial render before the layout function so render all nodes at 0,0\n        const position = nodeBounds && nodeBounds[i] ? { x:nodeBounds[i].x, y: nodeBounds[i].y } : { x: 0, y: 0 };\n        const state = {\n          selected: states.selectedNodeIds.includes(node.id),\n          focused: states.focusedId === node.id,\n          hovered: states.hoveredId === node.id,\n          zoom: states.zoom\n        };\n        const previousState = {\n          selected: previousStates.selectedNodeIds.includes(node.id),\n          focused: previousStates.focusedId === node.id,\n          hovered: previousStates.hoveredId === node.id,\n          zoom: previousStates.zoom\n        };\n        return (\n          <DiagramNodeElement\n            id={node.id}\n            position={position}\n            state={state}\n            previousState={previousState}\n            isDimmed={states.highlightedIds.length !== 0 && !states.highlightedIds.includes(node.id)}\n            activeId={states.activeId}\n            nodeRenderer={nodeRenderer}\n            onNodeSizeChanged={onNodeSizeChanged}\n            nodeIndex={i}\n            accessibleLabel={node.accessibleLabel}\n            data={node}\n            supportsSelection={supportsSelection}\n          />\n        );\n      })}\n    </div>\n  );\n}\n","import type { State, DiagramLink, LinkRendererContext } from './Diagram.types';\nimport { getItemAriaLabel } from './utils/diagramUtils';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { itemStyles } from './themes/DiagramStyles.css';\nimport { ComponentChildren } from 'preact';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\n\n/**\n * Props for Link\n */\nexport type LinkProps<K2, K1> = {\n  id: K2;\n  label?: string;\n  state: State;\n  previousState: State;\n  isDimmed?: boolean;\n  activeId?: string;\n  accessibleLabel?: string;\n  data: DiagramLink<K2, K1>;\n  linkRenderer: (context: LinkRendererContext<K2, K1>) => ComponentChildren;\n  supportsSelection: boolean;\n};\n\nexport const DiagramLinkElement = <K2, K1>({\n  id,\n  state,\n  previousState,\n  activeId,\n  data,\n  linkRenderer,\n  accessibleLabel,\n  isDimmed,\n  supportsSelection\n}: LinkProps<K2, K1>) => {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { dimmedItemStyle, linkStyles } = itemStyles;\n  const context = {\n    state: state,\n    previousState: previousState,\n    data: data\n  };\n  return (\n    <g\n      key={id}\n      id={state.focused ? activeId : undefined}\n      aria-label={getItemAriaLabel(\n        translations,\n        supportsSelection,\n        state.selected,\n        accessibleLabel\n      )}\n      data-link={id}\n      role=\"img\"\n      class={classNames([linkStyles, isDimmed && dimmedItemStyle])}>\n      {linkRenderer(context)}\n    </g>\n  );\n};\n","import { ComponentChildren } from 'preact';\nimport type { DiagramLink, States, LinkRendererContext } from './Diagram.types';\nimport { DiagramLinkElement } from './DiagramLinkElement';\nimport { layerStyles } from './themes/DiagramStyles.css';\n\ntype Props<K2, K1> = {\n  links: DiagramLink<K2, K1>[];\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  linkRenderer: (context: LinkRendererContext<K2, K1>) => ComponentChildren;\n  width: number;\n  height: number;\n  supportsSelection: boolean;\n};\n\nexport function DiagramLinkLayer<K2, K1>({\n  links,\n  states,\n  previousStates,\n  linkRenderer,\n  width,\n  height,\n  supportsSelection\n}: Props<K2, K1>) {\n  return (\n    <svg class={layerStyles} width={width} height={height}>\n      {links.map((link) => {\n        const state = {\n          selected: states.selectedLinkIds.includes(link.id),\n          focused: states.focusedId === link.id,\n          hovered: states.hoveredId === link.id,\n          zoom: states.zoom\n        };\n        const previousState = {\n          selected: previousStates.selectedLinkIds.includes(link.id),\n          focused: previousStates.focusedId === link.id,\n          hovered: previousStates.hoveredId === link.id,\n          zoom: previousStates.zoom\n        };\n        return (\n          <DiagramLinkElement\n            id={link.id}\n            label={link.label}\n            state={state}\n            previousState={previousState}\n            isDimmed={states.highlightedIds.length !== 0 && !states.highlightedIds.includes(link.id)}\n            activeId={states.activeId}\n            accessibleLabel={link.accessibleLabel}\n            data={link}\n            linkRenderer={linkRenderer}\n            supportsSelection={supportsSelection}\n          />\n        );\n      })}\n    </svg>\n  );\n}\n","import type { DiagramLabelPosition, DiagramLabelStyles } from './Diagram.types';\nimport { getLabelPosition } from './utils/diagramUtils';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { labelStyles } from './themes/DiagramStyles.css';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { Property } from 'csstype';\n\n/**\n * Props for the label component\n */\ntype LabelProps = {\n  styles?: LabelStyles;\n  text: string;\n  position: DiagramLabelPosition;\n  dimensions: TextDimensions;\n  isRTL: boolean;\n};\n\n/**\n * Label styles\n */\ntype LabelStyles = DiagramLabelStyles & {\n  borderStyle?: Property.BorderStyle;\n};\n\nexport const DiagramLabel = ({ text, position, styles, dimensions, isRTL }: LabelProps) => {\n  const { labelStyle, labelBorderStyle } = labelStyles;\n\n  const labelPosition = getLabelPosition(dimensions, position, isRTL);\n  const labelRotation = getLabelRotation(position);\n  return (\n    <div\n      class={classNames([labelStyle, styles && styles.borderColor && labelBorderStyle])}\n      style={{\n        top: labelPosition.y,\n        left: labelPosition.x,\n        ...styles,\n        ...labelRotation\n      }}>\n      {text}\n    </div>\n  );\n};\n\n/**\n * Returns the label rotation props\n * @param position\n * @returns rotation props\n */\nfunction getLabelRotation(position: DiagramLabelPosition) {\n  const rotationAngle = position.rotationAngle;\n  const rotationPoint = position.rotationPoint;\n  const rotation: {\n    transform?: string;\n    'transform-origin'?: string;\n  } = {};\n  if (rotationAngle) {\n    rotation['transform'] = `rotate(${rotationAngle}deg)`;\n  }\n  if (rotationPoint) {\n    rotation['transform-origin'] = `${rotationPoint.x}px ${rotationPoint.y}px`;\n  }\n  return rotation;\n}\n","import type { DiagramLabelPosition, DiagramNode, DiagramLink } from './Diagram.types';\nimport { DiagramLabel } from './DiagramLabel';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { layerStyles } from './themes/DiagramStyles.css';\nimport { useUser } from '../hooks/UNSAFE_useUser';\n\ntype Props<K1, K2> = {\n  labelPosition: (DiagramLabelPosition | undefined)[];\n  itemProps: (DiagramNode<K1> | DiagramLink<K2, K1>)[];\n  labelDimensions: Map<K1 | K2, TextDimensions>;\n};\n\nexport function DiagramLabelLayer<K1, K2>({\n  labelPosition,\n  itemProps,\n  labelDimensions\n}: Props<K1, K2>) {\n  const { direction } = useUser();\n  return (\n    <div class={layerStyles}>\n      {itemProps.map((item, i) => {\n        if (item.label && labelPosition[i]) {\n          return (\n            <DiagramLabel\n              styles={item.labelStyle}\n              text={item.label}\n              position={labelPosition[i]!}\n              dimensions={labelDimensions.get(item.id)!}\n              isRTL={direction === 'rtl'}\n            />\n          );\n        }\n        return undefined;\n      })}\n    </div>\n  );\n}\n","import type {\n  DiagramNode,\n  DiagramLink,\n  NodeRendererContext,\n  LinkRendererContext,\n  States,\n  Bounds,\n  DiagramLabelPosition\n} from './Diagram.types';\nimport { DiagramNodeLayer } from './DiagramNodeLayer';\nimport { DiagramLinkLayer } from './DiagramLinkLayer';\nimport { DiagramLabelLayer } from './DiagramLabelLayer';\nimport { ComponentChildren } from 'preact';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\n\n/**\n * Props for Diagram layers component\n */\ntype DiagramLayersProps<K1, K2> = {\n  nodes: DiagramNode<K1>[];\n  links: DiagramLink<K2, K1>[];\n  nodeRenderer: (context: NodeRendererContext<K1>) => ComponentChildren;\n  linkRenderer?: (context: LinkRendererContext<K2, K1>) => ComponentChildren;\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  nodeBounds: Bounds[];\n  // width height are for svg for links\n  width: number;\n  height: number;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  nodeLabelPositions?: (DiagramLabelPosition | undefined)[];\n  linkLabelPositions?: (DiagramLabelPosition | undefined)[];\n  labelDimensions?: Map<K1 | K2, TextDimensions>;\n  supportsSelection: boolean;\n};\n\nexport function DiagramLayers<K1 extends string | number, K2 extends string | number>({\n  nodes,\n  links,\n  nodeRenderer,\n  linkRenderer,\n  states,\n  previousStates,\n  nodeBounds,\n  onNodeSizeChanged,\n  width,\n  height,\n  nodeLabelPositions,\n  linkLabelPositions,\n  labelDimensions,\n  supportsSelection\n}: DiagramLayersProps<K1, K2>) {\n  return (\n    <>\n      {links.length > 0 && linkRenderer && width !== Infinity && (\n        <DiagramLinkLayer\n          links={links}\n          states={states}\n          previousStates={previousStates}\n          linkRenderer={linkRenderer}\n          width={width}\n          height={height}\n          supportsSelection={supportsSelection}\n        />\n      )}\n      <DiagramNodeLayer\n        nodes={nodes}\n        nodeBounds={nodeBounds}\n        states={states}\n        previousStates={previousStates}\n        nodeRenderer={nodeRenderer}\n        onNodeSizeChanged={onNodeSizeChanged}\n        supportsSelection={supportsSelection}\n      />\n      {labelDimensions ? (\n        <div>\n          {nodeLabelPositions ? (\n            <DiagramLabelLayer\n              labelPosition={nodeLabelPositions}\n              itemProps={nodes}\n              labelDimensions={labelDimensions}\n            />\n          ) : undefined}\n          {links && linkLabelPositions ? (\n            <DiagramLabelLayer\n              labelPosition={linkLabelPositions}\n              itemProps={links}\n              labelDimensions={labelDimensions}\n            />\n          ) : undefined}\n        </div>\n      ) : undefined}\n    </>\n  );\n}\n","import { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { centerXYToPanXY } from './utils/diagramUtils';\nimport { panZoomStyles } from './themes/DiagramStyles.css';\n\ntype IntrinsicProps = Pick<HTMLAttributesSignalExcluded<HTMLDivElement>, 'children'>;\n\ntype Props = IntrinsicProps & {\n  centerX: number;\n  centerY: number;\n  zoom: number;\n  width: number;\n  height: number;\n};\n\nexport function DiagramPanZoomContainer({\n  centerX,\n  centerY,\n  children,\n  zoom,\n  width,\n  height\n}: Props) {\n  const panValues = centerXYToPanXY(centerX, centerY, zoom, width, height);\n  return (\n    <div\n      class={panZoomStyles}\n      style={{\n        //TODO JET-62471 look at using matrices or both in transform instead\n        translate: `${panValues.panX}px ${panValues.panY}px`,\n        transform: `scale(${zoom})`\n      }}>\n      {children}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { DiagramNode, DiagramLink, Bounds, ItemInfo } from '../Diagram.types';\n\n/**\n * Navigation direction\n */\nexport type NavDirection = 'right' | 'left' | 'up' | 'down';\n\ntype linkDetailType<K2> = {\n  id: K2;\n  angle: number;\n  distance: number;\n  /**\n   * Ingoing = 1, outgoing = 0\n   */\n  direction: 0 | 1;\n};\n\n/**\n * Returns the node data based on node info in a diagram.\n * @param itemInfo\n * @returns\n */\nexport function getNodeDetailFromInfo<K1, K2>(\n  itemInfo: ItemInfo<K1, K2>,\n  nodes: DiagramNode<K1>[]\n): DiagramNode<K1> | undefined {\n  let node;\n  for (let i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (itemInfo.id === node.id) {\n      return node;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Returns the link data based on link info in a diagram.\n * @param itemInfo\n * @returns\n */\nexport function getLinkDetailFromInfo<K1, K2>(\n  itemInfo: ItemInfo<K1, K2>,\n  links: DiagramLink<K2, K1>[]\n): DiagramLink<K2, K1> | undefined {\n  let link;\n  for (let i = 0; i < links.length; i++) {\n    link = links[i];\n    if (itemInfo.id === link.id) {\n      return link;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Creates a map with key node id and value node bounds\n */\nexport function createNodeBoundsMap<K1>(nodes: DiagramNode<K1>[], bounds: Bounds[]) {\n  const nodeBounds: Map<K1, Bounds> = new Map();\n  for (let i = 0; i < nodes.length; i++) {\n    nodeBounds.set(nodes[i].id, bounds[i]);\n  }\n  return nodeBounds;\n}\n\n/**\n * Utility method that adds sorting attributes of each link to an array\n */\nexport function addSortingAttributes<K1, K2>(\n  node: DiagramNode<K1>,\n  listOfLinks: DiagramLink<K2, K1>[],\n  nodes: DiagramNode<K1>[],\n  nodeBounds: Map<K1, Bounds>\n) {\n  let angle, distance, direction;\n  const linkDetail: linkDetailType<K2>[] = [];\n  for (let i = 0; i < listOfLinks.length; i++) {\n    const link = listOfLinks[i];\n    angle = _getClockwiseAngle(node, link, nodes, nodeBounds);\n    distance = _getNodesDistance(link, nodes, nodeBounds);\n    direction = _getLinkDirection(node, link);\n    linkDetail.push({ id: link.id, angle: angle, distance: distance, direction: direction });\n  }\n  return linkDetail;\n}\n\n/**\n * Returns a function that compares two link around a given node\n * The links are analyzed by angle, distance from the node and direction. The sorting attributes are added to the links before sorting.\n */\nexport function getLinkComparator<K2>() {\n  return (link1: linkDetailType<K2>, link2: linkDetailType<K2>) => {\n    const { angle: linkAngle1, distance: linkDistance1, direction: linkDirection1 } = link1;\n    const { angle: linkAngle2, distance: linkDistance2, direction: linkDirection2 } = link2;\n    let res = -1;\n\n    if (!_anglesAreEqualWithinTolerance(linkAngle1, linkAngle2) && linkAngle1 > linkAngle2) {\n      res = 1;\n    } else if (_anglesAreEqualWithinTolerance(linkAngle1, linkAngle2)) {\n      //check distance and direction\n      if (linkDistance1 > linkDistance2) {\n        res = 1;\n      } else if (linkDistance2 == linkDistance1 && linkDirection1 > linkDirection2) {\n        //outgoing to ingoing\n        res = 1;\n      } else if (linkDistance2 == linkDistance1 && linkDirection1 == linkDirection2) {\n        res = 0;\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Returns navigable links for a given node\n */\nexport function getNavigableLinksForNodeId<K1, K2>(nodeId: K1, listOfLinks: DiagramLink<K2, K1>[]) {\n  const links: DiagramLink<K2, K1>[] = [];\n  listOfLinks.forEach((link) => {\n    const startId = link.startNode;\n    const endId = link.endNode;\n\n    if (startId == nodeId || endId == nodeId) links.push(link);\n  });\n  return links;\n}\n\n/**\n * Get the clockwise angle for the link given node as a center\n */\nfunction _getClockwiseAngle<K1, K2>(\n  node: DiagramNode<K1>,\n  link: DiagramLink<K2, K1>,\n  nodes: DiagramNode<K1>[],\n  nodeBounds: Map<K1, Bounds>\n) {\n  //find opposite node\n  let currNode;\n  let startNode = nodes[0];\n  let endNode = nodes[0];\n  for (let i = 0; i < nodes.length; i++) {\n    currNode = nodes[i];\n    if (currNode.id === link.startNode) {\n      startNode = currNode;\n    } else if (currNode.id === link.endNode) {\n      endNode = currNode;\n    }\n  }\n  const oppositeNode = node.id == startNode.id ? endNode : startNode;\n\n  const p1 = _getNodeCenter(node, nodeBounds);\n  const p2 = _getNodeCenter(oppositeNode, nodeBounds);\n  let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n  angle = angle < 0 ? angle + Math.PI * 2 : angle;\n  return angle;\n}\n\n/**\n * Get the distance between start and end nodes for the given link\n */\nfunction _getNodesDistance<K1, K2>(\n  link: DiagramLink<K2, K1>,\n  nodes: DiagramNode<K1>[],\n  nodeBounds: Map<K1, Bounds>\n) {\n  let currNode;\n  let startNode = nodes[0];\n  let endNode = nodes[0];\n  for (let i = 0; i < nodes.length; i++) {\n    currNode = nodes[i];\n    if (currNode.id === link.startNode) {\n      startNode = currNode;\n    } else if (currNode.id === link.endNode) {\n      endNode = currNode;\n    }\n  }\n  const p1 = _getNodeCenter(startNode, nodeBounds);\n  const p2 = _getNodeCenter(endNode, nodeBounds);\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\n\n/**\n * Get link direction for the given node.  1 if the node is the end node\n * and 0 if it is the start node\n */\nfunction _getLinkDirection<K1, K2>(node: DiagramNode<K1>, link: DiagramLink<K2, K1>): 0 | 1 {\n  if (link.endNode === node.id) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * Get node center\n */\nfunction _getNodeCenter<K1>(node: DiagramNode<K1>, nodeBounds: Map<K1, Bounds>) {\n  const nodeBB = nodeBounds.get(node.id)!;\n  return { x: nodeBB.x + nodeBB.w / 2, y: nodeBB.y + nodeBB.h / 2 };\n}\n\n/**\n * Calculates the angle weighted by distance\n */\nexport function calcDistanceAngleWeighted(\n  objectBB: Bounds,\n  currentBB: Bounds,\n  direction: NavDirection\n) {\n  // Variables used for calculating penalties when calculating distances between two DvtKeyboardNavigables\n  const optimalAngle1 = (15 / 180) * Math.PI;\n  const optimalAngle2 = (40 / 180) * Math.PI;\n  const suboptimalAnglePenalty1 = 2; // multiplier to the distance\n  const suboptimalAnglePenalty2 = 6; // multiplier to the distance\n\n  const objCenterX = objectBB.x + objectBB.w / 2;\n  const objCenterY = objectBB.y + objectBB.h / 2;\n\n  const curCenterX = currentBB.x + currentBB.w / 2;\n  const curCenterY = currentBB.y + currentBB.h / 2;\n\n  const x_dist = Math.abs(objCenterX - curCenterX);\n  const y_dist = Math.abs(objCenterY - curCenterY);\n\n  const angle = Math.atan2(y_dist, x_dist);\n\n  let distance = Math.sqrt(x_dist * x_dist + y_dist * y_dist);\n\n  // Angle penalty based on direction\n  if (\n    (angle > optimalAngle1 && (direction == 'right' || direction == 'left')) ||\n    (angle < Math.PI / 2 - optimalAngle1 && (direction == 'up' || direction == 'down'))\n  ) {\n    if (\n      (angle > optimalAngle2 && (direction == 'right' || direction == 'left')) ||\n      (angle < Math.PI / 2 - optimalAngle2 && (direction == 'up' || direction == 'down'))\n    ) {\n      distance *= suboptimalAnglePenalty2;\n    } else {\n      distance *= suboptimalAnglePenalty1;\n    }\n  }\n\n  return distance;\n}\n\n/**\n * Given a direction, is a certain node is a valid destination to navigate to\n */\nexport function isValidDestination(\n  objBB: Bounds,\n  curBB: Bounds,\n  direction: NavDirection,\n  compareCenters: boolean\n) {\n  // compare the centers of the navigable and to be valid, the navigable must be in the right direction\n  // without tolerance\n  if (compareCenters) {\n    const objCenterX = objBB.x + 0.5 * objBB.w;\n    const curCenterX = curBB.x + 0.5 * curBB.w;\n    const objCenterY = objBB.y + 0.5 * objBB.h;\n    const curCenterY = curBB.y + 0.5 * curBB.h;\n\n    switch (direction) {\n      case 'up':\n        return objCenterY < curCenterY;\n      case 'down':\n        return objBB.y > curCenterY;\n      case 'right':\n        return objCenterX > curCenterX;\n      case 'left':\n        return objCenterX < curCenterX;\n      default:\n        break;\n    }\n    return true;\n  }\n\n  switch (direction) {\n    case 'up':\n      return objBB.y < curBB.y || _areEqualWithinTolerance(objBB.y, curBB.y);\n    case 'down':\n      return objBB.y > curBB.y || _areEqualWithinTolerance(objBB.y, curBB.y);\n    case 'right':\n      return objBB.x > curBB.x || _areEqualWithinTolerance(objBB.x, curBB.x);\n    case 'left':\n      return objBB.x < curBB.x || _areEqualWithinTolerance(objBB.x, curBB.x);\n    default:\n      break;\n  }\n  return true;\n}\n\n/**\n * Returns true if two nodes are in contact\n */\nexport function calcInContact(objRect: Bounds, curRect: Bounds, direction: NavDirection) {\n  switch (direction) {\n    case 'up':\n      return (\n        _isVerticallyAligned(objRect, curRect) &&\n        (curRect.y <= objRect.y + objRect.h ||\n          _areEqualWithinTolerance(curRect.y, objRect.y + objRect.h))\n      );\n    case 'down':\n      return (\n        _isVerticallyAligned(objRect, curRect) &&\n        (objRect.y <= curRect.y + curRect.h ||\n          _areEqualWithinTolerance(objRect.y, curRect.y + curRect.h))\n      );\n    case 'right':\n      return (\n        _isHorizontallyAligned(objRect, curRect) &&\n        (objRect.x <= curRect.x + curRect.w ||\n          _areEqualWithinTolerance(objRect.x, curRect.x + curRect.w))\n      );\n    case 'left':\n      return (\n        _isHorizontallyAligned(objRect, curRect) &&\n        (curRect.x <= objRect.x + objRect.w ||\n          _areEqualWithinTolerance(curRect.x, objRect.x + objRect.w))\n      );\n    default:\n      break;\n  }\n\n  return false;\n}\n\nfunction _isVerticallyAligned(rect1: Bounds, rect2: Bounds) {\n  return (\n    (rect1.x >= rect2.x && rect1.x <= rect2.x + rect2.w) ||\n    (rect2.x >= rect1.x && rect2.x <= rect1.x + rect1.w)\n  );\n}\n\nfunction _isHorizontallyAligned(rect1: Bounds, rect2: Bounds) {\n  return (\n    (rect1.y >= rect2.y && rect1.y <= rect2.y + rect2.h) ||\n    (rect2.y >= rect1.y && rect2.y <= rect1.y + rect1.h)\n  );\n}\n\nfunction _areEqualWithinTolerance(a: number, b: number) {\n  return Math.abs(a - b) <= 0.0000001;\n}\n\nfunction _anglesAreEqualWithinTolerance(a1: number, a2: number) {\n  let res = Math.abs(a1 - a2) <= 0.0000001;\n  if (!res) {\n    res = Math.abs(Math.PI * 2 + Math.min(a1, a2) - Math.max(a1, a2)) <= 0.0000001;\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  NavDirection,\n  addSortingAttributes,\n  calcDistanceAngleWeighted,\n  calcInContact,\n  createNodeBoundsMap,\n  getLinkComparator,\n  getNavigableLinksForNodeId,\n  getNodeDetailFromInfo,\n  isValidDestination\n} from '../utils/navUtils';\nimport type { DiagramNode, DiagramLink, Bounds, ItemInfo } from '../Diagram.types';\nimport { useRef } from 'preact/hooks';\n\nexport function useDiagramNavigation<K1, K2>(\n  nodes: DiagramNode<K1>[],\n  links: DiagramLink<K2, K1>[],\n  bounds: Bounds[],\n  linkIdToDataMap: Map<K2, DiagramLink<K2, K1>>\n) {\n  const currentKeyboardFocusNode = useRef<K1>();\n  const nodeBoundsById = createNodeBoundsMap(nodes, bounds);\n\n  function getNextNavigableNode(\n    direction: NavDirection,\n    compareCenters: boolean,\n    current?: DiagramNode<K1>,\n    listOfObjects?: DiagramNode<K1>[]\n  ) {\n    if (!listOfObjects) return current;\n\n    if (!current) return listOfObjects[0];\n    const currBB = nodeBoundsById.get(current.id);\n    if (!currBB) return listOfObjects[0];\n\n    let nextObject = current; //init to current object\n    let nextDistance = Number.MAX_VALUE;\n\n    // If an object is in contact it overrules all other attributes\n    // Only another in contact object with better attributes will have higher precedence\n    let nextInContact = false;\n\n    // Whether or not the for loop has encountered the current object\n    let hasFoundCurrent = false;\n\n    let object, inContact, distance;\n    for (let i = 0; i < listOfObjects.length; i++) {\n      object = listOfObjects[i];\n\n      if (object === current) {\n        hasFoundCurrent = true;\n        continue;\n      }\n      const objBB = nodeBoundsById.get(object.id);\n      if (!objBB) continue;\n\n      const objBounds = { x: objBB.x, y: objBB.y, w: objBB.w, h: objBB.h };\n      const currBounds = { x: currBB.x, y: currBB.y, w: currBB.w, h: currBB.h };\n      if (!isValidDestination(objBounds, currBounds, direction, compareCenters)) continue;\n\n      inContact = calcInContact(objBounds, currBounds, direction);\n\n      if (nextInContact && !inContact) continue;\n\n      distance = calcDistanceAngleWeighted(objBounds, currBounds, direction);\n\n      if (distance == 0 && !hasFoundCurrent) continue;\n\n      // Make sure incontact flag have highest precedence\n      if (\n        (!nextInContact && inContact) ||\n        (distance < nextDistance && ((nextInContact && inContact) || !nextInContact))\n      ) {\n        nextDistance = distance;\n        nextObject = object;\n        nextInContact = inContact;\n      }\n    }\n    return nextObject;\n  }\n\n  /**\n   * Get next navigavle link depending on direction - clockwise or conter clockwise.\n   * The decision is made based on location of nodes centers rather than link paths or link angles.\n   */\n  function getNextNavigableLink(\n    direction: string,\n    listOfNodes: DiagramNode<K1>[],\n    currentLink?: DiagramLink<K2, K1>,\n    listOfLinks?: DiagramLink<K2, K1>[]\n  ) {\n    if (!listOfLinks) return currentLink;\n\n    if (!currentLink) return listOfLinks[0];\n    const keyboardFocusNode = currentKeyboardFocusNode.current;\n    const nodeId = keyboardFocusNode ? keyboardFocusNode : currentLink.startNode;\n    const node = getNodeDetailFromInfo({ id: nodeId, isNode: true }, listOfNodes);\n\n    if (!node) return currentLink;\n    const adjLinks = getNavigableLinksForNodeId(node.id, listOfLinks);\n    listOfLinks = adjLinks;\n    const linksWithSortingAttributes = addSortingAttributes(\n      node,\n      listOfLinks,\n      listOfNodes,\n      nodeBoundsById\n    );\n    linksWithSortingAttributes.sort(getLinkComparator<K2>());\n    //clockwise direction\n    const bForward = direction == 'down' ? true : false;\n    let index = 0;\n    for (let i = 0; i < linksWithSortingAttributes.length; i++) {\n      const link = linksWithSortingAttributes[i];\n      if (link.id === currentLink.id) {\n        if (bForward) index = i == linksWithSortingAttributes.length - 1 ? 0 : i + 1;\n        else index = i == 0 ? linksWithSortingAttributes.length - 1 : i - 1;\n        break;\n      }\n    }\n    return linksWithSortingAttributes[index];\n  }\n\n  /**\n   * Returns the link detail when a node to link navigation occurs\n   */\n  function navigateFromNodeToLink(\n    listOfLinks: DiagramLink<K2, K1>[],\n    event: KeyboardEvent,\n    node?: DiagramNode<K1>\n  ) {\n    if (!node) return undefined;\n    const adjLinks = getNavigableLinksForNodeId(node.id, listOfLinks);\n    if (adjLinks.length < 1) return undefined;\n    let link = adjLinks[0];\n    const nodeBB = nodeBoundsById.get(node.id)!;\n    let object, currNode, currNodeBB, currNodeBBCenterX;\n    const nodeCenterX = nodeBB.x + nodeBB.w / 2;\n    currentKeyboardFocusNode.current = node.id;\n    for (let i = 0; i < adjLinks.length; i++) {\n      object = adjLinks[i];\n      currNode = object.startNode === node.id ? object.endNode : object.startNode;\n      currNodeBB = nodeBoundsById.get(currNode);\n      currNodeBBCenterX = currNodeBB!.x + currNodeBB!.w / 2;\n      if (\n        // equivalent of ≤ and ≥\n        (event.altKey && event.code === 'Comma' && currNodeBBCenterX <= nodeCenterX) ||\n        (event.altKey && event.code === 'Period' && currNodeBBCenterX >= nodeCenterX)\n      ) {\n        link = object;\n        break;\n      }\n    }\n    return { id: link.id, isNode: false };\n  }\n\n  /**\n   * Returns the node detail when a link to node navigation occurs\n   */\n  function navigateFromLinkToNode(linkId: K2, event: KeyboardEvent) {\n    const key = event.key;\n    const linkData = linkIdToDataMap.get(linkId)!;\n    const startNodeBB = nodeBoundsById.get(linkData.startNode);\n    const endNodeBB = nodeBoundsById.get(linkData.endNode);\n    if (!startNodeBB || !endNodeBB) return undefined;\n    const startNodeCenterX = startNodeBB.x + startNodeBB.w / 2;\n    const endNodeCenterX = endNodeBB.x + endNodeBB.w / 2;\n    const newNode =\n      (endNodeCenterX > startNodeCenterX && key === 'ArrowRight') ||\n      (endNodeCenterX < startNodeCenterX && key === 'ArrowLeft')\n        ? linkData.endNode\n        : linkData.startNode;\n    return { id: newNode, isNode: true };\n  }\n\n  return {\n    isNode: (itemInfo: ItemInfo<K1, K2>): boolean => {\n      let node, link;\n      for (let i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        link = links[i];\n        if (itemInfo.id === node.id) {\n          return true;\n        }\n        if (itemInfo.id === link.id) {\n          return true;\n        }\n      }\n      return false;\n    },\n    getNextNavigableNode,\n    getNextNavigableLink,\n    navigateFromNodeToLink,\n    navigateFromLinkToNode\n  };\n}\n","import { DiagramNode, DiagramLink, ItemInfo, ItemInputDetail, Bounds } from '../Diagram.types';\nimport { useRef, useState } from 'preact/hooks';\nimport { isEqualItem, getNavigableInfo, zoomAndCenterItemFromInfo } from '../utils/diagramUtils';\nimport { getRandomId } from '../../utils/PRIVATE_visLayoutUtils/LayoutUtils';\nimport { getNodeDetailFromInfo, getLinkDetailFromInfo } from '../utils/navUtils';\nimport { useDiagramNavigation } from './useDiagramNavigation';\nimport type { NavDirection } from '../utils/navUtils';\n\nconst DEFAULT_KB_PAN = 15;\nconst DEFAULT_KB_ZOOM = 0.15;\n\nexport function useEvents<K1, K2>(\n  initNode: DiagramNode<K1>,\n  nodes: DiagramNode<K1>[],\n  links: DiagramLink<K2, K1>[],\n  nodeBounds: Bounds[],\n  linkIdToDataMap: Map<K2, DiagramLink<K2, K1>>,\n  nodeIdToIndexMap: Map<K1, number>,\n  width: number,\n  height: number,\n  maxZoom: number,\n  onInput?: (detail: ItemInputDetail<K1, K2>) => void,\n  kbPanCallback?: (props: {\n    dPan?: { dx: number; dy: number };\n    nPan?: { cx: number; cy: number };\n    center?: boolean;\n  }) => void,\n  kbZoomCallback?: (props: { dZoom?: number; nZoom?: number }) => void\n) {\n  const {\n    getNextNavigableNode,\n    getNextNavigableLink,\n    navigateFromNodeToLink,\n    navigateFromLinkToNode\n  } = useDiagramNavigation(nodes, links, nodeBounds, linkIdToDataMap);\n  const [focusedItemInfo, setfocusedItemInfo] = useState<ItemInfo<K1, K2>>({\n    id: initNode.id,\n    isNode: true\n  });\n  const [hoveredItemInfo, sethoveredItemInfo] = useState<ItemInfo<K1, K2>>();\n  const activeId = useRef<string>();\n\n  const cancelEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const keyDownHandler = (event: KeyboardEvent) => {\n    const key = event.key;\n    let eventConsumed = false;\n    // tabbing out of the diagram\n    if (key === 'TAB') {\n      return;\n    }\n    // if this a switch from node to link or vice versa\n    if (isChangeItemType(event)) {\n      const nextItemInfo = focusedItemInfo.isNode\n        ? navigateFromNodeToLink(links, event, getNodeDetailFromInfo(focusedItemInfo, nodes))\n        : navigateFromLinkToNode(focusedItemInfo.id as K2, event);\n      handleKeyboardInput(nextItemInfo);\n      eventConsumed = true;\n    } else if (isNavigationEvent(key)) {\n      const nextItemInfo = handleKeyboardNavigationEvent(key);\n      handleKeyboardInput(nextItemInfo);\n      eventConsumed = true;\n    } else {\n      switch (key) {\n        case 'PageUp': {\n          kbPanCallback &&\n            kbPanCallback({\n              dPan: {\n                dx: event.shiftKey ? -DEFAULT_KB_PAN : 0,\n                dy: event.shiftKey ? 0 : -DEFAULT_KB_PAN\n              }\n            });\n          eventConsumed = true;\n          break;\n        }\n        case 'PageDown': {\n          kbPanCallback &&\n            kbPanCallback({\n              dPan: {\n                dx: event.shiftKey ? DEFAULT_KB_PAN : 0,\n                dy: event.shiftKey ? 0 : DEFAULT_KB_PAN\n              }\n            });\n          eventConsumed = true;\n          eventConsumed = true;\n          break;\n        }\n        case '+':\n        case '=': {\n          kbZoomCallback && kbZoomCallback({ dZoom: DEFAULT_KB_ZOOM });\n          eventConsumed = true;\n          break;\n        }\n        case '-':\n        case '_': {\n          kbZoomCallback && kbZoomCallback({ dZoom: -DEFAULT_KB_ZOOM });\n          eventConsumed = true;\n          break;\n        }\n        case '0': {\n          if (event.ctrlKey && event.altKey) {\n            const { centerX, centerY, zoom } = zoomAndCenterItemFromInfo(\n              focusedItemInfo,\n              linkIdToDataMap,\n              nodeBounds,\n              nodeIdToIndexMap,\n              width,\n              height,\n              maxZoom\n            );\n            kbZoomCallback && kbZoomCallback({ nZoom: zoom });\n            kbPanCallback && kbPanCallback({ nPan: { cx: centerX, cy: centerY } });\n          } else {\n            // zoom to fit\n            kbZoomCallback && kbZoomCallback({});\n            kbPanCallback && kbPanCallback({ center: true });\n          }\n          eventConsumed = true;\n        }\n      }\n    }\n    if (eventConsumed) {\n      cancelEvent(event);\n    }\n  };\n\n  const keyUpHandler = (event: KeyboardEvent) => {\n    const key = event.code;\n    switch (key) {\n      case 'Tab': {\n        updatefocusedItemInfo({\n          ...focusedItemInfo,\n          isCurrent: true,\n          isFocusVisible: true\n        });\n        break;\n      }\n    }\n  };\n\n  const blurHandler = () => {\n    if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {\n      onInput?.({ id: undefined });\n    }\n    const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };\n    setfocusedItemInfo(itemInfo);\n  };\n\n  const hoverHandler = (event: PointerEvent) => {\n    const itemInfo = getNavigableInfo<K1, K2>(event.target as HTMLElement);\n    if (itemInfo && !isEqualItem(itemInfo, hoveredItemInfo)) {\n      sethoveredItemInfo({ ...itemInfo, isCurrent: true });\n      activeId.current = getRandomId();\n      setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false });\n      onInput?.({ id: itemInfo.id, type: itemInfo.isNode ? 'node' : 'link' });\n    }\n  };\n\n  const pointerLeaveHandler = () => {\n    sethoveredItemInfo(undefined);\n    activeId.current = undefined;\n    onInput?.({ id: undefined });\n  };\n\n  const pointerUpHandler = (event: PointerEvent) => {\n    const itemInfo = getNavigableInfo<K1, K2>(event.target as HTMLElement);\n    if (itemInfo.id != null) {\n      setfocusedItemInfo(itemInfo);\n      activeId.current = getRandomId();\n    }\n  };\n\n  function updatefocusedItemInfo(itemInfo: ItemInfo<K1, K2>) {\n    onInput?.({ id: itemInfo.id, type: itemInfo.isNode ? 'node' : 'link' });\n    activeId.current = getRandomId();\n    setfocusedItemInfo(itemInfo);\n  }\n\n  function handleKeyboardInput(item?: ItemInfo<K1, K2>) {\n    if (!item) return;\n    if (!isEqualItem(item, focusedItemInfo)) {\n      item.isCurrent = true;\n      item.isFocusVisible = true;\n      if (hoveredItemInfo) {\n        sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });\n      }\n      updatefocusedItemInfo(item);\n    }\n  }\n\n  function isNavigationEvent(key: string) {\n    switch (key) {\n      case 'ArrowDown':\n      case 'ArrowUp':\n      case 'ArrowRight':\n      case 'ArrowLeft': {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function isChangeItemType(event: KeyboardEvent) {\n    const key = event.code;\n    // check if switching from node to link\n    // equivalent of ≤ and ≥\n    if (focusedItemInfo.isNode && event.altKey && (key === 'Period' || key === 'Comma')) {\n      return true;\n      // check if switching from link to node\n    } else if (!focusedItemInfo.isNode && (key === 'ArrowLeft' || key === 'ArrowRight')) {\n      return true;\n    }\n    return false;\n  }\n\n  function handleKeyboardNavigationEvent(key: string) {\n    let direction: NavDirection = 'down';\n    switch (key) {\n      case 'ArrowDown': {\n        direction = 'down';\n        break;\n      }\n      case 'ArrowUp': {\n        direction = 'up';\n        break;\n      }\n      case 'ArrowRight': {\n        direction = 'right';\n        break;\n      }\n      case 'ArrowLeft': {\n        direction = 'left';\n        break;\n      }\n    }\n    if (focusedItemInfo.isNode) {\n      const itemDetail = getNextNavigableNode(\n        direction,\n        true,\n        getNodeDetailFromInfo(focusedItemInfo, nodes),\n        nodes\n      );\n      return itemDetail ? { id: itemDetail.id, isNode: true } : focusedItemInfo;\n    } else {\n      const linkDetail = getLinkDetailFromInfo(focusedItemInfo, links);\n      const itemDetail = getNextNavigableLink(direction, nodes, linkDetail, links);\n      return itemDetail ? { id: itemDetail.id } : { id: focusedItemInfo.id };\n    }\n  }\n\n  return {\n    focusedItemInfo,\n    hoveredItemInfo,\n    'aria-activedescendant': activeId.current,\n    onKeyUp: keyUpHandler,\n    onKeyDown: keyDownHandler,\n    onBlur: blurHandler,\n    onPointerUp: pointerUpHandler,\n    onPointerMove: hoverHandler,\n    onPointerLeave: pointerLeaveHandler\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { ItemInfo, Bounds } from '../Diagram.types';\nimport type { Ref } from 'preact/hooks';\nimport { calculateOffset, useDatatip } from '../../hooks/PRIVATE_useDatatip';\nimport type { Pan } from '../utils/panUtils';\nimport { useUser } from '../../hooks/UNSAFE_useUser';\n\ntype props<K1, K2> = {\n  text?: string;\n  focusedItemInfo: ItemInfo<K1, K2>;\n  focusedItemBoundsRef: Ref<Bounds | null>;\n  panState: Pan;\n  zoom: number;\n  width: number;\n};\n\n/**\n * Returns the datatip.\n * @param text The text string for the diagram item.\n * @param rootRef The ref for root of the diagram.\n * @param focusedItemBoundsRef The ref for focused item bounds.\n * @param focusedItemInfo The ItemInfo for focused item.\n * @returns\n */\nexport const useDiagramDatatip = <K1, K2>({\n  text,\n  focusedItemBoundsRef,\n  focusedItemInfo,\n  panState,\n  zoom,\n  width\n}: props<K1, K2>) => {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const elementBounds = focusedItemInfo?.isCurrent\n    ? {\n        x: focusedItemBoundsRef.current!.x * zoom + panState.panX,\n        y: focusedItemBoundsRef.current!.y * zoom + panState.panY,\n        width: focusedItemBoundsRef.current!.w * zoom,\n        height: focusedItemBoundsRef.current!.h * zoom\n      }\n    : undefined;\n\n  const { datatipContent, datatipProps } = useDatatip({\n    content: text,\n    placement: 'top-start',\n    offset: calculateOffset(isRtl, width, elementBounds),\n    anchor: focusedItemInfo?.isCurrent ? 'element' : 'pointer'\n  });\n  return { datatipContent: datatipContent, datatipProps: datatipProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref, useRef } from 'preact/hooks';\n\ntype PointerGesture = {\n  pointers: PointerEvent[];\n};\n\ntype UsePointerGestureOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  numPointers: number;\n  onPointerGestureDown?: (detail: PointerGesture) => void;\n  onPointerGestureMove?: (detail: PointerGesture) => void;\n  onPointerGestureEnd?: (detail: PointerGesture) => void;\n  onExtraneousPointerDown?: (detail: PointerGesture) => void;\n  isDisabled?: boolean;\n};\n\nconst usePointerGesture = ({\n  captureTargetRef,\n  numPointers = 1,\n  onPointerGestureDown,\n  onPointerGestureMove,\n  onPointerGestureEnd,\n  onExtraneousPointerDown,\n  isDisabled = false\n}: UsePointerGestureOptions) => {\n  const activePointers = useRef<PointerEvent[]>([]);\n\n  if (isDisabled) {\n    activePointers.current = [];\n  }\n\n  const onPointerDown = (e: PointerEvent) => {\n    activePointers.current.push(e);\n    if (activePointers.current.length === numPointers) {\n      onPointerGestureDown && onPointerGestureDown({ pointers: activePointers.current });\n    } else if (activePointers.current.length > numPointers) {\n      onExtraneousPointerDown && onExtraneousPointerDown({ pointers: activePointers.current });\n    }\n  };\n\n  const onPointerMove = (e: PointerEvent) => {\n    if (activePointers.current.length === 0) return;\n\n    const index = activePointers.current.findIndex(\n      (pointerEvent) => pointerEvent.pointerId === e.pointerId\n    );\n    if (index === -1) return;\n\n    activePointers.current[index] = e;\n    if (activePointers.current.length === numPointers) {\n      activePointers.current.forEach((e) =>\n        captureTargetRef.current!.setPointerCapture(e.pointerId)\n      );\n\n      onPointerGestureMove && onPointerGestureMove({ pointers: activePointers.current });\n    }\n  };\n\n  const onPointerUp = (e: PointerEvent) => {\n    const index = activePointers.current.findIndex(\n      (pointerEvent) => pointerEvent.pointerId === e.pointerId\n    );\n    if (index === -1) return;\n\n    activePointers.current[index] = e;\n    if (activePointers.current.length === numPointers) {\n      onPointerGestureEnd && onPointerGestureEnd({ pointers: activePointers.current });\n    }\n    activePointers.current.splice(index, 1);\n  };\n\n  const onPointerCancel = onPointerUp;\n  const onPointerLeave = onPointerUp;\n\n  return isDisabled\n    ? {}\n    : {\n        onPointerDown,\n        onPointerMove,\n        onPointerUp,\n        onPointerCancel,\n        onPointerLeave\n      };\n};\n\nexport { usePointerGesture };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Bounds, PanState } from '../Diagram.types';\nimport { panXYToCenterXY } from './diagramUtils';\nexport type PanBounds = {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n};\n\n/**\n * The pan values that describes where the diagram content\n * is panned\n */\nexport type Pan = {\n  panX: number;\n  panY: number;\n};\n\nconst constrainPan = (\n  previousPan: Pan,\n  nextPan: Pan,\n  panBounds: PanBounds,\n  panDirection: 'x' | 'y' | 'any'\n) => {\n  const panX = panDirection !== 'y' ? nextPan.panX : previousPan.panX;\n  const panY = panDirection !== 'x' ? nextPan.panY : previousPan.panY;\n  return {\n    panX: panX > panBounds.maxX || panX < panBounds.minX ? previousPan.panX : panX,\n    panY: panY > panBounds.maxY || panY < panBounds.minY ? previousPan.panY : panY\n  };\n};\n\nexport const pan = (\n  previousPan: Pan,\n  nextPan: Pan,\n  panDirection: 'x' | 'y' | 'any',\n  zoom: number,\n  width: number,\n  height: number,\n  panBounds?: PanBounds,\n  onPanChange?: (detail: PanState) => void\n) => {\n  if (!panBounds) {\n    //On initial render before nodes are rendered\n    return { newPan: { panX: 0, panY: 0 } };\n  }\n  const newPan = constrainPan(previousPan, nextPan, panBounds, panDirection);\n  const isPanChanged = newPan.panX !== previousPan.panX || newPan.panY !== previousPan.panY;\n  const center = panXYToCenterXY(newPan.panX, newPan.panY, zoom, width, height);\n  isPanChanged &&\n    onPanChange &&\n    onPanChange({\n      centerX: center.centerX,\n      centerY: center.centerY\n    });\n  return { newPan };\n};\n\nexport const getPanBounds = (\n  width: number,\n  height: number,\n  elemBounds: Bounds,\n  panType: string,\n  zoom: number,\n  minZoom: number,\n  initPanZoomState: {\n    zoom: number;\n    centerX?: number;\n    centerY?: number;\n  }\n): PanBounds => {\n  const { x, y, w, h } = elemBounds;\n  let minX, maxX, minY, maxY;\n  if (panType === 'centerContent') {\n    minX = width / 2 - (w + x) * zoom;\n    minY = height / 2 - (h + y) * zoom;\n    maxX = width / 2 - x * zoom;\n    maxY = height / 2 - y * zoom;\n  } else {\n    // panType equals fixed\n    const zoomRatio = zoom / minZoom;\n    // Find left corner of the content at min zoom and content is centered\n    const minZoomX = (width - w * minZoom) / 2 - x * minZoom;\n    const minZoomY = (height - h * minZoom) / 2 - y * minZoom;\n    // When we pan all the way to the right, the left corner of displayable area is 0,0 as in min zoom.\n    // When we pan all the way to the left, lets find the corner of the displayable area\n    const leftCornerX = width - width * zoomRatio;\n    const leftCornerY = height - height * zoomRatio;\n    // Now we have everything to calculate pan zoom constraints\n    minX = leftCornerX + minZoomX * zoomRatio;\n    minY = leftCornerY + minZoomY * zoomRatio;\n    maxX = minZoomX * zoomRatio;\n    maxY = minZoomY * zoomRatio;\n  }\n  const initZoom = initPanZoomState.zoom;\n  const initCenterX = initPanZoomState.centerX;\n  const initCenterY = initPanZoomState.centerY;\n  // If an initial panZoomState is set, should expand pan bounds to include it\n  let dx, dy;\n  if (initCenterX) {\n    const boundsX = initCenterX * initZoom - width / 2;\n    if (-boundsX * initZoom < minX) {\n      dx = minX - boundsX * initZoom;\n      minX -= dx;\n      maxX += dx;\n    } else if (-boundsX * initZoom > maxX) {\n      dx = -boundsX * initZoom - maxX;\n      minX -= dx;\n      maxX += dx;\n    }\n  }\n  if (initCenterY) {\n    const boundsY = initCenterY * initZoom - height / 2;\n    if (-boundsY * initZoom < minY) {\n      dy = minY - boundsY * initZoom;\n      minY -= dy;\n      maxY += dy;\n    } else if (-boundsY * initZoom > maxY) {\n      dy = -boundsY * initZoom - maxY;\n      minY -= dy;\n      maxY += dy;\n    }\n  }\n  return {\n    minX: minX,\n    maxX: maxX,\n    minY: minY,\n    maxY: maxY\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { PanState } from '../Diagram.types';\n\nimport { Ref, useRef } from 'preact/hooks';\nimport { useDrag } from './useDrag';\nimport { PanBounds, pan } from '../utils/panUtils';\nimport { centerXYToPanXY } from '../utils/diagramUtils';\n/**\n * Options for useDragPan hook\n */\ntype UseDragPanOptions = {\n  panProps: {\n    panning: 'centerContent' | 'fixed' | 'off';\n    centerX: number;\n    centerY: number;\n    panDirection: 'x' | 'y' | 'any';\n    onPan?: (detail: PanState) => void;\n  };\n  captureTargetRef: Ref<HTMLDivElement>;\n  panBounds?: PanBounds;\n  onDragPanStart?: () => void;\n  onDragPanEnd?: () => void;\n  zoom: number;\n  width: number;\n  height: number;\n};\n\nconst useDragPan = ({\n  panProps,\n  captureTargetRef,\n  panBounds,\n  width,\n  height,\n  zoom,\n  onDragPanStart,\n  onDragPanEnd\n}: UseDragPanOptions) => {\n  const prevPanState = useRef({ panX: 0, panY: 0 });\n  const initialPanState = useRef({ panX: 0, panY: 0 });\n  const dragProps = useDrag({\n    captureTargetRef,\n    onDragStart: () => {\n      const panValues = centerXYToPanXY(panProps.centerX, panProps.centerY, zoom, width, height);\n      initialPanState.current = {\n        panX: panValues.panX,\n        panY: panValues.panY\n      };\n      onDragPanStart && onDragPanStart();\n    },\n    onDragMove: ({ dx, dy }) => {\n      const nextPan = {\n        panX: initialPanState.current.panX + dx,\n        panY: initialPanState.current.panY + dy\n      };\n      const { newPan } = pan(\n        prevPanState.current,\n        nextPan,\n        panProps.panDirection,\n        zoom,\n        width,\n        height,\n        panBounds,\n        panProps.onPan\n      );\n      prevPanState.current = newPan;\n    },\n    onDragEnd: ({ originalEvent }) => {\n      // If panning occurred, call preventDefault to prevent selection from occurring\n      if (\n        initialPanState.current.panX !== prevPanState.current.panX ||\n        initialPanState.current.panY !== prevPanState.current.panY\n      )\n        originalEvent.preventDefault();\n      onDragPanEnd && onDragPanEnd();\n    },\n    isDisabled: panProps.panning === 'off'\n  });\n\n  return dragProps;\n};\n\nexport { useDragPan };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref, useRef } from 'preact/hooks';\nimport { usePointerGesture } from './usePointerGesture';\n/**\n * Draggable region\n */\ntype DraggableRegion = {\n  xMin: number;\n  xMax: number;\n  yMin: number;\n  yMax: number;\n};\n\ntype DragDetail = {\n  x: number;\n  y: number;\n  dx: number;\n  dy: number;\n  regionOffsetX: number;\n  regionOffsetY: number;\n  originalEvent: PointerEvent;\n};\n\ntype UseDragOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  draggableRegion?: DraggableRegion;\n  onDragStart?: (detail: Omit<DragDetail, 'dx' | 'dy'>) => void;\n  onDragMove?: (detail: DragDetail) => void;\n  onDragEnd?: (detail: DragDetail) => void;\n  isDisabled?: boolean;\n};\n/**\n * Whether point with coordinates are in the draggable region\n */\nconst inDraggableRegion = (x: number, y: number, region?: DraggableRegion) => {\n  if (!region) return true;\n  const { xMin, xMax, yMin, yMax } = region;\n  return x >= xMin && x <= xMax && y >= yMin && y <= yMax;\n};\n\n/**\n * Returns region offset\n */\nconst getRegionOffset = (x: number, y: number, region?: DraggableRegion) => {\n  if (!region) return { regionOffsetX: x, regionOffsetY: y };\n  return { regionOffsetX: x - region.xMin, regionOffsetY: y - region.yMin };\n};\n\nconst useDrag = ({\n  captureTargetRef,\n  draggableRegion,\n  onDragStart,\n  onDragMove,\n  onDragEnd,\n  isDisabled = false\n}: UseDragOptions) => {\n  const inactiveState = { isDragging: false, x0: -1, y0: -1, regionOffsetX: -1, regionOffsetY: -1 };\n  const dragState = useRef(inactiveState);\n\n  const handlePointerEvent = (e: PointerEvent, cb?: (detail: DragDetail) => void) => {\n    const { isDragging, x0, y0, regionOffsetX, regionOffsetY } = dragState.current;\n    if (!isDragging) return;\n    const x = e.pageX;\n    const y = e.pageY;\n    cb && cb({ x, y, dx: x - x0, dy: y - y0, regionOffsetX, regionOffsetY, originalEvent: e });\n  };\n\n  const dragProps = usePointerGesture({\n    captureTargetRef,\n    numPointers: 1, // Only allow 1 pointer dragging\n    onExtraneousPointerDown: () => {\n      dragState.current = inactiveState;\n    },\n    onPointerGestureDown: ({ pointers: [e] }) => {\n      const x = e.pageX;\n      const y = e.pageY;\n      if (e.button !== 0 || !inDraggableRegion(x, y, draggableRegion)) return;\n      const { regionOffsetX, regionOffsetY } = getRegionOffset(x, y, draggableRegion);\n      dragState.current = { isDragging: true, x0: x, y0: y, regionOffsetX, regionOffsetY };\n      onDragStart && onDragStart({ x, y, regionOffsetX, regionOffsetY, originalEvent: e });\n    },\n    onPointerGestureMove: ({ pointers: [e] }) => {\n      handlePointerEvent(e, onDragMove);\n    },\n    onPointerGestureEnd: ({ pointers: [e] }) => {\n      handlePointerEvent(e, onDragEnd);\n      dragState.current = inactiveState;\n    }\n  });\n\n  return isDisabled ? {} : dragProps;\n};\n\nexport { useDrag };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport const ZOOM_INCREMENT = 0.05;\n\nexport const zoom = (\n  nextZoom: number,\n  zoom: number,\n  minZoom: number,\n  maxZoom: number,\n  onZoomChange?: (detail: { zoomValue: number }) => void\n) => {\n  const newZoom = nextZoom > maxZoom || nextZoom < minZoom ? zoom : nextZoom;\n  const isZoomChanged = newZoom !== zoom;\n  isZoomChanged &&\n    onZoomChange &&\n    onZoomChange({\n      zoomValue: newZoom\n    });\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref, useRef } from 'preact/hooks';\nimport { usePointerGesture } from './usePointerGesture';\n\ntype Point = { x: number; y: number };\n\nconst getMidpoint = (p1: Point, p2: Point) => ({ x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 });\nconst getDistance = (p1: Point, p2: Point) => Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p2.y) ** 2);\n\ntype PinchDetail = {\n  origin: Point;\n  delta: number;\n};\n\ntype UsePinchOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  onPinchZoomStart?: (detail: PinchDetail) => void;\n  onPinchZoomChange?: (detail: PinchDetail) => void;\n  onPinchZoomEnd?: () => void;\n  isDisabled?: boolean;\n};\n\nconst usePinch = ({\n  captureTargetRef,\n  onPinchZoomStart,\n  onPinchZoomChange,\n  onPinchZoomEnd,\n  isDisabled = false\n}: UsePinchOptions) => {\n  const origin = useRef({ x: -1, y: -1 });\n  const prevDistance = useRef(-1);\n  const reset = () => {\n    origin.current = { x: -1, y: -1 };\n    prevDistance.current = -1;\n  };\n\n  if (isDisabled) reset();\n\n  const pinchProps = usePointerGesture({\n    captureTargetRef,\n    numPointers: 2, // Pinch gesture requires 2 pointers\n    onPointerGestureDown: ({ pointers: [pointer1, pointer2] }) => {\n      const p1 = { x: pointer1.offsetX, y: pointer1.offsetY };\n      const p2 = { x: pointer2.offsetX, y: pointer2.offsetY };\n      origin.current = getMidpoint(p1, p2);\n      prevDistance.current = getDistance(p1, p2);\n      onPinchZoomStart &&\n        onPinchZoomStart({\n          origin: origin.current,\n          delta: 0\n        });\n    },\n    onPointerGestureMove: ({ pointers: [pointer1, pointer2] }) => {\n      const p1 = { x: pointer1.offsetX, y: pointer1.offsetY };\n      const p2 = { x: pointer2.offsetX, y: pointer2.offsetY };\n      const distance = getDistance(p1, p2);\n      const delta = distance - prevDistance.current;\n      prevDistance.current = distance;\n      onPinchZoomChange &&\n        onPinchZoomChange({\n          origin: origin.current,\n          delta\n        });\n    },\n    onPointerGestureEnd: () => {\n      reset();\n      onPinchZoomEnd && onPinchZoomEnd();\n    }\n  });\n\n  return isDisabled ? {} : pinchProps;\n};\n\nexport { usePinch };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref } from 'preact/hooks';\nimport { usePinch } from './usePinch';\nimport { zoom, ZOOM_INCREMENT } from '../utils/zoomUtils';\n\ntype UsePinchZoomOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  zooming: 'on' | 'off';\n  minZoom: number;\n  maxZoom: number;\n  zoomValue: number;\n  onZoom?: (detail: { zoomValue: number }) => void;\n};\n\nconst usePinchZoom = ({\n  captureTargetRef,\n  zooming,\n  minZoom,\n  maxZoom,\n  zoomValue,\n  onZoom\n}: UsePinchZoomOptions) => {\n  const pinchProps = usePinch({\n    captureTargetRef,\n    onPinchZoomChange: ({ delta }) => {\n      const newZoom = zoomValue * (1 + ZOOM_INCREMENT * delta);\n      zoom(newZoom, zoomValue, minZoom, maxZoom, onZoom);\n    },\n    isDisabled: zooming === 'off'\n  });\n\n  return pinchProps;\n};\n\nexport { usePinchZoom };\n","import { Pan, Zoom, Bounds } from '../Diagram.types';\nimport { Ref, useState, useRef } from 'preact/hooks';\nimport { useDragPan } from './useDragPan';\nimport { useWheelZoom } from './useWheelZoom';\nimport { usePinchZoom } from './usePinchZoom';\n\nimport {\n  centerXYToPanXY,\n  getPanProps,\n  getZoomProps,\n  getZoomToFitZoom\n} from '../utils/diagramUtils';\nimport { PanBounds, getPanBounds, pan } from '../utils/panUtils';\nimport { zoom } from '../utils/zoomUtils';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\n\nimport { Property } from 'csstype';\n\ntype PanZoomProps = {\n  props: Pan & Zoom;\n  captureTargetRef: Ref<HTMLDivElement>;\n  width: number;\n  height: number;\n  contentBounds: Bounds;\n};\n\nexport const usePanZoom = ({\n  props,\n  captureTargetRef,\n  width,\n  height,\n  contentBounds\n}: PanZoomProps) => {\n  const [cursor, setCursor] = useState<Property.Cursor>();\n  const zoomProps = getZoomProps(props, width, height, contentBounds);\n  const panProps = getPanProps(props, contentBounds);\n  const panBounds = useRef<PanBounds>();\n  const prevZoom = useRef<number>();\n  const panning = useRef<string>();\n  const initPanZoomState = useRef({\n    zoom: props.zoomValue || 0,\n    centerX: props.centerX,\n    centerY: props.centerY\n  });\n  if (\n    contentBounds.w !== Infinity &&\n    (zoomProps.zoomValue !== prevZoom.current || panProps.panning !== panning.current)\n  ) {\n    panBounds.current = getPanBounds(\n      width,\n      height,\n      contentBounds,\n      panProps.panning,\n      zoomProps.zoomValue,\n      zoomProps.minZoom,\n      initPanZoomState.current\n    );\n    prevZoom.current = zoomProps.zoomValue;\n    panning.current = panProps.panning;\n  }\n  const dragPanProps = useDragPan({\n    panProps: panProps,\n    captureTargetRef: captureTargetRef,\n    panBounds: panBounds.current,\n    zoom: zoomProps.zoomValue,\n    width,\n    height,\n    onDragPanStart: () => setCursor('grabbing'),\n    onDragPanEnd: () => setCursor('auto')\n  });\n  //dZoom or nZoom is required\n  const kbZoomCallback = (props: { dZoom?: number; nZoom?: number }) => {\n    const newZoom = props.dZoom\n      ? zoomProps.zoomValue + props.dZoom\n      : getZoomToFitZoom(width, height, contentBounds);\n    zoom(\n      props.nZoom ? props.nZoom : newZoom,\n      zoomProps.zoomValue,\n      zoomProps.minZoom,\n      zoomProps.maxZoom,\n      zoomProps.onZoom\n    );\n  };\n  const prevPanState = useRef({ panX: 0, panY: 0 });\n\n  // dPan or nPan is required\n  const kbPanCallback = (props: {\n    dPan?: { dx: number; dy: number };\n    nPan?: { cx: number; cy: number };\n    center?: boolean;\n  }) => {\n    let centerX;\n    let centerY;\n    if (props.center) {\n      centerX = contentBounds.x + contentBounds.w / 2;\n      centerY = contentBounds.y + contentBounds.h / 2;\n    } else if (props.dPan) {\n      centerX = panProps.centerX + props.dPan.dx;\n      centerY = panProps.centerY + props.dPan.dy;\n    } else {\n      centerX = props.nPan!.cx;\n      centerY = props.nPan!.cy;\n    }\n    const panValues = centerXYToPanXY(centerX, centerY, zoomProps.zoomValue, width, height);\n    const { newPan } = pan(\n      prevPanState.current,\n      panValues,\n      panProps.panDirection,\n      zoomProps.zoomValue,\n      width,\n      height,\n      panBounds.current,\n      panProps.onPan\n    );\n    prevPanState.current = newPan;\n  };\n  const wheelZoomProps = useWheelZoom(zoomProps);\n  const pinchZoomProps = usePinchZoom({\n    captureTargetRef,\n    zooming: zoomProps.zooming,\n    minZoom: zoomProps.minZoom,\n    maxZoom: zoomProps.maxZoom,\n    zoomValue: zoomProps.zoomValue,\n    onZoom: zoomProps.onZoom\n  });\n  const panZoomProps = mergeProps(dragPanProps, wheelZoomProps, pinchZoomProps);\n\n  return {\n    panZoomProps,\n    cursor,\n    centerX: panProps.centerX,\n    centerY: panProps.centerY,\n    zoomValue: zoomProps.zoomValue,\n    kbPanCallback: panProps.panning !== 'off' ? kbPanCallback : undefined,\n    kbZoomCallback: zoomProps.zooming !== 'off' ? kbZoomCallback : undefined\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useWheel } from './useWheel';\nimport { zoom, ZOOM_INCREMENT } from '../utils/zoomUtils';\n\ntype UseWheelZoomOptions = {\n  zooming: 'on' | 'off';\n  minZoom: number;\n  maxZoom: number;\n  zoomValue: number;\n  onZoom?: (detail: { zoomValue: number }) => void;\n};\n\nconst useWheelZoom = ({ zooming, minZoom, maxZoom, zoomValue, onZoom }: UseWheelZoomOptions) => {\n  const wheelProps = useWheel({\n    onWheel: ({ deltaY }) => {\n      const newZoom = zoomValue * (1 + ZOOM_INCREMENT * deltaY);\n      zoom(newZoom, zoomValue, minZoom, maxZoom, onZoom);\n    },\n    isDisabled: zooming === 'off'\n  });\n\n  return wheelProps;\n};\n\nexport { useWheelZoom };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\ntype WheelDetail = {\n  x: number;\n  y: number;\n  deltaX: number;\n  deltaY: number;\n  ctrlKey: boolean;\n};\n\ntype UseWheelOptions = {\n  onWheel: (detail: WheelDetail) => void;\n  preventDefault?: boolean;\n  isDisabled?: boolean;\n};\n\nconst PX_FACTOR_PER_LINE = 15; // Value used in Toolkit\nconst PX_FACTOR_PER_PAGE = 40; // Value copied from datagrid; this is not handled in Toolkit\n\nconst getNormalizedDelta = (e: WheelEvent) => {\n  const { deltaX, deltaY, deltaMode } = e;\n\n  switch (deltaMode) {\n    case e.DOM_DELTA_PIXEL:\n      return { deltaX: -deltaX, deltaY: -deltaY };\n    case e.DOM_DELTA_LINE:\n      return { deltaX: -deltaX * PX_FACTOR_PER_LINE, deltaY: -deltaY * PX_FACTOR_PER_LINE };\n    case e.DOM_DELTA_PAGE:\n      return { deltaX: -deltaX * PX_FACTOR_PER_PAGE, deltaY: -deltaY * PX_FACTOR_PER_PAGE };\n    default:\n      return { deltaX: -deltaX, deltaY: -deltaY };\n  }\n};\n\nconst useWheel = ({\n  onWheel: onWheelCallback,\n  preventDefault = true,\n  isDisabled = false\n}: UseWheelOptions) => {\n  const onWheel = (e: WheelEvent) => {\n    const { deltaX, deltaY } = getNormalizedDelta(e);\n    if (preventDefault) e.preventDefault();\n    onWheelCallback({\n      x: e.offsetX,\n      y: e.offsetY,\n      deltaX,\n      deltaY,\n      ctrlKey: e.ctrlKey || e.metaKey\n    });\n  };\n  return isDisabled ? {} : { onWheel };\n};\n\nexport { useWheel, PX_FACTOR_PER_LINE };\n","import { useSelection } from '../../hooks/PRIVATE_useVisSelection';\nimport type { DiagramNode, DiagramLink, ItemInfo } from '../Diagram.types';\nimport { getNavigableInfo } from '../utils/diagramUtils';\nimport { Ref } from 'preact/hooks';\n\ntype SelectionProps<K1,K2> = {\n    selectedIds: {\n\t\t\tnodes?: K1[],\n\t\t\tlinks?: K2[]\n\t\t},\n    selectionMode: 'none'|'single'|'multiple';\n\t\tnodeMap: {\n\t\t\titemIdToDataMap: Map<K1, DiagramNode<K1>>,\n\t\t\titemIdToIndexMap: Map<K1, number>\n\t\t\titemIndexToIdMap: Map<number, K1>\n\t\t},\n\t\tlinkMap: {\n\t\t\titemIdToDataMap: Map<K1, DiagramLink<K2, K1>>,\n\t\t\titemIdToIndexMap: Map<K2, number>\n\t\t\titemIndexToIdMap: Map<number, K2>\n\t\t}\n\t\tfocusedItemInfo: ItemInfo<K1,K2>,\n    onSelectionChange?: (detail: { nodes: Array<K1>; links: Array<K2> }) => void,\n\t\trootRef: Ref<HTMLDivElement>\n  };\n\ntype EncodedNodeId = `N_${number}`;\ntype EncodedLinkId = `L_${number}`;\n\nexport function useDiagramSelection<K1,K2> ({\nselectedIds,\nselectionMode,\nnodeMap,\nlinkMap,\nfocusedItemInfo,\nonSelectionChange,\nrootRef\n}: SelectionProps<K1,K2>) {\n\tconst nodeIdToIndexMap = nodeMap.itemIdToIndexMap;\n\tconst nodeIndexToIdMap = nodeMap.itemIndexToIdMap;\n\tconst linkIdToIndexMap = linkMap.itemIdToIndexMap;\n\tconst linkIndexToIdMap = linkMap.itemIndexToIdMap;\n\tconst encodeNodeId = (id: K1) => `N_${nodeIdToIndexMap.get(id)}` as EncodedNodeId;\n\tconst decodeNodeId = (id: EncodedNodeId) => nodeIndexToIdMap.get(Number(id.slice(2)));\n\tconst encodeLinkId = (id: K2) => `L_${linkIdToIndexMap.get(id)}` as EncodedLinkId;\n\tconst decodeLinkId = (id: EncodedLinkId) => linkIndexToIdMap.get(Number(id.slice(2)));\n\n\tconst encodedNodesSelection = selectedIds.nodes ? selectedIds.nodes.map(encodeNodeId) : [];\n\tconst encodedLinksSelection = selectedIds.links ? selectedIds.links.map(encodeLinkId) : [];\n\tconst encodedSelection = [...encodedNodesSelection, ...encodedLinksSelection]\n\tconst idExtracter = (event: Event) => {\n\t\t// return encodeNodeId(id) or encodeLinkId(id) depending on node or link selection\n\t\tconst info =\n\t\tevent.type === 'keyup'\n\t\t\t? focusedItemInfo\n\t\t\t: getNavigableInfo<K1,K2>(event.target as HTMLElement, rootRef);\n\t\treturn info.isNode ? encodeNodeId(info.id as K1) : encodeLinkId(info.id as K2);\n\t};\n\n\tconst onEncodedSelectionChange = (detail: { ids: (EncodedNodeId | EncodedLinkId)[] }) => {\n\t\tconst newSelectedNodeIds = detail.ids.filter((encId) => encId[0] === 'N').map((encId) => decodeNodeId(encId as EncodedNodeId)!);\n\t\tconst newSelectedLinkIds = detail.ids.filter((encId) => encId[0] === 'L').map((encId) => decodeLinkId(encId as EncodedLinkId)!);\n\t\treturn onSelectionChange && onSelectionChange({ nodes: newSelectedNodeIds, links: newSelectedLinkIds });\n\t};\n\n\tconst selectionProps = useSelection({\n\t\tselection: encodedSelection,\n\t\tidExtracter,\n\t\tselectionMode,\n\t\tonChange: onEncodedSelectionChange\n\t})\n\nreturn selectionProps\n}","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { Diagram, Bounds, DiagramLabelPosition, States } from './Diagram.types';\nimport type { Size } from '../utils/UNSAFE_size';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\n\nimport { DiagramLayers } from './DiagramLayers';\nimport { TrackResizeContainer } from '../PRIVATE_TrackResizeContainer';\nimport { DiagramPanZoomContainer } from './DiagramPanZoomContainer';\n\nimport { useEvents } from './hooks/useEvents';\nimport { useDiagramDatatip } from './hooks/useDiagramDatatip';\nimport { useTextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { usePanZoom } from './hooks/usePanZoom';\nimport { useRef, useState } from 'preact/hooks';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useDiagramSelection } from './hooks/useDiagramSelection';\n\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport {\n  constructLayoutJSON,\n  deconstructLayoutJSON,\n  createItemMap,\n  getDatatipText,\n  getFocusedItemBounds,\n  mergeDimensions,\n  getDimensionsFromBounds,\n  combineIds,\n  getContentBounds,\n  centerXYToPanXY,\n  filterLinksWithNoEndNodes,\n  getAllLabelBounds\n} from './utils/diagramUtils';\nimport { sizeToCSS } from '../utils/UNSAFE_size';\n\nimport { outerStyles } from './themes/DiagramStyles.css';\n\n/**\n * Diagrams are used to display a set of nodes and the links between them.\n */\nexport function Diagram<K1 extends string | number, K2 extends string | number>({\n  nodes = [],\n  links = [],\n  width = '100%',\n  height = '140x',\n  selectedIds = {},\n  selectionMode = 'none',\n  layout,\n  nodeRenderer,\n  linkRenderer,\n  onSelectionChange,\n  onItemInput,\n  highlightedIds = {},\n  datatip,\n  ...otherProps\n}: Diagram<K1, K2>) {\n  const focusedItemBoundsRef = useRef<Bounds | null>(null);\n  const rootRef = useRef<HTMLDivElement>(null);\n  //TODO JET-62563 change bounds to a MAP\n  const [bounds, setBounds] = useState<Bounds[]>([]);\n  const [combinedLabelBounds, setCombinedLabelBounds] = useState<Bounds>();\n  const { direction } = useUser();\n\n  if (nodes.length === 0) return null;\n  const diagramNodes = nodes;\n  const nodeMap = createItemMap<K1, K2>(diagramNodes);\n  const nodeIdToDataMap = nodeMap.itemIdToDataMap;\n  const diagramLinks = filterLinksWithNoEndNodes(links, nodeIdToDataMap);\n  const linkMap = createItemMap<K1, K2>(diagramLinks);\n  const linkIdToDataMap = linkMap.itemIdToDataMap;\n\n  return (\n    <TrackResizeContainer\n      width={sizeToCSS(width as Size) || '0px'}\n      height={sizeToCSS(height as Size) || '0px'}>\n      {function _(dgWidth, dgHeight) {\n        const resizeThrottling = useRef<boolean>(false);\n        const newDimensions = getDimensionsFromBounds(bounds);\n        const { textMeasureContent, getTextDimensions } = useTextDimensions();\n        const labelDimensions = useRef<Map<K1 | K2, TextDimensions>>(new Map());\n        const nodeLabelPosRef = useRef<(DiagramLabelPosition | undefined)[] | undefined>([]);\n        const linkLabelPosRef = useRef<(DiagramLabelPosition | undefined)[] | undefined>([]);\n\n        const contentBounds = getContentBounds(bounds, combinedLabelBounds);\n        const { panZoomProps, cursor, centerX, centerY, zoomValue, kbPanCallback, kbZoomCallback } =\n          usePanZoom({\n            props: otherProps,\n            captureTargetRef: rootRef,\n            width: dgWidth,\n            height: dgHeight,\n            contentBounds\n          });\n        const { focusedItemInfo, hoveredItemInfo, ...eventsProps } = useEvents<K1, K2>(\n          diagramNodes[0],\n          diagramNodes,\n          diagramLinks,\n          bounds,\n          linkIdToDataMap,\n          nodeMap.itemIdToIndexMap,\n          dgWidth,\n          dgHeight,\n          otherProps.maxZoom || 1,\n          onItemInput,\n          kbPanCallback,\n          kbZoomCallback\n        );\n\n        const selectionProps = useDiagramSelection<K1, K2>({\n          selectedIds,\n          selectionMode,\n          nodeMap,\n          linkMap,\n          focusedItemInfo,\n          onSelectionChange,\n          rootRef\n        });\n\n        // This is for the datatip kb position\n        if (focusedItemInfo && bounds.length > 0) {\n          focusedItemBoundsRef.current = getFocusedItemBounds(\n            focusedItemInfo,\n            bounds,\n            diagramLinks,\n            nodeMap.itemIdToIndexMap,\n            linkMap.itemIdToIndexMap\n          );\n        }\n        const datatipText = getDatatipText(\n          nodeIdToDataMap,\n          linkIdToDataMap,\n          focusedItemInfo,\n          hoveredItemInfo,\n          datatip\n        );\n        const { datatipContent, datatipProps } = useDiagramDatatip({\n          text: datatipText,\n          focusedItemInfo,\n          focusedItemBoundsRef,\n          panState: centerXYToPanXY(centerX, centerY, zoomValue, dgWidth, dgHeight),\n          zoom: zoomValue,\n          width: dgWidth\n        });\n\n        const style = {\n          width: dgWidth,\n          height: dgHeight,\n          cursor: cursor\n        };\n\n        const states = useRef<States<K1, K2>>();\n        const previousState = states.current // states.current is previous state\n          ? states.current\n          : {\n              selectedNodeIds: [],\n              selectedLinkIds: [],\n              focusedId: undefined,\n              hoveredId: undefined,\n              activeId: undefined,\n              highlightedIds: [],\n              zoom: 0\n            };\n\n        states.current = {\n          // update states to new state\n          selectedNodeIds: selectedIds.nodes ?? [],\n          selectedLinkIds: selectedIds.links ?? [],\n          focusedId:\n            focusedItemInfo.isCurrent && focusedItemInfo.isFocusVisible\n              ? focusedItemInfo.id\n              : undefined,\n          hoveredId: hoveredItemInfo?.isCurrent ? hoveredItemInfo.id : undefined,\n          activeId: eventsProps['aria-activedescendant'],\n          highlightedIds: combineIds(highlightedIds.nodes, highlightedIds.links),\n          zoom: zoomValue\n        };\n\n        const mergedEventProps = mergeProps(\n          panZoomProps,\n          eventsProps,\n          selectionProps,\n          datatipProps\n        );\n\n        // Called anytime node changes size\n        const onNodeSizeChanged = (nodeWidth: number, nodeHeight: number, idx: number) => {\n          newDimensions[idx] = { w: nodeWidth, h: nodeHeight };\n          if (resizeThrottling.current) {\n            return;\n          }\n\n          resizeThrottling.current = true;\n          // performs layout at the next available animation frame when all measurements should be ready\n          window.requestAnimationFrame(() => {\n            const { labelDims, layoutJSON } = constructLayoutJSON(\n              diagramNodes,\n              nodeIdToDataMap,\n              linkIdToDataMap,\n              newDimensions,\n              dgWidth,\n              dgHeight,\n              getTextDimensions\n            );\n            labelDimensions.current = labelDims;\n            const { nodePoints, nodeLabelPos, linkLabelPos } = deconstructLayoutJSON<K1, K2>(\n              layout(layoutJSON),\n              diagramNodes,\n              diagramLinks\n            );\n            nodeLabelPosRef.current = nodeLabelPos;\n            linkLabelPosRef.current = linkLabelPos;\n            const nodeBounds = mergeDimensions(newDimensions, nodePoints);\n            setBounds(nodeBounds);\n            const labelBounds = getAllLabelBounds(\n              labelDims,\n              diagramNodes,\n              diagramLinks,\n              nodeLabelPos,\n              linkLabelPos,\n              direction === 'rtl'\n            );\n            setCombinedLabelBounds(labelBounds);\n            resizeThrottling.current = false;\n          });\n        };\n        return (\n          <div\n            ref={rootRef}\n            class={outerStyles}\n            {...mergedEventProps}\n            style={style}\n            tabIndex={0}\n            role=\"application\"\n            aria-label={otherProps['aria-label']}\n            aria-labelledby={otherProps['aria-labelledby']}\n            aria-describedby={otherProps['aria-describedby']}>\n            {getTextDimensions ? (\n              <DiagramPanZoomContainer\n                centerX={centerX}\n                centerY={centerY}\n                zoom={zoomValue}\n                width={dgWidth}\n                height={dgHeight}>\n                <DiagramLayers\n                  nodes={diagramNodes}\n                  links={diagramLinks}\n                  nodeRenderer={nodeRenderer}\n                  linkRenderer={linkRenderer}\n                  width={dgWidth}\n                  height={dgHeight}\n                  nodeBounds={bounds}\n                  states={states.current!}\n                  previousStates={previousState}\n                  onNodeSizeChanged={onNodeSizeChanged}\n                  nodeLabelPositions={nodeLabelPosRef.current}\n                  linkLabelPositions={linkLabelPosRef.current}\n                  labelDimensions={labelDimensions.current}\n                  supportsSelection={\n                    selectionMode !== 'none' ||\n                    !!(selectedIds?.nodes && selectedIds.nodes.length > 0) ||\n                    !!(selectedIds?.links && selectedIds.links.length > 0)\n                  }\n                />\n              </DiagramPanZoomContainer>\n            ) : undefined}\n            {textMeasureContent}\n            {datatipContent}\n          </div>\n        );\n      }}\n    </TrackResizeContainer>\n  );\n}\n"],"names":["ZOOM_TO_FIT_PADDING","createItemMap","items","itemIdToDataMap","Map","itemIdToIndexMap","itemIndexToIdMap","i","length","set","id","combineIds","nodeIds","linkIds","combinedIds","push","getLabelBounds","label","dims","isRTL","labelPos","getLabelPosition","rotationAngle","rotationPoint","x","width","y","height","angle","topLeft","getCoordsRelToRotPoint","topRight","bottomLeft","bottomRight","points","minX","minY","maxX","maxY","point","w","h","getBoundsFromPoints","rotatePoint","map","pos","labelPoint","rotPoint","Math","cos","sin","dimensions","positionProps","position","hAlign","vAlign","centerXYToPanXY","centerX","centerY","zoom","panX","panY","isEqualItem","item1","item2","isNode","getNavigableInfo","element","rootElementRef","navigableId","elem","dataset","parentElement","current","getItemAriaLabel","translations","supportsSelection","isSelected","accessibleLabel","dataVisualization_stateSelected","dataVisualization_stateUnselected","getZoomToFitZoom","contentBounds","zoomX","zoomY","min","constrainZoom","minZoom","maxZoom","newZoom","max","_getFontProps","styles","fontProps","fontFamily","fontSize","fontStyle","fontWeight","zoomAndCenterItemFromInfo","info","linkIdToDataMap","bounds","nodeIdToIndex","totalBounds","get","link","startNodeBounds","startNode","endNodeBounds","endNode","cX","cY","getPanZoomToCenterNode","DiagramNodeElement","state","previousState","activeId","nodeRenderer","onNodeSizeChanged","nodeIndex","data","isDimmed","nodeStyles","dimmedItemStyle","itemStyles","context","useTranslationBundle","ref","useRef","optionsRef","box","useResizeObserver","callback","useCallback","entry","boxSize","borderBoxSize","inlineSize","blockSize","resizeObserverOptions","_jsx","class","classNames","undefined","role","selected","style","top","left","focused","hovered","children","DiagramNodeLayer","nodes","states","previousStates","nodeBounds","layerStyles","node","selectedNodeIds","includes","focusedId","hoveredId","jsx","highlightedIds","DiagramLinkElement","linkRenderer","linkStyles","DiagramLinkLayer","links","selectedLinkIds","DiagramLabel","text","labelStyle","labelBorderStyle","labelStyles","labelPosition","labelRotation","rotation","getLabelRotation","borderColor","DiagramLabelLayer","itemProps","labelDimensions","direction","useUser","item","DiagramLayers","nodeLabelPositions","linkLabelPositions","_jsxs","jsxs","_Fragment","Fragment","Infinity","DiagramPanZoomContainer","panValues","panZoomStyles","translate","transform","getNodeDetailFromInfo","itemInfo","getNavigableLinksForNodeId","nodeId","listOfLinks","forEach","startId","endId","_getClockwiseAngle","currNode","oppositeNode","p1","_getNodeCenter","p2","atan2","PI","_getNodesDistance","sqrt","pow","_getLinkDirection","nodeBB","calcDistanceAngleWeighted","objectBB","currentBB","optimalAngle1","optimalAngle2","objCenterX","objCenterY","curCenterX","curCenterY","x_dist","abs","y_dist","distance","isValidDestination","objBB","curBB","compareCenters","_areEqualWithinTolerance","calcInContact","objRect","curRect","_isVerticallyAligned","_isHorizontallyAligned","rect1","rect2","a","b","_anglesAreEqualWithinTolerance","a1","a2","res","useDiagramNavigation","currentKeyboardFocusNode","nodeBoundsById","createNodeBoundsMap","getNextNavigableNode","listOfObjects","currBB","object","inContact","nextObject","nextDistance","Number","MAX_VALUE","nextInContact","hasFoundCurrent","objBounds","currBounds","getNextNavigableLink","listOfNodes","currentLink","keyboardFocusNode","linksWithSortingAttributes","linkDetail","addSortingAttributes","sort","link1","link2","linkAngle1","linkDistance1","linkDirection1","linkAngle2","linkDistance2","linkDirection2","bForward","index","navigateFromNodeToLink","event","adjLinks","currNodeBB","currNodeBBCenterX","nodeCenterX","altKey","code","navigateFromLinkToNode","linkId","key","linkData","startNodeBB","endNodeBB","startNodeCenterX","endNodeCenterX","DEFAULT_KB_PAN","DEFAULT_KB_ZOOM","useEvents","initNode","nodeIdToIndexMap","onInput","kbPanCallback","kbZoomCallback","focusedItemInfo","setfocusedItemInfo","useState","hoveredItemInfo","sethoveredItemInfo","updatefocusedItemInfo","type","getRandomId","handleKeyboardInput","isCurrent","isFocusVisible","onKeyUp","onKeyDown","eventConsumed","isChangeItemType","isNavigationEvent","nextItemInfo","itemDetail","getLinkDetailFromInfo","handleKeyboardNavigationEvent","dPan","dx","shiftKey","dy","dZoom","ctrlKey","nZoom","nPan","cx","cy","center","preventDefault","stopPropagation","cancelEvent","onBlur","onPointerUp","target","onPointerMove","onPointerLeave","usePointerGesture","captureTargetRef","numPointers","onPointerGestureDown","onPointerGestureMove","onPointerGestureEnd","onExtraneousPointerDown","isDisabled","activePointers","e","findIndex","pointerEvent","pointerId","pointers","splice","onPointerDown","setPointerCapture","onPointerCancel","pan","previousPan","nextPan","panDirection","panBounds","onPanChange","newPan","constrainPan","isPanChanged","panXYToCenterXY","useDragPan","panProps","onDragPanStart","onDragPanEnd","prevPanState","initialPanState","dragProps","draggableRegion","onDragStart","onDragMove","onDragEnd","inactiveState","isDragging","x0","y0","regionOffsetX","regionOffsetY","dragState","handlePointerEvent","cb","pageX","pageY","originalEvent","button","region","xMin","xMax","yMin","yMax","inDraggableRegion","getRegionOffset","useDrag","onPan","panning","nextZoom","onZoomChange","zoomValue","getDistance","usePinchZoom","zooming","onZoom","pinchProps","onPinchZoomStart","onPinchZoomChange","onPinchZoomEnd","origin","prevDistance","reset","pointer1","pointer2","offsetX","offsetY","getMidpoint","delta","usePinch","usePanZoom","props","cursor","setCursor","zoomProps","getZoomProps","getPanProps","prevZoom","initPanZoomState","elemBounds","panType","zoomRatio","minZoomX","minZoomY","initZoom","initCenterX","initCenterY","boundsX","boundsY","getPanBounds","dragPanProps","wheelZoomProps","onWheel","onWheelCallback","deltaX","deltaY","deltaMode","DOM_DELTA_PIXEL","DOM_DELTA_LINE","DOM_DELTA_PAGE","getNormalizedDelta","metaKey","useWheel","useWheelZoom","pinchZoomProps","panZoomProps","mergeProps","useDiagramSelection","selectedIds","selectionMode","nodeMap","linkMap","onSelectionChange","rootRef","nodeIndexToIdMap","linkIdToIndexMap","linkIndexToIdMap","encodeNodeId","encodeLinkId","encodedSelection","useSelection","selection","idExtracter","onChange","detail","newSelectedNodeIds","ids","filter","encId","decodeNodeId","slice","newSelectedLinkIds","decodeLinkId","layout","onItemInput","datatip","otherProps","focusedItemBoundsRef","setBounds","combinedLabelBounds","setCombinedLabelBounds","diagramNodes","nodeIdToDataMap","diagramLinks","nodesMap","newLinks","filterLinksWithNoEndNodes","TrackResizeContainer","sizeToCSS","dgWidth","dgHeight","resizeThrottling","newDimensions","getDimensionsFromBounds","textMeasureContent","getTextDimensions","useTextDimensions","nodeLabelPosRef","linkLabelPosRef","labelBounds","getContentBounds","eventsProps","selectionProps","startNB","endNB","startNCenter","endNCenter","getFocusedItemBounds","datatipText","linksMap","focusedItem","hoveredItem","isPointerActive","getDatatipText","datatipContent","datatipProps","panState","isRtl","elementBounds","useDatatip","content","placement","offset","calculateOffset","anchor","useDiagramDatatip","mergedEventProps","outerStyles","tabIndex","nodeWidth","nodeHeight","idx","window","requestAnimationFrame","labelDims","layoutJSON","nodeItems","linkItems","nodeKeys","Array","from","keys","linkKeys","getNodeDimensions","getLabelDimensions","componentSize","constructLayoutJSON","nodePoints","nodeLabelPos","linkLabelPos","nodeData","positions","hasNodeLabels","hasLinkLabels","deconstructLayoutJSON","newBounds","dim","mergeDimensions","getAllLabelBounds"],"mappings":"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"}