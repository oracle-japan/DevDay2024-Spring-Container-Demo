{"version":3,"file":"List-d040cb51.js","sources":["../../src/PRIVATE_List/ListRoles.ts","../../src/PRIVATE_List/ListItem.tsx","../../src/PRIVATE_List/SkeletonContainer.tsx","../../src/PRIVATE_List/Sparkle.tsx","../../src/PRIVATE_List/List.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Roles } from '../UNSAFE_ListView';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\n\n/**\n * List Roles need to be kept in matching sets, this module encapsulates the sets\n *\n * @param ariaRole\n * @returns matching, valid set of roles\n */\n\nconst getListViewRoles = (\n  ariaRole: Roles\n): {\n  list: HTMLAttributesSignalExcluded['role'];\n  item: HTMLAttributesSignalExcluded['role'];\n  cell: HTMLAttributesSignalExcluded['role'];\n} => {\n  switch (ariaRole) {\n    case 'listbox':\n      return { list: 'listbox', item: 'presentation', cell: 'option' };\n    case 'treegrid':\n      return { list: 'treegrid', item: 'row', cell: 'gridcell' };\n    default:\n      return { list: 'grid', item: 'row', cell: 'gridcell' };\n  }\n};\n\nexport { getListViewRoles };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { useRef, useMemo } from 'preact/hooks';\nimport { memo } from 'preact/compat';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { SelectionMode, CurrentItemVariant, ListItemRendererContext } from '../UNSAFE_Collection';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { Roles } from '../UNSAFE_ListView';\nimport { getListViewRoles } from './ListRoles';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { flexitemInterpolations } from '../utils/UNSAFE_interpolations/flexitem';\nimport type { FlexitemProps } from '../utils/UNSAFE_interpolations/flexitem';\nimport { listItemStyles, listItemMultiVariantStyles } from './themes/ListStyles.css';\nimport { compareListItemContext } from '../utils/PRIVATE_collectionUtils';\n\nexport const ITEM_SELECTOR = '[data-oj-key]';\n\n/**\n * Props for the ListViewItem Component\n */\nexport type Props<K, D> = {\n  children: (context: ListItemRendererContext<K, D>) => ComponentChildren;\n  context: ListItemRendererContext<K, D>;\n  itemDepth?: number;\n  isFocused: boolean;\n  isFocusRingVisible: boolean;\n  isActive: boolean;\n  isGridlineVisible: boolean;\n  isSelected: boolean;\n  isTopGridlineVisible?: boolean;\n  isTabbable?: boolean;\n  role: Roles;\n  selectionMode: SelectionMode;\n  suggestion?: 'end' | true;\n  currentItemVariant?: CurrentItemVariant;\n};\n\n/**\n * The internal component used to render a single item in ListView.\n */\nexport function ListViewItem<K extends string | number, D>({\n  children,\n  context,\n  itemDepth,\n  isFocused,\n  isFocusRingVisible,\n  isActive,\n  isGridlineVisible,\n  isSelected,\n  isTopGridlineVisible = false,\n  isTabbable = false,\n  role,\n  selectionMode,\n  suggestion,\n  currentItemVariant\n}: Props<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const roles = useMemo(() => getListViewRoles(role), [role]);\n  const itemKey = context.metadata.key;\n  const itemIndex = context.index;\n\n  // some roles come with related aria attributes which need to be set\n  const cellRoleAttributes =\n    roles.cell === 'option'\n      ? {\n          role: roles.cell,\n          'aria-posinset': itemIndex + 1,\n          'aria-setsize': -1\n        }\n      : {\n          role: roles.cell\n        };\n\n  // don't bubble Arrow Up and Down events to parent when in isTabbable mode\n  // this bubbling causes the outer CollectionFocus ring to change index while in the isTabbable mode.\n  const handleKeyDown = (event: KeyboardEvent) => {\n    if (isTabbable && (event.key === 'ArrowDown' || event.key === 'ArrowUp')) {\n      event.stopPropagation();\n    }\n  };\n\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle();\n\n  const variantClasses = listItemMultiVariantStyles({\n    selectable: isSelectable(selectionMode, isSelected) ? 'isSelectable' : 'notSelectable',\n    selected: isSelected ? 'isSelected' : 'notSelected',\n    selectedSingle:\n      isSelected && selectionMode === 'single' ? 'isSelectedSingle' : 'notSelectedSingle',\n    needsEventsHover: applyHoverStyle ? 'isNeedsEventsHover' : 'notNeedsEventsHover',\n    pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',\n    active: applyActiveStyle || isActive ? 'isActive' : 'notActive',\n    focusHighlight:\n      currentItemVariant === 'highlight' && isFocused ? 'isFocusHighlight' : 'notFocusHighlight',\n    focusRingVisible:\n      isFocusRingVisible && isFocused ? 'isFocusRingVisible' : 'notFocusRingVisible',\n    gridlineTop: isTopGridlineVisible ? 'visible' : 'hidden',\n    gridlineBottom:\n      isGridlineVisible ||\n      (suggestion === 'end' && !isGridlineVisible && (!isSelected || selectionMode !== 'single'))\n        ? 'visible'\n        : 'hidden'\n  });\n  const classes = classNames([variantClasses]);\n  const styleInterpolations = mergeInterpolations<FlexitemProps>([\n    ...Object.values(flexitemInterpolations)\n  ]);\n  const { class: cls, ...cellStyles } = styleInterpolations({\n    flex: '1 1 auto',\n    alignSelf: 'center'\n  });\n  const cellClasses = classNames([\n    cls,\n    selectionMode === 'multiple' && listItemStyles.checkboxContainer\n  ]);\n\n  // todo: use translated text for selector\n  // note cannot put focus on gridcell div since JAWS will not read the aria-rowindex\n  // correctly, so unfortunately needed another div\n  return (\n    <div\n      aria-rowindex={itemIndex + 1}\n      aria-level={itemDepth}\n      data-oj-key={itemKey}\n      class={classes}\n      ref={rootRef}\n      role={roles.item}\n      {...(suggestion && { 'data-oj-suggestion': true })}\n      {...(typeof itemKey === 'number' && { 'data-oj-key-type': 'number' })}\n      {...interactionProps}>\n      <div\n        id={useId()}\n        style={cellStyles}\n        class={cellClasses}\n        aria-posinset={itemIndex + 1}\n        aria-setsize={-1}\n        onKeyDown={handleKeyDown}\n        aria-colindex={1}\n        aria-selected={selectionMode !== 'none' ? isSelected : undefined}\n        {...cellRoleAttributes}>\n        <TabbableModeContext.Provider value={{ isTabbable }}>\n          <FocusTrap isDisabled={!isTabbable} restoreFocusRef={false}>\n            {children(context)}\n          </FocusTrap>\n        </TabbableModeContext.Provider>\n      </div>\n    </div>\n  );\n}\n\n/**\n * Helper method to determine whether item is selectable\n * @returns true if item is selectable (show hover effect), false otherwise\n */\nconst isSelectable = (selectionMode: SelectionMode, isItemSelected: boolean) => {\n  return selectionMode !== 'none' && (selectionMode === 'multiple' || !isItemSelected);\n};\n\nexport const MemoizeListViewItem = memo(ListViewItem, (prev: any, next: any) => {\n  if (prev && next) {\n    return (\n      prev.children === next.children &&\n      prev.isFocused === next.isFocused &&\n      prev.isFocusRingVisible === next.isFocusRingVisible &&\n      prev.isSelected === next.isSelected &&\n      prev.isTabbable === next.isTabbable &&\n      prev.isActive === next.isActive &&\n      prev.suggestion === next.suggestion &&\n      prev.isGridlineVisible === next.isGridlineVisible &&\n      prev.isTopGridlineVisible === next.isTopGridlineVisible &&\n      compareListItemContext(prev.context, next.context)\n    );\n  }\n  return false;\n});\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { skeletonStyles } from './themes/ListStyles.css';\n\ntype Props = {\n  /**\n   * Allows to pass and access the properties from child elements\n   **/\n  children?: (index: number) => ComponentChildren;\n  /**\n   * Allows to specify number of skeletons to be rendered on initial load\n   **/\n  minimumCount?: number;\n};\n\n/**\n * Allows to specify the time delay for rendering the component\n **/\nconst timerValue = 50;\n\n/**\n * SkeletonContainer renders 'minimumCount' number of skeletons\n * of the variant specified from its child element - Skeleton's prop after\n * 'timerValue' ms delay\n **/\nexport function SkeletonContainer({ children, minimumCount = 1 }: Props) {\n  const [isVisible, setIsVisible] = useState(false);\n\n  useEffect(() => {\n    setTimeout(() => {\n      setIsVisible(true);\n    }, timerValue);\n  }, []);\n\n  const containerClasses = classNames([skeletonStyles.container]);\n  return isVisible && children ? (\n    <div class={containerClasses} role=\"presentation\">\n      {[...Array(minimumCount)].map((_element, index) => children(index))}\n    </div>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Metadata } from '../UNSAFE_Collection';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { globalImages } from '#/ImageVars.css';\nimport { sparkleStyles } from './themes/ListStyles.css';\nimport { useTheme } from '#/hooks/UNSAFE_useTheme';\n\nconst SPARKLE_STYLE_CLASS = 'oj-collection-sparkle';\n\n/**\n * A sparkle component for smart suggestion indicator in ListView\n * @param sparkleHeight the height of sparkle\n */\nexport function Sparkle({ sparkleHeight }: { sparkleHeight: number }) {\n  const { name } = useTheme();\n  if (sparkleHeight <= 0) {\n    return null;\n  }\n\n  const height = sparkleHeight + 'px';\n  const sparkleClasses = classNames([sparkleStyles.base]);\n  const containerClasses = classNames([\n    sparkleStyles.container,\n    SPARKLE_STYLE_CLASS,\n    // TODO: this component should create separate theme definitions to only show the image in redwood\n    name === 'redwood' && globalImages\n  ]);\n\n  return (\n    <div key=\"sparkle\" class={containerClasses}>\n      <div class={sparkleClasses} style={{ height }}></div>\n    </div>\n  );\n}\n\n/**\n * A helper function that finds the data with suggestions, and\n * returns the corresponding keys\n * @param dataState\n */\nexport const findSuggestions = <K, D>(\n  data: { data: D; metadata: Metadata<K> }[],\n  count: number\n) => {\n  if (count === 0) {\n    return null;\n  }\n\n  const suggestionsData = data.slice(0, count);\n  return suggestionsData.reduce((suggestions, value, index) => {\n    const key = value.metadata.key;\n\n    if (index === count - 1) {\n      suggestions.set(key, 'end');\n    } else {\n      suggestions.set(key, true);\n    }\n\n    return suggestions;\n  }, new Map<K, 'end' | true>());\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentProps, RefObject } from 'preact';\nimport { useRef, useCallback, useEffect, useState, useMemo } from 'preact/hooks';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { containsKey, Keys, isKeyDefined } from '../utils/UNSAFE_keys';\nimport {\n  DataState,\n  ItemContext,\n  ListItemRendererContext,\n  Metadata,\n  Range,\n  SelectionDetail\n} from '../UNSAFE_Collection';\nimport { LoadMoreCollection, LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\nimport { VirtualizedCollection, PLACEHOLDER_STYLE_CLASS } from '../PRIVATE_VirtualizedCollection';\nimport { ViewportConfig } from '../hooks/UNSAFE_useViewportIntersect';\nimport { ListViewItem, ITEM_SELECTOR, MemoizeListViewItem } from './ListItem';\nimport { SelectionRangeDetail, useSelection } from '../hooks/PRIVATE_useSelection';\nimport { useCurrentKey } from '../hooks/PRIVATE_useCurrentKey';\nimport { useCollectionFocusRing } from '../hooks/PRIVATE_useCollectionFocusRing';\nimport { useTabbableModeSet } from '../hooks/PRIVATE_useTabbableModeSet';\nimport { useItemAction } from '../hooks/PRIVATE_useItemAction';\nimport { SkeletonContainer } from './SkeletonContainer';\nimport { Skeleton } from '../UNSAFE_Skeleton';\nimport { Flex } from '../UNSAFE_Flex';\nimport {\n  getFirstVisibleKey,\n  getPrevNextKey,\n  findElementByKey,\n  keyExtractor\n} from '../utils/PRIVATE_collectionUtils';\nimport { Selector } from '../UNSAFE_Selector';\nimport { Props } from '../UNSAFE_ListView';\nimport { getListViewRoles } from './ListRoles';\nimport { findSuggestions, Sparkle } from './Sparkle';\nimport { useCollectionGestureContext } from '../hooks/PRIVATE_useCollectionGestureContext';\nimport { listStyles } from './themes/ListStyles.css';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\nimport { Menu } from '../UNSAFE_Menu';\nimport { useContextMenuGesture } from '../hooks/UNSAFE_useContextMenuGesture';\nimport { ListContextMenuContext } from '../UNSAFE_ListView/List.types';\n\ntype MenuProps = Pick<\n  ComponentProps<typeof Menu>,\n  'anchorRef' | 'initialFocus' | 'placement' | 'offsetValue' | 'isOpen'\n>;\n\nconst TOUCH_OFFSET_VALUE = 40;\n\nconst menuPropGestureStates: Record<\n  'mouse' | 'keyboard' | 'touch',\n  Omit<Required<MenuProps>, 'anchorRef' | 'isOpen'>\n> = {\n  mouse: {\n    initialFocus: 'menu',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  keyboard: {\n    initialFocus: 'firstItem',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  touch: {\n    initialFocus: 'menu',\n    placement: 'end',\n    offsetValue: TOUCH_OFFSET_VALUE\n  }\n};\n\nconst initialMenuProps: MenuProps = {\n  isOpen: false,\n  initialFocus: 'menu',\n  placement: 'bottom-start',\n  offsetValue: 0,\n  anchorRef: { current: null }\n};\n\n/**\n * Component that renders items as a flat list.\n * In order to maximize performance, only items that are visible in the viewport are rendered.\n */\nexport function List<K extends string | number, D>({\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  allowTabbableMode = true,\n  children,\n  currentKey,\n  data,\n  gridlines,\n  loadingIndicator = defaultLoadingIndicator,\n  onCurrentKeyChange,\n  onLoadRange,\n  onSelectionChange,\n  onItemAction,\n  rangeExtractor,\n  role = 'grid',\n  selectedKeys = emptyKeys as Keys<K>,\n  selectionMode = 'none',\n  viewportConfig,\n  currentItemVariant = 'none',\n  promotedSection,\n  isVirtualized = true,\n  customItemRenderer,\n  scrollToVisibleOffset,\n  testId,\n  contextMenuRenderer,\n  ...props\n}: Props<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const listRoles = useMemo(() => getListViewRoles(role), [role]);\n\n  // tracking the anchor key which is used for shift+click selection\n  const anchorKey = useRef<K | undefined>();\n\n  // tracking pending selection/current key that is not in current data\n  const pendingSelection = useRef<{ detail: SelectionRangeDetail<K>; range: Range }>();\n  const pendingCurrentKey = useRef<K>();\n\n  const [active, setActive] = useState<boolean>(false);\n\n  // tracking sparkle height\n  const [sparkleHeight, setSparkleHeight] = useState<number>(0);\n\n  const showGridline = (index: number) => {\n    // show bottom gridlines for each item, and for the last item if specified\n    return (\n      gridlines?.item === 'visible' &&\n      (index + 1 !== data?.totalSize || gridlines?.bottom === 'visible')\n    );\n  };\n\n  const showGridlineTop = () => {\n    // show the top gridline for the first item\n    return gridlines?.item === 'visible' && gridlines?.top === 'visible';\n  };\n\n  const ariaMultiSelectable = selectionMode === 'none' ? undefined : selectionMode === 'multiple';\n  const ariaRowCount =\n    data === null ? undefined : data.sizePrecision === 'exact' ? data.totalSize : -1;\n\n  const classes = classNames([listStyles.base]);\n\n  const { currentKeyProps } = useCurrentKey(\n    (element) => keyExtractor(element, ITEM_SELECTOR),\n    selectionMode !== 'multiple',\n    getPrevNextKey(rootRef.current, currentKey, true, ITEM_SELECTOR),\n    getPrevNextKey(rootRef.current, currentKey, false, ITEM_SELECTOR),\n    undefined,\n    undefined,\n    currentKey,\n    onCurrentKeyChange\n  );\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(rootRef, ['ArrowUp', 'ArrowDown']);\n\n  const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet(\n    rootRef,\n    (element) => {\n      // we don't want List to go into Tabbable mode when user clicks on expander\n      return isExpander(element) ? null : (keyExtractor(element, ITEM_SELECTOR) as K);\n    },\n    currentKey,\n    onCurrentKeyChange\n  );\n\n  useEffect(() => {\n    if (currentKey != null && rootRef.current) {\n      const elem = findElementByKey(rootRef.current, currentKey, ITEM_SELECTOR);\n      if (elem) {\n        const activeDescendant = rootRef.current.getAttribute('aria-activedescendant');\n        const cell = elem.querySelector(`[role=${listRoles.cell}]`);\n        if (cell && activeDescendant !== cell.id) {\n          // update aria-activedescendant for screenreader\n          rootRef.current.setAttribute('aria-activedescendant', cell.id);\n\n          const scroller = viewportConfig?.scroller();\n          const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;\n          // make sure item is visible\n          scrollToVisible(elem, scroller != null ? scroller : rootRef.current, offset);\n        }\n      }\n    }\n    // listen to data because the current item would re-render when the virtualizer\n    // is fetching data or updating the data, i.e. the id of current item would be updated,\n    // so the currentKey itself couldn't guarantee the root has latest aria-activedescendant\n  }, [currentKey, data, listRoles.cell, viewportConfig, scrollToVisibleOffset]);\n\n  const handleSelectionChange = useCallback(\n    (detail: SelectionDetail<K>) => {\n      if (onSelectionChange) {\n        if (detail.value.all === false && detail.value.keys.size > 0) {\n          // the last key selected by a user gesture is the anchor key\n          anchorKey.current = Array.from(detail.value.keys.values()).pop();\n        }\n        onSelectionChange(detail);\n      }\n    },\n    [anchorKey, onSelectionChange]\n  );\n\n  const handleSelectionRangeChange = useCallback(\n    (detail: SelectionRangeDetail<K>) => {\n      if (data && onSelectionChange) {\n        const value = handleSelectionRange(detail, data);\n        if (Array.isArray(value)) {\n          // the last key selected by a user gesture is the anchor key\n          anchorKey.current = Array.from(value).pop();\n          onSelectionChange({ value: { all: false, keys: new Set(value) }, target: null });\n        } else {\n          pendingSelection.current = {\n            detail: detail,\n            range: { offset: data.offset, count: data.data.length }\n          };\n          onLoadRange(value);\n        }\n      }\n    },\n    [data, onSelectionChange, onLoadRange]\n  );\n\n  const handleInitialFocus = useCallback(() => {\n    if (\n      rootRef.current &&\n      onCurrentKeyChange &&\n      (!allowTabbableMode || isCurrentTabbableKey(undefined))\n    ) {\n      const firstKey =\n        pendingCurrentKey.current || (getFirstVisibleKey(rootRef.current, ITEM_SELECTOR) as K);\n      if (isKeyDefined(firstKey)) {\n        onCurrentKeyChange({ value: firstKey });\n      }\n    }\n  }, [allowTabbableMode, onCurrentKeyChange, isCurrentTabbableKey]);\n\n  /**\n   * Used by allowTabbableMode = false, to prevent focus from getting onto checkboxes on click\n   * @param event\n   */\n  const handleSelectorFocusCapture = useCallback(\n    (event: FocusEvent) => {\n      const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n      if (\n        isKeyDefined(key) &&\n        (event.relatedTarget as HTMLElement)?.getAttribute('type') === 'checkbox'\n      ) {\n        rootRef.current?.focus();\n        if (onCurrentKeyChange && isKeyDefined(key)) {\n          onCurrentKeyChange({ value: key as K });\n        }\n      }\n    },\n    [onCurrentKeyChange]\n  );\n\n  const handleFocus = useCallback(\n    (event: FocusEvent) => {\n      if (isExpander(event.target as HTMLElement)) {\n        rootRef.current?.focus();\n        const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n        if (onCurrentKeyChange && isKeyDefined(key)) {\n          onCurrentKeyChange({ value: key as K });\n        }\n        return;\n      }\n      !isKeyDefined(currentKey) && onCurrentKeyChange && handleInitialFocus();\n      !allowTabbableMode && handleSelectorFocusCapture(event);\n    },\n    [\n      allowTabbableMode,\n      currentKey,\n      handleInitialFocus,\n      handleSelectorFocusCapture,\n      onCurrentKeyChange\n    ]\n  );\n\n  const value = useCollectionGestureContext();\n\n  const { selectionProps } = useSelection(\n    (element: HTMLElement) => {\n      if (element === rootRef.current) {\n        return currentKey === undefined ? null : currentKey;\n      }\n      return keyExtractor(element, ITEM_SELECTOR) as K;\n    },\n    selectedKeys,\n    selectionMode,\n    false,\n    'replace',\n    value === 'embedded',\n    handleSelectionChange,\n    anchorKey.current,\n    currentKey,\n    (currentKey: K | undefined, isPrev: boolean) =>\n      getPrevNextKey(rootRef.current, currentKey, isPrev, ITEM_SELECTOR),\n    undefined,\n    (key: K) => {\n      if (rootRef.current) {\n        const elem = findElementByKey(rootRef.current, key, ITEM_SELECTOR);\n        if (elem) {\n          const scroller = viewportConfig?.scroller();\n          const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;\n          scrollToVisible(elem, scroller != null ? scroller : rootRef.current, offset);\n        }\n      }\n    },\n    handleSelectionRangeChange\n  );\n\n  if (data && pendingSelection.current !== undefined && onSelectionChange) {\n    const keys = handleSelectionRange(pendingSelection.current.detail, data);\n    if (Array.isArray(keys)) {\n      onSelectionChange({ value: { all: false, keys: new Set(keys) }, target: null });\n    }\n    const range = pendingSelection.current\n      ? pendingSelection.current.range\n      : { offset: data.offset, count: data.data.length };\n    data = adjustDataState(data, range);\n    pendingSelection.current = undefined;\n    onLoadRange(range);\n  }\n\n  const suggestions = useMemo(\n    () => data && promotedSection && findSuggestions(data.data, promotedSection.count),\n    [data, promotedSection]\n  );\n\n  // TODO: check suggestions before Sparkle would cause a scrolling issue\n  const sparkleIndicator = <Sparkle sparkleHeight={sparkleHeight}></Sparkle>;\n\n  const itemActionProps = useItemAction(\n    currentKey,\n    data,\n    onItemAction,\n    ITEM_SELECTOR,\n    value === 'embedded'\n  );\n\n  useEffect(() => {\n    // update sparkleHeight only when we have suggestions\n    // avoid unnecessary iterating through elements\n    if (suggestions) {\n      const placeholder = rootRef.current?.querySelector(\n        '.' + PLACEHOLDER_STYLE_CLASS\n      ) as HTMLElement;\n      let height = placeholder?.offsetHeight || 0;\n      const suggestionItems = rootRef.current?.querySelectorAll('[data-oj-suggestion]');\n      suggestionItems?.forEach((item) => (height += (item as HTMLElement).offsetHeight));\n      setSparkleHeight(height);\n    }\n  }, [suggestions]);\n\n  // returns an ListItemContext based on ItemContext (added metadata and selector)\n  const getItemContext = useCallback(\n    (context: ItemContext<{ data: D; metadata: Metadata<K> }>) => {\n      const selectorRenderer =\n        selectionMode === 'multiple'\n          ? () => (\n              <Selector\n                onChange={handleSelectionChange}\n                rowKey={context.data.metadata.key}\n                selectedKeys={selectedKeys}></Selector>\n            )\n          : undefined;\n\n      return {\n        index: context.index,\n        data: context.data.data,\n        metadata: context.data.metadata,\n        selector: selectorRenderer\n      };\n    },\n    [selectionMode, selectedKeys, handleSelectionChange]\n  );\n\n  const ItemComponent = isVirtualized ? ListViewItem : MemoizeListViewItem;\n\n  const childrenComponent = (context: ItemContext<{ data: D; metadata: Metadata<K> }>) => {\n    const listItemContext = getItemContext(context);\n    const suggestion = suggestions?.get(listItemContext.metadata.key);\n    const isTabbable = allowTabbableMode && isCurrentTabbableKey(listItemContext.metadata.key);\n    const isFocused = currentKey === listItemContext.metadata.key && !isTabbable;\n    const isActive = isFocused && active;\n    const isSelected = containsKey(selectedKeys, listItemContext.metadata.key);\n    const isFocusRingVisible = isFocused && showFocusRing;\n    const listItemFunc = (ctx: ListItemRendererContext<K, D>, otherProps?: any) => (\n      <ItemComponent\n        key={listItemContext.metadata.key}\n        context={ctx}\n        isFocused={isFocused}\n        isFocusRingVisible={isFocusRingVisible}\n        isActive={isActive}\n        isGridlineVisible={showGridline(listItemContext.index)}\n        isSelected={isSelected}\n        isTabbable={allowTabbableMode && isCurrentTabbableKey(listItemContext.metadata.key)}\n        role={role}\n        selectionMode={selectionMode}\n        currentItemVariant={currentItemVariant}\n        {...(suggestion && { suggestion })}\n        {...(listItemContext.index === 0 && { isTopGridlineVisible: showGridlineTop() })}\n        {...otherProps}>\n        {children}\n      </ItemComponent>\n    );\n\n    // if customItemRenderer is specified (ExpandableList and GroupedList)\n    // create a custom context with additional info including a function\n    // that helps create the default item component\n    if (customItemRenderer) {\n      const customRendererContext = {\n        listItemContext,\n        isFocused,\n        isFocusRingVisible,\n        isSelected,\n        isTabbable,\n        isActive,\n        defaultListItem: listItemFunc\n      };\n      return customItemRenderer(customRendererContext);\n    }\n    return listItemFunc(listItemContext);\n  };\n\n  viewportConfig = getViewportConfig(rootRef, viewportConfig);\n\n  /**\n   * Need to track pointer down element to set currentItem when initial focus happens\n   */\n  const handlePointerDown = useCallback((event: PointerEvent) => {\n    const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n    if (isKeyDefined(key)) {\n      pendingCurrentKey.current = key as K;\n    }\n  }, []);\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (event.key === ' ' && isKeyDefined(currentKey) && selectionMode !== 'none') {\n        setActive(true);\n      }\n    },\n    [currentKey, selectionMode, setActive]\n  );\n\n  const handleKeyUp = useCallback(() => {\n    setActive(false);\n  }, [setActive]);\n\n  /*Context Menu section\n   TODO: A version of context Menu listview will be merged using useContextMenuGesture instead. Once it's merged we \n   can go back to this to create a hook or utility that could be share among all collection comps. JET-60320\n  */\n\n  /* \n  Steps to open a menu:\n    1.- useContextMenu handler is called when menu is supposed to be opened.\n    2.- We set contextMenuContext when contextMenuRenderer is called.\n    3.- We dispatch opening the menu with the correct anchor.\n    5.- Menu receives updated props and updated contextMenuContext.\n    6.- Menu is opened.  \n\n    */\n\n  //Supposed to be updated when menu is about to be opened\n  //We set an initial key value for the context menu context, to allow user use object destructuring inside the\n  //contextMenuRenderer. It doesn't matter if the key is not correct at the initial rendering since menu starts\n  //being closed always\n  const [contextMenuContext, setContextMenuContext] = useState<ListContextMenuContext<K>>({\n    key: '' as K\n  });\n\n  const [menuProps, setMenuProps] = useState<MenuProps>(initialMenuProps);\n\n  const { triggerProps } = useContextMenuGesture(\n    ({ gesture, anchor, target }) => {\n      let anchorBasedOnGesture = anchor;\n      if (gesture === 'keyboard') {\n        //We find the element where the position of the menu is going to be based of\n        const elem = findElementByKey(\n          rootRef.current as HTMLElement,\n          currentKey as string,\n          ITEM_SELECTOR\n        );\n\n        //We set the correct anchor\n        anchorBasedOnGesture = elem ? elem : anchor;\n\n        setContextMenuContext({ key: currentKey as K });\n      } else {\n        //We search for the key using the target of the event\n        const key = keyExtractor(target as HTMLElement, ITEM_SELECTOR);\n\n        setContextMenuContext({ key: key as K });\n\n        //We update the key so when we close logical focus is on the correct item\n        //TODO: Do this directly in useCurrentKey.JET-62373\n        onCurrentKeyChange?.({ value: key as K });\n      }\n      setMenuProps({\n        ...menuPropGestureStates[gesture],\n        anchorRef: { current: anchorBasedOnGesture },\n        isOpen: true\n      });\n    },\n    {\n      isDisabled: !contextMenuRenderer //If there is no a context menu renderer we disable the hook\n    }\n  );\n\n  const handleCloseContextMenu = useCallback<Required<ComponentProps<typeof Menu>>['onClose']>(\n    (detail) => {\n      /* \n      TODO: Focus ring should be visible when context menu was closed because of selecting an item using keyboard, \n      but should not be visible when the selection was done using mouse or touch. This would probably means menu \n      onClose API is going to be changed a little bit so we can satisfy this requirement. JET-62372\n      */\n      //Focus has to be set on the current target that was obtained\n      //during context menu gesture when menu is dismissed or item is \"selected\"\n      if (detail.reason === 'dismissed' || detail.reason === 'itemAction') {\n        rootRef.current?.focus();\n      }\n      // We close the menu.The only prop that matters here is isOpen\n      setMenuProps({ ...initialMenuProps });\n    },\n    []\n  );\n\n  // if data is not specified, listview should show loading indicator\n  // todo: replace placeholder with actual SkeletonContainer component (Ash is working on)\n  const testIdProps = useTestId(testId);\n  return (\n    <>\n      <div\n        {...mergeProps(\n          allowTabbableMode ? tabbableModeProps : {},\n          currentKeyProps,\n          focusRingProps,\n          selectionProps,\n          itemActionProps,\n          triggerProps,\n          {\n            onFocus: handleFocus,\n            onPointerDown: handlePointerDown,\n            onKeyDown: handleKeyDown,\n            onKeyUp: handleKeyUp\n          },\n          props\n        )}\n        {...testIdProps}\n        role={role}\n        aria-rowcount={ariaRowCount}\n        aria-colcount={1}\n        ref={rootRef}\n        class={classes}\n        tabIndex={0}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-multiselectable={ariaMultiSelectable}>\n        {data == null ? (\n          loadingIndicator\n        ) : isVirtualized ? (\n          <VirtualizedCollection\n            data={data}\n            itemSelector={ITEM_SELECTOR}\n            loadMoreIndicator={defaultLoadMoreIndicator}\n            onLoadRange={onLoadRange}\n            rangeExtractor={rangeExtractor}\n            suggestions={sparkleIndicator}\n            viewportConfig={viewportConfig}>\n            {childrenComponent}\n          </VirtualizedCollection>\n        ) : (\n          <LoadMoreCollection\n            data={data.data}\n            loadMoreIndicator={defaultLoadMoreIndicator}\n            hasMore={data.sizePrecision === 'atLeast' && data.data.length <= data.totalSize}\n            onLoadMore={() => {\n              data && onLoadRange({ offset: 0, count: data.data.length + 25 });\n            }}\n            suggestions={sparkleIndicator}\n            viewportConfig={viewportConfig}>\n            {childrenComponent}\n          </LoadMoreCollection>\n        )}\n      </div>\n      {contextMenuRenderer && (\n        <Menu {...menuProps} onClose={handleCloseContextMenu}>\n          {contextMenuRenderer(contextMenuContext as ListContextMenuContext<K>)}\n        </Menu>\n      )}\n    </>\n  );\n}\n\nconst isExpander = (elem: HTMLElement) => {\n  if (elem.parentElement && elem.parentElement.classList.contains('oj-listview-expander')) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nconst scrollToVisible = (elem: Element, scroller: Element, offset: number) => {\n  if (elem && scroller) {\n    if ((elem as any).scrollIntoViewIfNeeded) {\n      // for Safari, we'll need the non-standard scrollIntoViewIfNeeded\n      (elem as any).scrollIntoViewIfNeeded();\n    } else {\n      elem.scrollIntoView({ block: 'nearest' });\n    }\n    if (offset > 0) {\n      const scrollerBounds = scroller.getBoundingClientRect();\n      const elemBounds = elem.getBoundingClientRect();\n      const diff = scrollerBounds.top + offset - elemBounds.top;\n      if (diff > 0) {\n        scroller.scrollTop = scroller.scrollTop - diff;\n      }\n    }\n  }\n};\n\nconst getViewportConfig = (rootRef: RefObject<HTMLElement>, config?: ViewportConfig) => {\n  return (\n    config ?? {\n      scroller: () => {\n        return rootRef.current;\n      }\n    }\n  );\n};\n\nconst emptyKeys = { all: false, keys: new Set() };\n\nconst handleSelectionRange = <K, D>(\n  detail: SelectionRangeDetail<K>,\n  dataState: DataState<K, D>\n) => {\n  const keys = dataState.data.map((value: { data: D; metadata: Metadata<K> }) => {\n    return value.metadata.key;\n  });\n  const startIndex = keys.indexOf(detail.value.start);\n  const endIndex = keys.indexOf(detail.value.end);\n  const minIndex = Math.min(startIndex, endIndex);\n  const maxIndex = Math.max(startIndex, endIndex);\n  if (minIndex === -1) {\n    // return a range to fetch so we can find all the keys, maxIndex should not be -1\n    return { offset: 0, count: dataState.totalSize };\n  } else {\n    // range of keys are in the current viewport, return them\n    return keys.slice(minIndex, maxIndex + 1);\n  }\n};\n\nconst defaultLoadingIndicator = (\n  <SkeletonContainer minimumCount={25}>\n    {() => {\n      return (\n        <Flex height=\"12x\" align=\"center\">\n          <Skeleton height=\"4x\" />\n        </Flex>\n      );\n    }}\n  </SkeletonContainer>\n);\n\nconst defaultLoadMoreIndicator = (\n  <div class={LOADMORE_STYLE_CLASS}>\n    <SkeletonContainer minimumCount={3}>\n      {() => {\n        return (\n          <Flex height=\"12x\" align=\"center\">\n            <Skeleton height=\"4x\" />\n          </Flex>\n        );\n      }}\n    </SkeletonContainer>\n  </div>\n);\n\n/**\n * Adjust the DataState as needed if it contains more than needed for the specified range\n */\nconst adjustDataState = <K, D>(dataState: DataState<K, D>, range: Range | null) => {\n  if (range) {\n    // prevent range offset from being larger than the data state\n    const safeRangeOffset = Math.min(range.offset, dataState.offset + dataState.totalSize);\n    const diff = safeRangeOffset - dataState.offset;\n    if (diff > 0) {\n      dataState = {\n        offset: safeRangeOffset,\n        data: dataState.data.slice(diff, diff + range.count),\n        totalSize: dataState.totalSize,\n        sizePrecision: dataState.sizePrecision\n      };\n    }\n  }\n  return dataState;\n};\n"],"names":["getListViewRoles","ariaRole","list","item","cell","ITEM_SELECTOR","ListViewItem","children","context","itemDepth","isFocused","isFocusRingVisible","isActive","isGridlineVisible","isSelected","isTopGridlineVisible","isTabbable","role","selectionMode","suggestion","currentItemVariant","rootRef","useRef","roles","useMemo","itemKey","metadata","key","itemIndex","index","cellRoleAttributes","interactionProps","applyActiveStyle","applyHoverStyle","applyPseudoHoverStyle","useInteractionStyle","variantClasses","listItemMultiVariantStyles","selectable","isSelectable","selected","selectedSingle","needsEventsHover","pseudoHover","active","focusHighlight","focusRingVisible","gridlineTop","gridlineBottom","classes","classNames","styleInterpolations","mergeInterpolations","Object","values","flexitemInterpolations","class","cls","cellStyles","flex","alignSelf","cellClasses","listItemStyles","checkboxContainer","_jsx","jsx","ref","id","useId","style","onKeyDown","event","stopPropagation","undefined","TabbableModeContext","Provider","value","FocusTrap","isDisabled","restoreFocusRef","isItemSelected","MemoizeListViewItem","memo","prev","next","compareListItemContext","SkeletonContainer","minimumCount","isVisible","setIsVisible","useState","useEffect","setTimeout","containerClasses","skeletonStyles","container","Array","map","_element","SPARKLE_STYLE_CLASS","Sparkle","sparkleHeight","name","useTheme","height","sparkleClasses","sparkleStyles","base","globalImages","menuPropGestureStates","mouse","initialFocus","placement","offsetValue","keyboard","touch","initialMenuProps","isOpen","anchorRef","current","isExpander","elem","parentElement","classList","contains","scrollToVisible","scroller","offset","scrollIntoViewIfNeeded","scrollIntoView","block","scrollerBounds","getBoundingClientRect","elemBounds","diff","top","scrollTop","getViewportConfig","config","emptyKeys","all","keys","Set","handleSelectionRange","detail","dataState","data","startIndex","indexOf","start","endIndex","end","minIndex","Math","min","maxIndex","max","count","totalSize","slice","defaultLoadingIndicator","Flex","align","Skeleton","defaultLoadMoreIndicator","LOADMORE_STYLE_CLASS","adjustDataState","range","safeRangeOffset","sizePrecision","ariaLabel","ariaLabelledBy","allowTabbableMode","currentKey","gridlines","loadingIndicator","onCurrentKeyChange","onLoadRange","onSelectionChange","onItemAction","rangeExtractor","selectedKeys","viewportConfig","promotedSection","isVirtualized","customItemRenderer","scrollToVisibleOffset","testId","contextMenuRenderer","props","listRoles","anchorKey","pendingSelection","pendingCurrentKey","setActive","setSparkleHeight","ariaMultiSelectable","ariaRowCount","listStyles","currentKeyProps","useCurrentKey","element","keyExtractor","getPrevNextKey","showFocusRing","focusRingProps","useCollectionFocusRing","isCurrentTabbableKey","tabbableModeProps","useTabbableModeSet","findElementByKey","activeDescendant","getAttribute","querySelector","setAttribute","handleSelectionChange","useCallback","size","from","pop","handleSelectionRangeChange","isArray","target","length","handleInitialFocus","firstKey","getFirstVisibleKey","isKeyDefined","handleSelectorFocusCapture","relatedTarget","focus","handleFocus","useCollectionGestureContext","selectionProps","useSelection","isPrev","suggestions","reduce","set","Map","findSuggestions","sparkleIndicator","itemActionProps","useItemAction","placeholder","PLACEHOLDER_STYLE_CLASS","offsetHeight","suggestionItems","querySelectorAll","forEach","getItemContext","selectorRenderer","Selector","onChange","rowKey","selector","ItemComponent","childrenComponent","listItemContext","get","containsKey","listItemFunc","ctx","otherProps","bottom","defaultListItem","handlePointerDown","handleKeyDown","handleKeyUp","contextMenuContext","setContextMenuContext","menuProps","setMenuProps","triggerProps","useContextMenuGesture","gesture","anchor","anchorBasedOnGesture","handleCloseContextMenu","reason","testIdProps","useTestId","_jsxs","_Fragment","mergeProps","onFocus","onPointerDown","onKeyUp","tabIndex","VirtualizedCollection","itemSelector","loadMoreIndicator","LoadMoreCollection","hasMore","onLoadMore","Menu","onClose"],"mappings":"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"}