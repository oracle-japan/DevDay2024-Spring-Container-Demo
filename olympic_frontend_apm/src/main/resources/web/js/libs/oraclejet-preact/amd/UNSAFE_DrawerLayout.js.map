{"version":3,"file":"UNSAFE_DrawerLayout.js","sources":["../../src/UNSAFE_DrawerLayout/DrawerLayout.tsx"],"sourcesContent":["import { JSX, ComponentChildren, RefObject } from 'preact';\nimport { useState, useRef, useEffect } from 'preact/hooks';\nimport { normalizePosition } from '../utils/PRIVATE_floatingUtils';\nimport { RtlSide } from '../UNSAFE_Floating';\n\n// Hooks\nimport { useAnimation } from '../hooks/UNSAFE_useAnimation';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { useBreakpointValues } from '../hooks/UNSAFE_useBreakpointValues';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { DrawerLayoutStyles } from './themes/DrawerLayoutStyles.css';\nimport { DrawerLayoutRedwoodTheme } from './themes/redwood/DrawerLayoutTheme';\n\n// Types\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\ntype Placement = 'start' | 'end' | 'bottom';\ntype Status = 'unmounted' | 'initial' | 'opening' | 'open' | 'closing';\n\ntype OnCloseDetail = {\n  placement: Placement;\n  reason: 'escapeKey';\n};\ntype OnTransitionEndDetail = {\n  placement: Placement;\n  value: boolean;\n};\ntype DisplayMode = 'overlay' | 'reflow';\ntype ResolvedDisplayMode = 'full-overlay' | 'overlay' | 'reflow';\ntype Visibility = 'hidden' | 'visible';\n\ntype Props = IntrinsicProps & {\n  /**\n   * The content node to be shown within the Start Drawer\n   */\n  startDrawer?: ComponentChildren;\n  /**\n   * The content node to be shown within the End Drawer\n   */\n  endDrawer?: ComponentChildren;\n  /**\n   * The content node to be shown within the Bottom Drawer\n   */\n  bottomDrawer?: ComponentChildren;\n  /**\n   * Specifies whether Start drawer is open.\n   */\n  isStartOpen?: boolean;\n  /**\n   * Specifies the display mode of the Start drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  startDisplay?: DisplayMode | undefined;\n  /**\n   * Specifies whether End drawer is open.\n   */\n  isEndOpen?: boolean;\n  /**\n   * Specifies the display mode of the End drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  endDisplay?: DisplayMode | undefined;\n  /**\n   * Specifies whether Bottom drawer is open.\n   */\n  isBottomOpen?: boolean;\n  /**\n   * Specifies the display mode of the Bottom drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  bottomDisplay?: DisplayMode | undefined;\n  /**\n   * Specifies callback triggered when a user tries to close a Drawer through UI interaction.\n   * The parent should listen to this event and close the Drawer. If the parent fails to remove\n   * the Popup, then no change will be done in the UI by the component.\n   *\n   * Supported detail values are:\n   * <p><code>placement: start | end | bottom</code></p>\n   * <p><code>reason: escapeKey</code></p>\n   */\n  onClose?: (detail: OnCloseDetail) => void;\n  /**\n   * Specifies callback triggered after the animation ends.\n   *\n   * Supported detail values are:\n   * <p><code>placement: start | end | bottom</code></p>\n   * <p><code>value: boolean</code></p>\n   */\n  onTransitionEnd?: (detail: OnTransitionEndDetail) => void;\n} & TestIdProps;\n\n/**\n * A drawer layout adds expandable side contents (drawers) alongside some primary content.\n *\n * These drawers automatically swap 'reflow' and 'overlay' display mode based on width of the page and can be placed at the 'start', 'end' or 'bottom' edge.\n */\nexport const DrawerLayout = ({\n  children,\n  startDrawer,\n  endDrawer,\n  bottomDrawer,\n  isStartOpen = false,\n  isEndOpen = false,\n  isBottomOpen = false,\n  startDisplay,\n  endDisplay,\n  bottomDisplay,\n  onClose,\n  onTransitionEnd,\n  testId // ...props\n}: Props) => {\n  // Constants\n  const zero = '0px';\n  const duration = 250;\n  const stringStart = 'start';\n  const stringEnd = 'end';\n  const stringBottom = 'bottom';\n  const stringInitial = 'initial';\n  const stringOpening = 'opening';\n  const stringOpen = 'open';\n  const stringClosing = 'closing';\n  const stringUnmounted = 'unmounted';\n  const stringFullOverlay = 'full-overlay';\n  const stringOverlay = 'overlay';\n  const stringReflow = 'reflow';\n  const stringHidden = 'hidden';\n  const stringVisible = 'visible';\n\n  // Initialize states\n  const [startDrawerStatus, setStartDrawerStatus] = useState<Status>(\n    isStartOpen ? stringInitial : stringUnmounted\n  );\n  const [endDrawerStatus, setEndDrawerStatus] = useState<Status>(\n    isEndOpen ? stringInitial : stringUnmounted\n  );\n  const [bottomDrawerStatus, setBottomDrawerStatus] = useState<Status>(\n    isBottomOpen ? stringInitial : stringUnmounted\n  );\n  const [startVisibility, setStartVisibility] = useState<Visibility>(stringHidden);\n  const [endVisibility, setEndVisibility] = useState<Visibility>(stringHidden);\n  const [bottomVisibility, setBottomVisibility] = useState<Visibility>(stringHidden);\n\n  // Breakpoints:\n  // sm: 0-600px (full-overlay)\n  // md: 600-1024px (overlay)\n  // lg: >1024px (reflow)\n  const displayMode: ResolvedDisplayMode = useBreakpointValues({\n    sm: 'full-overlay',\n    md: 'overlay',\n    lg: 'reflow'\n  });\n  const [viewportDisplayMode, setViewportDisplayMode] = useState<ResolvedDisplayMode>(displayMode);\n  useEffect(() => {\n    // Size breakpoint crossed\n    setViewportDisplayMode(displayMode);\n  }, [displayMode]);\n\n  // Refs\n  const startDrawerRef = useRef<HTMLDivElement>(null);\n  const endDrawerRef = useRef<HTMLDivElement>(null);\n  const bottomDrawerRef = useRef<HTMLDivElement>(null);\n\n  const getElementHeight = (element: HTMLDivElement): number => {\n    return Math.round(element.offsetHeight);\n  };\n\n  const getElementWidth = (element: HTMLDivElement): number => {\n    return Math.round(element.getBoundingClientRect().width);\n  };\n\n  // Normalizing position\n  const { direction } = useUser();\n  const isLtr = direction === 'ltr';\n\n  const getNormalizedPlacement = (placement: Placement): RtlSide => {\n    return normalizePosition(placement, direction);\n  };\n\n  const getTranslateX = (placement: Placement, ref: any): string => {\n    return `${getNormalizedPlacement(placement) === 'right' ? '' : '-'}${getElementWidth(\n      ref.current as HTMLDivElement\n    )}px`;\n  };\n\n  const getTranslateY = (ref: any): string => {\n    return `${getElementHeight(ref.current as HTMLDivElement)}px`;\n  };\n\n  const isBottomPlacement = (placement: Placement): boolean => {\n    return placement === stringBottom;\n  };\n\n  const isAnimationPending = (status: Status): boolean => {\n    return [stringOpening, stringClosing].indexOf(status) > -1;\n  };\n\n  const isDrawerAnimationPending = (placement: Placement): boolean => {\n    switch (placement) {\n      case stringStart:\n        return isAnimationPending(startDrawerStatus);\n      case stringEnd:\n        return isAnimationPending(endDrawerStatus);\n      case stringBottom:\n        return isAnimationPending(bottomDrawerStatus);\n    }\n  };\n\n  const isOverlayDisplayMode = (displayMode: ResolvedDisplayMode): boolean => {\n    return [stringFullOverlay, stringOverlay].indexOf(displayMode) > -1;\n  };\n\n  const getIsDrawerOpen = (placement: Placement): boolean => {\n    switch (placement) {\n      case stringStart:\n        return isStartOpen;\n      case stringEnd:\n        return isEndOpen;\n      case stringBottom:\n        return isBottomOpen;\n    }\n  };\n\n  const getDrawerVisibility = (placement: Placement): Visibility => {\n    switch (placement) {\n      case stringStart:\n        return startVisibility;\n      case stringEnd:\n        return endVisibility;\n      case stringBottom:\n        return bottomVisibility;\n    }\n  };\n\n  const setDrawerVisibility = (placement: Placement, visibility: Visibility): void => {\n    switch (placement) {\n      case stringStart:\n        return setStartVisibility(visibility);\n      case stringEnd:\n        return setEndVisibility(visibility);\n      case stringBottom:\n        return setBottomVisibility(visibility);\n    }\n  };\n\n  const getDrawerRef = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDrawerRef;\n      case stringEnd:\n        return endDrawerRef;\n      case stringBottom:\n        return bottomDrawerRef;\n    }\n  };\n\n  const getAnimatedNodeRef = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startAnimatedNodeRef;\n      case stringEnd:\n        return endAnimatedNodeRef;\n      case stringBottom:\n        return bottomAnimatedNodeRef;\n    }\n  };\n\n  const getDrawerStatus = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDrawerStatus;\n      case stringEnd:\n        return endDrawerStatus;\n      case stringBottom:\n        return bottomDrawerStatus;\n    }\n  };\n\n  const setDrawerStatus = (placement: Placement, status: Status): void => {\n    switch (placement) {\n      case stringStart:\n        setStartDrawerStatus(status);\n        break;\n      case stringEnd:\n        setEndDrawerStatus(status);\n        break;\n      case stringBottom:\n        setBottomDrawerStatus(status);\n        break;\n    }\n  };\n\n  const resetAnimatedNodeRef = (placement: Placement): void => {\n    switch (placement) {\n      case stringStart:\n        startAnimatedNodeRef(null);\n        break;\n      case stringEnd:\n        endAnimatedNodeRef(null);\n        break;\n      case stringBottom:\n        bottomAnimatedNodeRef(null);\n        break;\n    }\n  };\n\n  const getDrawerDisplayProp = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDisplay;\n      case stringEnd:\n        return endDisplay;\n      case stringBottom:\n        return bottomDisplay;\n    }\n  };\n\n  const getDrawerDisplayMode = (placement: Placement): ResolvedDisplayMode => {\n    const displayMode = getDrawerDisplayProp(placement);\n    return displayMode || viewportDisplayMode;\n  };\n\n  // Animation config\n  const getAnimationStates = (placement: Placement, ref: RefObject<HTMLElement>): any => {\n    const bottomPlacement: boolean = isBottomPlacement(placement);\n    if (getDrawerDisplayMode(placement) === stringReflow) {\n      // Reflow display mode\n      // Effect: Expand/Collapse\n      if (bottomPlacement) {\n        return {\n          opening: () => {\n            return {\n              from: {\n                maxHeight: zero,\n                overflowX: 'hidden'\n              },\n              to: {\n                maxHeight: `${getElementHeight(ref.current as HTMLDivElement)}px`,\n                overflowX: 'hidden'\n              },\n              options: {\n                duration: duration\n              }\n            };\n          },\n          closing: () => {\n            return {\n              from: {\n                maxHeight: `${getElementHeight(ref.current as HTMLDivElement)}px`\n              },\n              to: {\n                maxHeight: zero,\n                overflowX: 'hidden'\n              },\n              options: {\n                duration: duration\n              }\n            };\n          }\n        };\n      } else {\n        return {\n          opening: () => {\n            return {\n              from: {\n                maxWidth: zero,\n                overflowY: 'hidden'\n              },\n              to: {\n                maxWidth: `${getElementWidth(ref.current as HTMLDivElement)}px`,\n                overflowY: 'hidden'\n              },\n              options: {\n                duration: duration\n              }\n            };\n          },\n          closing: () => {\n            return {\n              from: {\n                maxWidth: `${getElementWidth(ref.current as HTMLDivElement)}px`\n              },\n              to: {\n                maxWidth: zero,\n                overflowY: 'hidden'\n              },\n              options: {\n                duration: duration\n              }\n            };\n          }\n        };\n      }\n    } else {\n      // FullOverlay or Overlay display mode\n      // Effect: Slidein/Slideout\n      if (bottomPlacement) {\n        return {\n          opening: () => {\n            return {\n              from: {\n                translateY: getTranslateY(ref)\n              },\n              to: {\n                translateY: zero\n              },\n              options: {\n                duration: duration\n              }\n            };\n          },\n          closing: () => {\n            return {\n              from: {\n                translateY: zero\n              },\n              to: {\n                translateY: getTranslateY(ref)\n              },\n              options: {\n                duration: duration\n              }\n            };\n          }\n        };\n      } else {\n        return {\n          opening: () => {\n            return {\n              from: {\n                translateX: getTranslateX(placement, ref)\n              },\n              to: {\n                translateX: zero\n              },\n              options: {\n                duration: duration\n              }\n            };\n          },\n          closing: () => {\n            return {\n              from: {\n                translateX: zero\n              },\n              to: {\n                translateX: getTranslateX(placement, ref)\n              },\n              options: {\n                duration: duration\n              }\n            };\n          }\n        };\n      }\n    }\n  };\n\n  // Custom hook to be shared for each side\n  // It can't be a function as a hook can only be called within a custom hook\n  function useNodeRef(placement: Placement, ref: RefObject<HTMLElement>) {\n    const isDrawerOpen: boolean = getIsDrawerOpen(placement);\n    const status = getDrawerStatus(placement);\n    return useAnimation<Status, HTMLDivElement>(status, {\n      animationStates: getAnimationStates(placement, ref),\n      isAnimatedOnMount: true,\n      onAnimationEnd: () => {\n        if (status === stringOpening) {\n          setDrawerStatus(placement, stringOpen);\n          onTransitionEnd?.({\n            placement: placement,\n            value: true\n          });\n        } else if (!isDrawerOpen) {\n          resetAnimatedNodeRef(placement);\n          setDrawerVisibility(placement, stringHidden);\n          setDrawerStatus(placement, stringUnmounted);\n          onTransitionEnd?.({\n            placement: placement,\n            value: false\n          });\n        }\n      }\n    }).nodeRef;\n  }\n\n  // Drawer refs\n  const startAnimatedNodeRef = useNodeRef(stringStart, startDrawerRef);\n  const endAnimatedNodeRef = useNodeRef(stringEnd, endDrawerRef);\n  const bottomAnimatedNodeRef = useNodeRef(stringBottom, bottomDrawerRef);\n\n  //testId support\n  const testIdProps = useTestId(testId);\n\n  // Custom hook to be shared for each side\n  // It can't be a function as a hook can only be called within a custom hook\n  function useDrawerStatus(placement: Placement): void {\n    const isDrawerOpen = getIsDrawerOpen(placement);\n    const drawerStatus = getDrawerStatus(placement);\n    useEffect(() => {\n      // 1. Ignore status update on initial render\n      if (drawerStatus === stringUnmounted && !isDrawerOpen) {\n        return;\n      }\n\n      // 2. Mount visually hidden component\n      // Component gets mounted, but will be visually hidden to avoid flickering\n      // Flickering happens because it gets rendered before animation hook repositions\n      // it in next render cycle\n      if (drawerStatus === stringUnmounted && isDrawerOpen) {\n        setDrawerStatus(placement, stringInitial);\n        return;\n      }\n\n      // 3. Setup animation\n      // Component has been mounted.\n      // We will kick out animation as node is already present in DOM.\n      // To avoid flickering, we still keep it visually hidden until the next render cycle.\n      if (drawerStatus === stringInitial && isDrawerOpen) {\n        const drawerRef = getDrawerRef(placement);\n        const animatedNodeRef = getAnimatedNodeRef(placement);\n        animatedNodeRef(drawerRef.current);\n        setDrawerStatus(placement, stringOpening);\n        return;\n      }\n\n      // 4. Unhide component. It becomes visible.\n      if (drawerStatus === stringOpening && isDrawerOpen) {\n        setDrawerVisibility(placement, stringVisible);\n        return;\n      }\n\n      // 5. Status 'open' is set in 'onAnimationEnd' handler\n\n      // 6. Closing\n      if (!isDrawerOpen) {\n        setDrawerStatus(placement, stringClosing);\n      }\n    }, [isDrawerOpen, drawerStatus, placement]);\n  }\n\n  // Drawers' status handler±\n  useDrawerStatus(stringStart);\n  useDrawerStatus(stringEnd);\n  useDrawerStatus(stringBottom);\n\n  // Keydown handlers\n  const handleKeyDownStart = (event: Event): void => {\n    handleKeyDown(stringStart, event);\n  };\n  const handleKeyDownEnd = (event: Event): void => {\n    handleKeyDown(stringEnd, event);\n  };\n  const handleKeyDownBottom = (event: Event): void => {\n    handleKeyDown(stringBottom, event);\n  };\n\n  const handleKeyDown = (placement: Placement, event: any): void => {\n    if (event.code === 'Escape') {\n      // Handle only in overlay mode\n      if (isOverlayDisplayMode(getDrawerDisplayMode(placement))) {\n        if (event.code === 'Escape') {\n          onClose?.({\n            placement,\n            reason: 'escapeKey'\n          });\n        }\n      }\n    }\n  };\n\n  // Styles\n  const { classes, styles } = useComponentTheme<never, DrawerLayoutStyles>(\n    DrawerLayoutRedwoodTheme\n  );\n\n  const getVisibilityClass = (visibility: Visibility) => {\n    return visibility === stringHidden ? styles.visibilityHidden : styles.visibilityVisible;\n  };\n\n  const getClassNames = (placement: Placement): string => {\n    const displayMode: ResolvedDisplayMode = getDrawerDisplayMode(placement);\n    const visibility = getDrawerVisibility(placement);\n    const visibilityClass = getVisibilityClass(visibility);\n    const animationPendingClass = isDrawerAnimationPending(placement) && styles.animatedDrawer;\n    switch (placement) {\n      case stringStart:\n        if (displayMode === stringFullOverlay) {\n          return classNames([\n            styles.overlayDrawer,\n            styles.fullOverlayDrawerSide,\n            isLtr && styles.overlayDrawerLeft,\n            !isLtr && styles.overlayDrawerRight,\n            visibilityClass,\n            animationPendingClass\n          ]);\n        } else if (displayMode === stringOverlay) {\n          return classNames([\n            styles.overlayDrawer,\n            styles.basicOverlayDrawerSide,\n            isLtr && styles.overlayDrawerLeft,\n            !isLtr && styles.overlayDrawerRight,\n            visibilityClass,\n            animationPendingClass\n          ]);\n        } else {\n          return classNames([\n            styles.reflowDrawer,\n            isLtr && styles.reflowDrawerLeft,\n            !isLtr && styles.reflowDrawerRight,\n            visibilityClass,\n            animationPendingClass\n          ]);\n        }\n      case stringEnd:\n        if (displayMode === stringFullOverlay) {\n          return classNames([\n            styles.overlayDrawer,\n            styles.fullOverlayDrawerSide,\n            isLtr && styles.overlayDrawerRight,\n            !isLtr && styles.overlayDrawerLeft,\n            visibilityClass,\n            animationPendingClass\n          ]);\n        } else if (displayMode === stringOverlay) {\n          return classNames([\n            styles.overlayDrawer,\n            styles.basicOverlayDrawerSide,\n            isLtr && styles.overlayDrawerRight,\n            !isLtr && styles.overlayDrawerLeft,\n            visibilityClass,\n            animationPendingClass\n          ]);\n        } else {\n          return classNames([\n            styles.reflowDrawer,\n            isLtr && styles.reflowDrawerRight,\n            !isLtr && styles.reflowDrawerLeft,\n            visibilityClass,\n            animationPendingClass\n          ]);\n        }\n      case stringBottom:\n        if ([stringOverlay, stringFullOverlay].indexOf(displayMode) > -1) {\n          return classNames([styles.overlayDrawer, styles.overlayDrawerBottom, visibilityClass]);\n        } else {\n          return classNames([\n            styles.reflowDrawer,\n            styles.reflowDrawerBottom,\n            visibilityClass,\n            animationPendingClass\n          ]);\n        }\n    }\n  };\n\n  const getDrawer = (placement: Placement): any => {\n    const isMounted = getDrawerStatus(placement) !== stringUnmounted;\n\n    if (isMounted) {\n      switch (placement) {\n        case stringStart:\n          return (\n            <div\n              ref={startDrawerRef}\n              className={getClassNames(stringStart)}\n              tabIndex={isOverlayDisplayMode(getDrawerDisplayMode(stringStart)) ? -1 : undefined}\n              onKeyDown={handleKeyDownStart}>\n              {startDrawer}\n            </div>\n          );\n        case stringEnd:\n          return (\n            <div\n              ref={endDrawerRef}\n              className={getClassNames(stringEnd)}\n              tabIndex={isOverlayDisplayMode(getDrawerDisplayMode(stringStart)) ? -1 : undefined}\n              onKeyDown={handleKeyDownEnd}>\n              {endDrawer}\n            </div>\n          );\n        case stringBottom:\n          return (\n            <div\n              ref={bottomDrawerRef}\n              className={getClassNames(stringBottom)}\n              tabIndex={isOverlayDisplayMode(getDrawerDisplayMode(stringStart)) ? -1 : undefined}\n              onKeyDown={handleKeyDownBottom}>\n              {bottomDrawer}\n            </div>\n          );\n      }\n    }\n    return null;\n  };\n\n  return (\n    <div className={classes} {...testIdProps}>\n      {getDrawer(stringStart)}\n      <div className={styles.centerSection}>\n        {/*center section*/}\n        <div className={styles.mainContent}>\n          {/*main section*/}\n          {children}\n        </div>\n        {getDrawer(stringBottom)}\n      </div>\n      {getDrawer(stringEnd)}\n    </div>\n  );\n};\n"],"names":["children","startDrawer","endDrawer","bottomDrawer","isStartOpen","isEndOpen","isBottomOpen","startDisplay","endDisplay","bottomDisplay","onClose","onTransitionEnd","testId","zero","duration","stringStart","stringEnd","stringBottom","stringInitial","stringOpening","stringClosing","stringUnmounted","stringFullOverlay","stringOverlay","stringHidden","startDrawerStatus","setStartDrawerStatus","useState","endDrawerStatus","setEndDrawerStatus","bottomDrawerStatus","setBottomDrawerStatus","startVisibility","setStartVisibility","endVisibility","setEndVisibility","bottomVisibility","setBottomVisibility","displayMode","useBreakpointValues","sm","md","lg","viewportDisplayMode","setViewportDisplayMode","useEffect","startDrawerRef","useRef","endDrawerRef","bottomDrawerRef","getElementHeight","element","Math","round","offsetHeight","getElementWidth","getBoundingClientRect","width","direction","useUser","isLtr","getTranslateX","placement","ref","normalizePosition","getNormalizedPlacement","current","getTranslateY","isAnimationPending","status","indexOf","isOverlayDisplayMode","getIsDrawerOpen","setDrawerVisibility","visibility","getDrawerStatus","setDrawerStatus","getDrawerDisplayMode","getDrawerDisplayProp","getAnimationStates","bottomPlacement","isBottomPlacement","opening","from","maxHeight","overflowX","to","options","closing","maxWidth","overflowY","translateY","translateX","useNodeRef","isDrawerOpen","useAnimation","animationStates","isAnimatedOnMount","onAnimationEnd","value","startAnimatedNodeRef","endAnimatedNodeRef","bottomAnimatedNodeRef","resetAnimatedNodeRef","nodeRef","testIdProps","useTestId","useDrawerStatus","drawerStatus","drawerRef","getDrawerRef","animatedNodeRef","getAnimatedNodeRef","handleKeyDownStart","event","handleKeyDown","handleKeyDownEnd","handleKeyDownBottom","code","reason","classes","styles","useComponentTheme","DrawerLayoutRedwoodTheme","getClassNames","getDrawerVisibility","visibilityClass","visibilityHidden","visibilityVisible","getVisibilityClass","animationPendingClass","isDrawerAnimationPending","animatedDrawer","classNames","overlayDrawer","fullOverlayDrawerSide","overlayDrawerLeft","overlayDrawerRight","basicOverlayDrawerSide","reflowDrawer","reflowDrawerLeft","reflowDrawerRight","overlayDrawerBottom","reflowDrawerBottom","getDrawer","_jsx","jsx","className","tabIndex","undefined","onKeyDown","_jsxs","centerSection","mainContent"],"mappings":"i4BA4G4B,EAC1BA,WACAC,cACAC,YACAC,eACAC,eAAc,EACdC,aAAY,EACZC,gBAAe,EACfC,eACAC,aACAC,gBACAC,UACAC,kBACAC,aAGA,MAAMC,EAAO,MACPC,EAAW,IACXC,EAAc,QACdC,EAAY,MACZC,EAAe,SACfC,EAAgB,UAChBC,EAAgB,UAEhBC,EAAgB,UAChBC,EAAkB,YAClBC,EAAoB,eACpBC,EAAgB,UAEhBC,EAAe,UAIdC,EAAmBC,GAAwBC,EAAQA,SACxDvB,EAAcc,EAAgBG,IAEzBO,EAAiBC,GAAsBF,EAAQA,SACpDtB,EAAYa,EAAgBG,IAEvBS,EAAoBC,GAAyBJ,EAAQA,SAC1DrB,EAAeY,EAAgBG,IAE1BW,EAAiBC,GAAsBN,EAAQA,SAAaH,IAC5DU,EAAeC,GAAoBR,EAAQA,SAAaH,IACxDY,EAAkBC,GAAuBV,EAAQA,SAAaH,GAM/Dc,EAAmCC,EAAAA,oBAAoB,CAC3DC,GAAI,eACJC,GAAI,UACJC,GAAI,YAECC,EAAqBC,GAA0BjB,EAAQA,SAAsBW,GACpFO,EAAAA,WAAU,KAERD,EAAuBN,EAAY,GAClC,CAACA,IAGJ,MAAMQ,EAAiBC,SAAuB,MACxCC,EAAeD,SAAuB,MACtCE,EAAkBF,SAAuB,MAEzCG,EAAoBC,GACjBC,KAAKC,MAAMF,EAAQG,cAGtBC,GAAmBJ,GAChBC,KAAKC,MAAMF,EAAQK,wBAAwBC,QAI9CC,UAAEA,IAAcC,EAAAA,UAChBC,GAAsB,QAAdF,GAMRG,GAAgB,CAACC,EAAsBC,IACpC,GAAyC,UALnB,CAACD,GACvBE,EAAiBA,kBAACF,EAAWJ,IAI1BO,CAAuBH,GAAyB,GAAK,MAAMP,GACnEQ,EAAIG,aAIFC,GAAiBJ,GACd,GAAGb,EAAiBa,EAAIG,aAO3BE,GAAsBC,GACnB,CAAClD,EAAeC,GAAekD,QAAQD,IAAW,EAcrDE,GAAwBjC,GACrB,CAAChB,EAAmBC,GAAe+C,QAAQhC,IAAgB,EAG9DkC,GAAmBV,IACvB,OAAQA,GACN,KAAK/C,EACH,OAAOX,EACT,KAAKY,EACH,OAAOX,EACT,KAAKY,EACH,OAAOX,EACV,EAcGmE,GAAsB,CAACX,EAAsBY,KACjD,OAAQZ,GACN,KAAK/C,EACH,OAAOkB,EAAmByC,GAC5B,KAAK1D,EACH,OAAOmB,EAAiBuC,GAC1B,KAAKzD,EACH,OAAOoB,EAAoBqC,GAC9B,EAyBGC,GAAmBb,IACvB,OAAQA,GACN,KAAK/C,EACH,OAAOU,EACT,KAAKT,EACH,OAAOY,EACT,KAAKX,EACH,OAAOa,EACV,EAGG8C,GAAkB,CAACd,EAAsBO,KAC7C,OAAQP,GACN,KAAK/C,EACHW,EAAqB2C,GACrB,MACF,KAAKrD,EACHa,EAAmBwC,GACnB,MACF,KAAKpD,EACHc,EAAsBsC,GAEzB,EA4BGQ,GAAwBf,IAC5B,MAAMxB,EAZqB,CAACwB,IAC5B,OAAQA,GACN,KAAK/C,EACH,OAAOR,EACT,KAAKS,EACH,OAAOR,EACT,KAAKS,EACH,OAAOR,EACV,EAImBqE,CAAqBhB,GACzC,OAAOxB,GAAeK,CAAmB,EAIrCoC,GAAqB,CAACjB,EAAsBC,KAChD,MAAMiB,EAvIkB,CAAClB,GAClBA,IAAc7C,EAsIYgE,CAAkBnB,GACnD,MAxMmB,WAwMfe,GAAqBf,GAGnBkB,EACK,CACLE,QAAS,KACA,CACLC,KAAM,CACJC,UAAWvE,EACXwE,UAAW,UAEbC,GAAI,CACFF,UAAW,GAAGlC,EAAiBa,EAAIG,aACnCmB,UAAW,UAEbE,QAAS,CACPzE,SAAUA,KAIhB0E,QAAS,KACA,CACLL,KAAM,CACJC,UAAW,GAAGlC,EAAiBa,EAAIG,cAErCoB,GAAI,CACFF,UAAWvE,EACXwE,UAAW,UAEbE,QAAS,CACPzE,SAAUA,MAMX,CACLoE,QAAS,KACA,CACLC,KAAM,CACJM,SAAU5E,EACV6E,UAAW,UAEbJ,GAAI,CACFG,SAAU,GAAGlC,GAAgBQ,EAAIG,aACjCwB,UAAW,UAEbH,QAAS,CACPzE,SAAUA,KAIhB0E,QAAS,KACA,CACLL,KAAM,CACJM,SAAU,GAAGlC,GAAgBQ,EAAIG,cAEnCoB,GAAI,CACFG,SAAU5E,EACV6E,UAAW,UAEbH,QAAS,CACPzE,SAAUA,MAShBkE,EACK,CACLE,QAAS,KACA,CACLC,KAAM,CACJQ,WAAYxB,GAAcJ,IAE5BuB,GAAI,CACFK,WAAY9E,GAEd0E,QAAS,CACPzE,SAAUA,KAIhB0E,QAAS,KACA,CACLL,KAAM,CACJQ,WAAY9E,GAEdyE,GAAI,CACFK,WAAYxB,GAAcJ,IAE5BwB,QAAS,CACPzE,SAAUA,MAMX,CACLoE,QAAS,KACA,CACLC,KAAM,CACJS,WAAY/B,GAAcC,EAAWC,IAEvCuB,GAAI,CACFM,WAAY/E,GAEd0E,QAAS,CACPzE,SAAUA,KAIhB0E,QAAS,KACA,CACLL,KAAM,CACJS,WAAY/E,GAEdyE,GAAI,CACFM,WAAY/B,GAAcC,EAAWC,IAEvCwB,QAAS,CACPzE,SAAUA,KAMrB,EAKH,SAAS+E,GAAW/B,EAAsBC,GACxC,MAAM+B,EAAwBtB,GAAgBV,GACxCO,EAASM,GAAgBb,GAC/B,OAAOiC,EAAAA,aAAqC1B,EAAQ,CAClD2B,gBAAiBjB,GAAmBjB,EAAWC,GAC/CkC,mBAAmB,EACnBC,eAAgB,KACV7B,IAAWlD,GACbyD,GAAgBd,EA5VL,QA6VXnD,IAAkB,CAChBmD,UAAWA,EACXqC,OAAO,KAECL,IArLW,CAAChC,IAC5B,OAAQA,GACN,KAAK/C,EACHqF,GAAqB,MACrB,MACF,KAAKpF,EACHqF,GAAmB,MACnB,MACF,KAAKpF,EACHqF,GAAsB,MAEzB,EA2KKC,CAAqBzC,GACrBW,GAAoBX,EAAWtC,GAC/BoD,GAAgBd,EAAWzC,GAC3BV,IAAkB,CAChBmD,UAAWA,EACXqC,OAAO,IAEV,IAEFK,OACJ,CAGD,MAAMJ,GAAuBP,GAAW9E,EAAa+B,GAC/CuD,GAAqBR,GAAW7E,EAAWgC,GAC3CsD,GAAwBT,GAAW5E,EAAcgC,GAGjDwD,GAAcC,YAAU9F,GAI9B,SAAS+F,GAAgB7C,GACvB,MAAMgC,EAAetB,GAAgBV,GAC/B8C,EAAejC,GAAgBb,GACrCjB,EAAAA,WAAU,KAER,GAAI+D,IAAiBvF,GAAoByE,EAQzC,GAAIc,IAAiBvF,GAAmByE,EACtClB,GAAgBd,EAAW5C,OAD7B,CASA,GAAI0F,IAAiB1F,GAAiB4E,EAAc,CAClD,MAAMe,EAlRS,CAAC/C,IACpB,OAAQA,GACN,KAAK/C,EACH,OAAO+B,EACT,KAAK9B,EACH,OAAOgC,EACT,KAAK/B,EACH,OAAOgC,EACV,EA0QqB6D,CAAahD,GACzBiD,EAxQe,CAACjD,IAC1B,OAAQA,GACN,KAAK/C,EACH,OAAOqF,GACT,KAAKpF,EACH,OAAOqF,GACT,KAAKpF,EACH,OAAOqF,GACV,EAgQ2BU,CAAmBlD,GAG3C,OAFAiD,EAAgBF,EAAU3C,cAC1BU,GAAgBd,EAAW3C,EAE5B,CAGGyF,IAAiBzF,GAAiB2E,EACpCrB,GAAoBX,EAjZJ,WAwZbgC,GACHlB,GAAgBd,EAAW1C,EAxB5B,CAyBA,GACA,CAAC0E,EAAcc,EAAc9C,GACjC,CAGD6C,GAAgB5F,GAChB4F,GAAgB3F,GAChB2F,GAAgB1F,GAGhB,MAAMgG,GAAsBC,IAC1BC,GAAcpG,EAAamG,EAAM,EAE7BE,GAAoBF,IACxBC,GAAcnG,EAAWkG,EAAM,EAE3BG,GAAuBH,IAC3BC,GAAclG,EAAciG,EAAM,EAG9BC,GAAgB,CAACrD,EAAsBoD,KACxB,WAAfA,EAAMI,MAEJ/C,GAAqBM,GAAqBf,KACzB,WAAfoD,EAAMI,MACR5G,IAAU,CACRoD,YACAyD,OAAQ,aAIf,GAIGC,QAAEA,GAAOC,OAAEA,IAAWC,EAAiBA,kBAC3CC,EAAwBA,0BAOpBC,GAAiB9D,IACrB,MAAMxB,EAAmCuC,GAAqBf,GACxDY,EAvWoB,CAACZ,IAC3B,OAAQA,GACN,KAAK/C,EACH,OAAOiB,EACT,KAAKhB,EACH,OAAOkB,EACT,KAAKjB,EACH,OAAOmB,EACV,EA+VkByF,CAAoB/D,GACjCgE,EAPmB,CAACpD,GACnBA,IAAelD,EAAeiG,GAAOM,iBAAmBN,GAAOO,kBAM9CC,CAAmBvD,GACrCwD,EAnYyB,CAACpE,IAChC,OAAQA,GACN,KAAK/C,EACH,OAAOqD,GAAmB3C,GAC5B,KAAKT,EACH,OAAOoD,GAAmBxC,GAC5B,KAAKX,EACH,OAAOmD,GAAmBtC,GAC7B,EA2X6BqG,CAAyBrE,IAAc2D,GAAOW,eAC5E,OAAQtE,GACN,KAAK/C,EACH,OAAIuB,IAAgBhB,EACX+G,aAAW,CAChBZ,GAAOa,cACPb,GAAOc,sBACP3E,IAAS6D,GAAOe,mBACf5E,IAAS6D,GAAOgB,mBACjBX,EACAI,IAEO5F,IAAgBf,EAClB8G,aAAW,CAChBZ,GAAOa,cACPb,GAAOiB,uBACP9E,IAAS6D,GAAOe,mBACf5E,IAAS6D,GAAOgB,mBACjBX,EACAI,IAGKG,aAAW,CAChBZ,GAAOkB,aACP/E,IAAS6D,GAAOmB,kBACfhF,IAAS6D,GAAOoB,kBACjBf,EACAI,IAGN,KAAKlH,EACH,OAAIsB,IAAgBhB,EACX+G,aAAW,CAChBZ,GAAOa,cACPb,GAAOc,sBACP3E,IAAS6D,GAAOgB,oBACf7E,IAAS6D,GAAOe,kBACjBV,EACAI,IAEO5F,IAAgBf,EAClB8G,aAAW,CAChBZ,GAAOa,cACPb,GAAOiB,uBACP9E,IAAS6D,GAAOgB,oBACf7E,IAAS6D,GAAOe,kBACjBV,EACAI,IAGKG,aAAW,CAChBZ,GAAOkB,aACP/E,IAAS6D,GAAOoB,mBACfjF,IAAS6D,GAAOmB,iBACjBd,EACAI,IAGN,KAAKjH,EACH,MAAI,CAACM,EAAeD,GAAmBgD,QAAQhC,IAAgB,EACtD+F,EAAAA,WAAW,CAACZ,GAAOa,cAAeb,GAAOqB,oBAAqBhB,IAE9DO,aAAW,CAChBZ,GAAOkB,aACPlB,GAAOsB,mBACPjB,EACAI,IAGP,EAGGc,GAAalF,IAGjB,GAFkBa,GAAgBb,KAAezC,EAG/C,OAAQyC,GACN,KAAK/C,EACH,OACEkI,EACEC,IAAA,MAAA,CAAAnF,IAAKjB,EACLqG,UAAWvB,GAAc7G,GACzBqI,SAAU7E,GAAqBM,GAAqB9D,KAAiB,OAAIsI,EACzEC,UAAWrC,YACVhH,IAGP,KAAKe,EACH,OACEiI,EACEC,IAAA,MAAA,CAAAnF,IAAKf,EACLmG,UAAWvB,GAAc5G,GACzBoI,SAAU7E,GAAqBM,GAAqB9D,KAAiB,OAAIsI,EACzEC,UAAWlC,YACVlH,IAGP,KAAKe,EACH,OACEgI,EACEC,IAAA,MAAA,CAAAnF,IAAKd,EACLkG,UAAWvB,GAAc3G,GACzBmI,SAAU7E,GAAqBM,GAAqB9D,KAAiB,OAAIsI,EACzEC,UAAWjC,YACVlH,IAKX,OAAO,IAAI,EAGb,OACEoJ,EAAAA,KAAK,MAAA,CAAAJ,UAAW3B,MAAaf,GAC1BzG,SAAA,CAAAgJ,GAAUjI,GACXwI,OAAK,MAAA,CAAAJ,UAAW1B,GAAO+B,cAErBxJ,SAAA,CAAAiJ,EAAAC,IAAA,MAAA,CAAKC,UAAW1B,GAAOgC,qBAEpBzJ,IAEFgJ,GAAU/H,MAEZ+H,GAAUhI,KAEb"}