{"version":3,"file":"BaseCardView-f5305415.js","sources":["../../src/PRIVATE_BaseCardView/BaseCardViewItem.tsx","../../src/PRIVATE_BaseCardView/BaseCardViewLayout.tsx","../../src/PRIVATE_BaseCardView/BaseCardViewSkeleton.tsx","../../src/PRIVATE_BaseCardView/BaseCardViewUtils.ts","../../src/PRIVATE_BaseCardView/BaseCardView.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { memo } from 'preact/compat';\nimport { useRef, useCallback, useLayoutEffect, useMemo, StateUpdater } from 'preact/hooks';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { warn } from '../utils/UNSAFE_logger';\nimport { allTabbableElements } from '../utils/PRIVATE_tabbableUtils';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { useAnimation, UseAnimationConfig } from '../hooks/UNSAFE_useAnimation';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport { SelectionMode, ListItemRendererContext } from '../UNSAFE_Collection';\nimport { multiVariantStyles, styles } from './themes/CardGridStyles.css';\nimport { compareListItemContext } from '../utils/PRIVATE_collectionUtils';\n\nexport const ITEM_SELECTOR = '[data-oj-key]';\n\n/**\n * Props for the CardGridItem Component\n */\nexport type Props<K, D> = {\n  children: (context: ListItemRendererContext<K, D>) => ComponentChildren;\n  context: ListItemRendererContext<K, D>;\n  isTabbable: boolean;\n  isFocused: boolean;\n  isFocusRingVisible: boolean;\n  isSelected: boolean;\n  selectionMode: SelectionMode;\n  focusBehavior: 'card' | 'content';\n  setIsFocusBehaviorValid?: StateUpdater<boolean>;\n  initialAnimation?: 'slideUp' | 'slideDown';\n  isGridLayout?: boolean;\n  updateCardSize?: (width: number, height: number) => void;\n};\n\n/**\n * The internal component used to render a single item in CardGrid.\n */\nexport function BaseCardViewItem<K extends string | number, D>({\n  children,\n  context,\n  isTabbable,\n  isFocused,\n  isFocusRingVisible,\n  isSelected,\n  selectionMode,\n  focusBehavior,\n  setIsFocusBehaviorValid,\n  initialAnimation,\n  isGridLayout,\n  updateCardSize\n}: Props<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const itemKey = context.metadata.key;\n  const itemIndex = context.index;\n\n  const isItemFocused = isFocused && isFocusRingVisible;\n  const variantClasses = multiVariantStyles({\n    itemFocused: focusBehavior === 'card' && isItemFocused ? 'isItemFocused' : 'isNotItemFocused',\n    itemInitialOpacity: initialAnimation ? 'isTransparent' : 'isNotTransparent',\n    itemInGridLayout: isGridLayout ? 'isInGridLayout' : 'isNotInGridLayout'\n  });\n  const classes = classNames([styles.itemStyle, variantClasses]);\n\n  // don't bubble Arrow Up/Down/Left/Right events to parent when in isTabbable mode\n  // this bubbling causes the outer CollectionFocus ring to change index while in the isTabbable mode.\n  const handleKeyDown = (event: KeyboardEvent) => {\n    if (\n      focusBehavior === 'card' &&\n      isTabbable &&\n      (event.key === 'ArrowDown' ||\n        event.key === 'ArrowUp' ||\n        event.key === 'ArrowLeft' ||\n        event.key === 'ArrowRight')\n    ) {\n      event.stopPropagation();\n    }\n  };\n\n  const handleResize = useCallback(\n    (entry: ResizeObserverEntry) => {\n      updateCardSize?.(entry.contentRect.width, entry.contentRect.height);\n    },\n    [updateCardSize]\n  );\n\n  const nullRef = useRef<HTMLDivElement>(null);\n  useResizeObserver({ ref: updateCardSize ? rootRef : nullRef, callback: handleResize });\n\n  useLayoutEffect(() => {\n    if (focusBehavior === 'content' && isItemFocused) {\n      // rootRef is cardgrid item, its first child is the focus trap div, so its first grand child\n      // is the actual content\n      const content = rootRef.current?.firstElementChild?.firstElementChild as HTMLElement;\n      const focusable = allTabbableElements(content, true, true);\n      if (focusable.length === 0 || focusable.length > 1) {\n        warn(\n          `${focusable.length} focusable elements are detected in the card. 'content' focusBehavior is intended only for use when the card has single focusable element. Please specify one focusable element in the card or switch the focusBehavior to 'card'.`\n        );\n        setIsFocusBehaviorValid?.(false);\n      } else {\n        focusable[0].focus();\n      }\n    }\n  }, [focusBehavior, isItemFocused, setIsFocusBehaviorValid]);\n\n  // TODO: issue track in JET-57681, we currently have two useAnimation() because the opacity and\n  // slide up/down have different durations, and the current API couldn't handle this case, we will\n  // update this once the API is updated\n\n  // animation for slide up/down\n  const { nodeRef: nodeRefSlide } = useAnimation<'slideUp' | 'slideDown' | 'none', HTMLDivElement>(\n    initialAnimation || 'none',\n    animationConfigSlide(itemIndex)\n  );\n  // animation for opacity change\n  const { nodeRef: nodeRefOpacity } = useAnimation<'opacity' | 'none', HTMLDivElement>(\n    (initialAnimation && 'opacity') || 'none',\n    animationConfigOpacity(itemIndex)\n  );\n\n  const itemRefs = useMemo(() => {\n    // NOTE: spot an issue when we click the cards during animation is processing, the cards would not finish\n    // the current animations and stay as what it is, e.g. leave itself as half transparent.\n    // need to remove nodeRefSlide and nodeRefOpacity to avoid this issue.\n    if (initialAnimation === undefined) {\n      return mergeRefs(rootRef);\n    }\n    return mergeRefs(rootRef, nodeRefSlide, nodeRefOpacity);\n  }, [rootRef, nodeRefSlide, nodeRefOpacity, initialAnimation]);\n\n  return (\n    <div\n      id={useId()}\n      ref={itemRefs}\n      class={classes}\n      role=\"gridcell\"\n      data-oj-key={itemKey}\n      onKeyDown={handleKeyDown}\n      aria-selected={selectionMode === 'none' ? undefined : isSelected}\n      {...(typeof itemKey === 'number' && { 'data-oj-key-type': 'number' })}>\n      <TabbableModeContext.Provider value={{ isTabbable }}>\n        <FocusTrap isDisabled={!isTabbable} restoreFocusRef={false}>\n          {children(context)}\n        </FocusTrap>\n      </TabbableModeContext.Provider>\n    </div>\n  );\n}\n\nconst animationConfigSlide = (\n  index: number\n): UseAnimationConfig<'slideUp' | 'slideDown' | 'none', HTMLDivElement> => {\n  return {\n    animationStates: {\n      slideUp: {\n        from: {\n          translateY: '50px'\n        },\n        to: {\n          translateY: '0px'\n        },\n        options: {\n          duration: 300,\n          delay: index * 50,\n          easing: [0, 0, 0.2, 1]\n        }\n      },\n      slideDown: {\n        from: {\n          translateY: '-50px'\n        },\n        to: {\n          translateY: '0'\n        },\n        options: {\n          duration: 300,\n          delay: index * 50,\n          easing: [0, 0, 0.2, 1]\n        }\n      }\n    },\n    isAnimatedOnMount: true\n  };\n};\n\nconst animationConfigOpacity = (\n  index: number\n): UseAnimationConfig<'opacity' | 'none', HTMLDivElement> => {\n  return {\n    animationStates: {\n      opacity: {\n        from: {\n          opacity: 0\n        },\n        to: {\n          opacity: 1\n        },\n        options: {\n          duration: 150,\n          delay: index * 50,\n          easing: 'linear'\n        }\n      }\n    },\n    isAnimatedOnMount: true\n  };\n};\n\nexport const MemoizeBaseCardViewItem = memo(\n  BaseCardViewItem,\n  <K, D>(prev: Props<K, D>, next: Props<K, D>) => {\n    if (prev && next) {\n      return (\n        prev.children === next.children &&\n        prev.isTabbable === next.isTabbable &&\n        prev.isFocused === next.isFocused &&\n        prev.isFocusRingVisible === next.isFocusRingVisible &&\n        prev.isSelected === next.isSelected &&\n        prev.initialAnimation === next.initialAnimation &&\n        prev.focusBehavior === next.focusBehavior &&\n        compareListItemContext(prev.context, next.context)\n      );\n    }\n    return false;\n  }\n);\n","import { ComponentChildren } from 'preact';\nimport { Grid } from '../UNSAFE_Grid';\nimport { Flex } from '../UNSAFE_Flex';\nimport { Size } from '../utils/UNSAFE_size';\n\ntype Props = {\n  children: ComponentChildren;\n  layout: 'grid' | 'flex';\n  gap: Size;\n  columns: number;\n};\n\nexport function BaseCardViewLayout({ children, layout, gap, columns }: Props) {\n  if (layout === 'grid') {\n    return columns < 1 ? null : (\n      <Grid gridTemplateColumns={`repeat(${columns}, 1fr)`} gap={gap}>\n        {children}\n      </Grid>\n    );\n  } else {\n    return (\n      <Flex wrap=\"wrap\" gap={gap}>\n        {children}\n      </Flex>\n    );\n  }\n}\n","import { Fragment } from 'preact';\nimport { Size } from '../utils/UNSAFE_size';\nimport { Skeleton } from '../UNSAFE_Skeleton';\nimport { LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\n\n// these are arbitrary values by now, might update them with definite values in the future\nconst DEFAULT_SKELETON_NUMBER = 25;\nconst DEFAULT_SKELETON_WIDTH = '60x';\nconst DEFAULT_SKELETON_HEIGHT = '70x';\n\ntype SkeletonProps = {\n  layout: 'flex' | 'grid';\n  colCount: number;\n  totalCount: number;\n  cardWidth?: number;\n  cardHeight?: number;\n};\n\n/**\n * A function that returns an array of skeletons based on count\n * @param count the number of skeletons\n */\nconst getSkeletonsByCount = (\n  layout: 'flex' | 'grid',\n  count = DEFAULT_SKELETON_NUMBER,\n  width?: Size,\n  height?: Size,\n  isUnique = true\n) => {\n  const sw = width || (layout === 'flex' ? DEFAULT_SKELETON_WIDTH : '100%');\n  const sh = height || DEFAULT_SKELETON_HEIGHT;\n\n  return [...Array(count)].map((_v, i) => (\n    // create unique keys if needed, otherwise the animations won't start at the same time, because the old copy of skeletons\n    // could be reused, even the key is specified by useId(), combine count with time to make the key unique.\n    <Skeleton key={isUnique && `${i}${new Date().getTime()}`} width={sw} height={sh} />\n  ));\n};\n\n/**\n * When there is no data (i.e. data is an empty array or null, and hasMore is false), we will show 25 card skeletons with default size\n */\nexport const InitialLoadSkeletons = (props: { layout: SkeletonProps['layout'] }) => (\n  <Fragment>{getSkeletonsByCount(props.layout)}</Fragment>\n);\n\n/**\n * When we are fetching the initial data (i.e. data is an empty array, and hasMore is true), we will show 25 card skeletons with default size,\n * because we don't know the card dimension at this time. Since there is more data to load, we will specify LOADMORE_STYLE_CLASS on skeletons\n */\nexport const DefaultLoadMoreSkeletons = (props: { layout: SkeletonProps['layout'] }) => {\n  const firstSkeleton = (\n    <div class={LOADMORE_STYLE_CLASS}>{getSkeletonsByCount(props.layout, 1)}</div>\n  );\n  const otherSkeletons = getSkeletonsByCount(props.layout, DEFAULT_SKELETON_NUMBER - 1);\n  const skeletons = [firstSkeleton, ...otherSkeletons];\n  return <Fragment>{skeletons}</Fragment>;\n};\n\n/**\n * During the render that we measure and update card dimension, we will hide skeletons temporarily\n * to avoid showing incorrect skeletons\n */\nconst InvisibleSkeletons = () => {\n  return <div class={LOADMORE_STYLE_CLASS}></div>;\n};\n\nexport const LoadMoreSkeletons = (props: SkeletonProps) => {\n  if (props.colCount < 1 || props.cardWidth == null || props.cardHeight == null) {\n    // if column count / card width / card height are invalid, we will show the invisible skeletons\n    return <InvisibleSkeletons />;\n  } else {\n    // after initial renders, show skeletons with correct dimension and count\n    const skeletons = [];\n\n    const firstRowColCount = props.colCount - (props.totalCount % props.colCount);\n    const isOnlyOneRow = firstRowColCount === props.colCount;\n\n    const cardWidth = `calc(${props.cardWidth}px)` as Size;\n    const cardHeight = props.cardHeight\n      ? (`calc(${props.cardHeight}px)` as Size)\n      : DEFAULT_SKELETON_HEIGHT;\n\n    const width: Size = props.layout === 'flex' ? cardWidth : '100%';\n    const height: Size = props.layout === 'flex' || isOnlyOneRow ? cardHeight : '100%';\n\n    // first row\n    const firstSkeleton = (\n      <div class={LOADMORE_STYLE_CLASS}>{getSkeletonsByCount(props.layout, 1, width, height)}</div>\n    );\n    skeletons.push(firstSkeleton);\n    skeletons.push(getSkeletonsByCount(props.layout, firstRowColCount - 1, width, height));\n\n    // second row\n    if (!isOnlyOneRow) {\n      skeletons.push(getSkeletonsByCount(props.layout, props.colCount, width, cardHeight));\n    }\n\n    return <Fragment>{skeletons}</Fragment>;\n  }\n};\n","import { Size } from '../utils/UNSAFE_size';\n\nexport const emptyKeys = { all: false, keys: new Set() };\ntype GutterSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';\n\n/**\n * A mapping of gutterSize to concrete size in pixels\n */\nexport const gutterSizeToPX: Record<string, number> = {\n  xs: 12,\n  sm: 16,\n  md: 24,\n  lg: 48,\n  xl: 64\n};\n\nexport const getGapSize = (gutterSize?: GutterSize) => {\n  const px = gutterSizeToPX[gutterSize || 'sm'];\n  const gap = `${px / 4}x` as Size;\n  return gap;\n};\n\nexport const getColCount = (gapWidth: number, cardWidth?: number, rootWidth?: number) => {\n  if (!cardWidth || !rootWidth) return 0;\n\n  // if we have n cards, we have n-1 gaps\n  const colCount = Math.floor((rootWidth + gapWidth) / (gapWidth + cardWidth));\n  return Math.max(1, colCount);\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Fragment } from 'preact';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { useRef, useCallback, useEffect, useState, useImperativeHandle } from 'preact/hooks';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { containsKey, Keys, isKeyDefined } from '../utils/UNSAFE_keys';\nimport {\n  getPrevNextKeyByCount,\n  getFirstVisibleKey,\n  getViewportConfig,\n  findElementByKey,\n  keyExtractor,\n  handleSelectionRange\n} from '../utils/PRIVATE_collectionUtils';\nimport { useCurrentKey } from '../hooks/PRIVATE_useCurrentKey';\nimport { useCollectionFocusRing } from '../hooks/PRIVATE_useCollectionFocusRing';\nimport { useTabbableModeSet } from '../hooks/PRIVATE_useTabbableModeSet';\nimport { useSelection, SelectionRangeDetail } from '../hooks/PRIVATE_useSelection';\nimport { ItemContext, ListItemRendererContext, SelectionDetail } from '../UNSAFE_Collection';\nimport { Selector } from '../UNSAFE_Selector';\nimport { LoadMoreCollection } from '../PRIVATE_LoadMoreCollection';\nimport { styles } from './themes/CardGridStyles.css';\nimport { Props } from '../UNSAFE_CardFlexView';\nimport { MemoizeBaseCardViewItem, ITEM_SELECTOR } from './BaseCardViewItem';\nimport { BaseCardViewLayout } from './BaseCardViewLayout';\nimport {\n  DefaultLoadMoreSkeletons,\n  LoadMoreSkeletons,\n  InitialLoadSkeletons\n} from './BaseCardViewSkeleton';\nimport { gutterSizeToPX, getGapSize, emptyKeys } from './BaseCardViewUtils';\n\n/**\n * Props specific for the GradGridBaseImpl Component\n */\ntype BaseCardViewImplProps<K, D> = Props<K, D> & {\n  /**\n   * Provide the number of columns to render;\n   */\n  columns: number;\n  /**\n   * The layout of the BaseCardView. When we use CardGridView as parent, we will use grid layout;\n   * when we use CardFlexView as parent, we will use flex layout.\n   */\n  layout: 'grid' | 'flex';\n  /**\n   * Card dimension, including width and height\n   */\n  cardSize: { width?: number; height?: number };\n  /**\n   * A callback function to update card dimension, including width and height\n   */\n  updateCardSize: (width: number, height: number) => void;\n};\n\nconst BaseCardViewImpl = forwardRef(\n  <K extends string | number, D>(\n    {\n      children,\n      data,\n      onLoadMore = () => {},\n      hasMore = false,\n      getRowKey,\n      currentKey,\n      onCurrentKeyChange,\n      selectionMode = 'none',\n      selectedKeys = emptyKeys as Keys<K>,\n      onSelectionChange,\n      viewportConfig,\n      focusBehavior = 'card',\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      initialAnimation = 'slideUp',\n      gutterSize = 'sm',\n      columns,\n      layout,\n      cardSize,\n      updateCardSize\n    }: BaseCardViewImplProps<K, D>,\n    ref?: ForwardedRef<HTMLDivElement>\n  ) => {\n    const rootRef = useRef<HTMLDivElement>(null);\n    useImperativeHandle(ref!, () => rootRef.current!, [rootRef]);\n\n    // tracking the anchor key which is used for shift+click selection\n    const anchorKey = useRef<K | undefined>();\n    // tracking pending current key in pointer down event\n    const pendingCurrentKey = useRef<K>();\n\n    const gap = getGapSize(gutterSize);\n    const gutterSizePX = gutterSizeToPX[gutterSize];\n    const layoutProps = { layout, columns, gap };\n    const isInitialAnimation = useRef(true);\n    useEffect(() => {\n      if (cardSize.height != undefined && cardSize.width != undefined) {\n        isInitialAnimation.current = false;\n      }\n    }, [cardSize]);\n\n    const ariaMultiSelectable = selectionMode === 'none' ? undefined : selectionMode === 'multiple';\n    const ariaRowcount = hasMore || !data || columns < 1 ? -1 : Math.ceil(data?.length / columns);\n    const ariaColcount = columns < 1 ? -1 : columns;\n\n    const [isFocusBehaviorValid, setIsFocusBehaviorValid] = useState(true);\n    const validFocusBehavior = isFocusBehaviorValid ? focusBehavior : 'card';\n\n    /*****************************************************************************************/\n    /************************************* Tabbable Mode *************************************/\n    /*****************************************************************************************/\n\n    const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet(\n      rootRef,\n      (element) => {\n        return keyExtractor(element, ITEM_SELECTOR) as K;\n      },\n      currentKey,\n      onCurrentKeyChange\n    );\n\n    /*****************************************************************************************/\n    /********************************* Current Key and Focus *********************************/\n    /*****************************************************************************************/\n\n    const { currentKeyProps } = useCurrentKey(\n      (element) => keyExtractor(element, ITEM_SELECTOR),\n      selectionMode !== 'multiple',\n      // init a function every time to make sure we pass in the latest columns,\n      // otherwise the new key might be wrong after resize\n      () => getPrevNextKeyByCount(data, getRowKey, currentKey, -columns),\n      () => getPrevNextKeyByCount(data, getRowKey, currentKey, columns),\n      () => getPrevNextKeyByCount(data, getRowKey, currentKey, -1),\n      () => getPrevNextKeyByCount(data, getRowKey, currentKey, 1),\n      currentKey,\n      onCurrentKeyChange\n    );\n\n    const [showFocusRing, focusRingProps] = useCollectionFocusRing(rootRef, [\n      'ArrowUp',\n      'ArrowDown',\n      'ArrowLeft',\n      'ArrowRight'\n    ]);\n\n    const handleInitialFocus = () => {\n      if (\n        !isKeyDefined(currentKey) &&\n        onCurrentKeyChange &&\n        isCurrentTabbableKey(undefined) &&\n        rootRef.current\n      ) {\n        const firstKey =\n          pendingCurrentKey.current || (getFirstVisibleKey(rootRef.current, ITEM_SELECTOR) as K);\n        if (isKeyDefined(firstKey)) {\n          onCurrentKeyChange({ value: firstKey });\n        }\n      }\n    };\n\n    // need to track pointer down element to set currentItem when initial focus happens\n    const handlePointerDown = (event: PointerEvent) => {\n      const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n      if (isKeyDefined(key)) {\n        pendingCurrentKey.current = key as K;\n      }\n    };\n\n    // for content focusBehavior, when users tab out, we need to focus back to card grid, to ensure\n    // the tabbing order works properly, otherwise the focus might get stuck at the current item\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (validFocusBehavior === 'content' && event.key === 'Tab') {\n        rootRef.current?.focus({ preventScroll: true });\n      }\n    };\n\n    useEffect(() => {\n      if (currentKey != null && rootRef.current) {\n        const elem = findElementByKey(rootRef.current, currentKey, ITEM_SELECTOR);\n        if (elem) {\n          // make sure item is visible\n          elem.scrollIntoView({ block: 'nearest' });\n          // only update aria-activedescendant for screen reader in default focusBehavior\n          if (validFocusBehavior === 'card') {\n            const cell = elem.closest(`[role=gridcell]`);\n            if (cell) {\n              rootRef.current.setAttribute('aria-activedescendant', cell.id);\n            }\n          }\n        }\n      }\n      // listen to data because the current item would re-render when data is updated, i.e. the id\n      // of current item would be updated, so the currentKey itself couldn't guarantee the root has\n      // the latest aria-activedescendant\n    }, [currentKey, data, validFocusBehavior]);\n\n    /*****************************************************************************************/\n    /*************************************** Selection ***************************************/\n    /*****************************************************************************************/\n\n    const handleSelectionChange = useCallback(\n      (detail: SelectionDetail<K>) => {\n        if (onSelectionChange) {\n          if (detail.value.all === false && detail.value.keys.size > 0) {\n            // the last key selected by a user gesture is the anchor key\n            anchorKey.current = Array.from(detail.value.keys.values()).pop();\n          }\n          onSelectionChange(detail);\n        }\n      },\n      [anchorKey, onSelectionChange]\n    );\n\n    const handleSelectionRangeChange = useCallback(\n      (detail: SelectionRangeDetail<K>) => {\n        if (data && onSelectionChange) {\n          const value = handleSelectionRange(detail, data, getRowKey);\n          // for non-virtualized CardGrid, value should always be an array\n          if (Array.isArray(value)) {\n            onSelectionChange({ value: { all: false, keys: new Set(value) }, target: null });\n          }\n        }\n      },\n      [data, onSelectionChange, getRowKey]\n    );\n\n    const { selectionProps } = useSelection(\n      (element: HTMLElement) => {\n        if (element === rootRef.current) {\n          return currentKey === undefined ? null : currentKey;\n        }\n        return keyExtractor(element, ITEM_SELECTOR) as K;\n      },\n      selectedKeys,\n      selectionMode,\n      false,\n      'replace',\n      false,\n      handleSelectionChange,\n      anchorKey.current,\n      currentKey,\n      (currentKey: K | undefined, isPrev: boolean) => () =>\n        getPrevNextKeyByCount(data, getRowKey, currentKey, isPrev ? -columns : columns),\n      (currentKey: K | undefined, isPrev: boolean) => () =>\n        getPrevNextKeyByCount(data, getRowKey, currentKey, isPrev ? -1 : 1),\n      (key: K) => {\n        if (rootRef.current) {\n          const elem = findElementByKey(rootRef.current, key, ITEM_SELECTOR);\n          if (elem) {\n            elem.scrollIntoView({ block: 'nearest' });\n          }\n        }\n      },\n      handleSelectionRangeChange\n    );\n\n    /*****************************************************************************************/\n    /************************************ Child Component ************************************/\n    /*****************************************************************************************/\n\n    const getItemContext = useCallback(\n      (context: ItemContext<D>) => {\n        const key = getRowKey(context.data);\n        const selectorRenderer =\n          selectionMode === 'multiple'\n            ? () => (\n                <Selector\n                  onChange={onSelectionChange}\n                  rowKey={key}\n                  selectedKeys={selectedKeys}></Selector>\n              )\n            : undefined;\n\n        return {\n          index: context.index,\n          data: context.data,\n          metadata: { key: key },\n          selector: selectorRenderer,\n          isSelected: containsKey(selectedKeys, key)\n        };\n      },\n      [selectionMode, selectedKeys, onSelectionChange, getRowKey]\n    );\n\n    const childrenComponent = (context: ItemContext<D>) => {\n      const cardItemContext = getItemContext(context);\n      const isTabbable = isCurrentTabbableKey(cardItemContext.metadata.key);\n      const isFocused = currentKey === cardItemContext.metadata.key && !isTabbable;\n      const isFocusRingVisible = isFocused && showFocusRing;\n      const isSelected = cardItemContext.isSelected;\n      const cardGridFunc = (context: ListItemRendererContext<K, D>) => (\n        <MemoizeBaseCardViewItem\n          key={cardItemContext.metadata.key}\n          context={context}\n          isTabbable={isTabbable}\n          isFocused={isFocused}\n          isFocusRingVisible={isFocusRingVisible}\n          isGridLayout={layout === 'grid'}\n          isSelected={isSelected}\n          selectionMode={selectionMode}\n          focusBehavior={validFocusBehavior}\n          {...(focusBehavior === 'content' && { setIsFocusBehaviorValid })}\n          {...(isInitialAnimation.current && { initialAnimation })}\n          {...(cardItemContext.index === 0 && !cardSize.width && { updateCardSize })}>\n          {children}\n        </MemoizeBaseCardViewItem>\n      );\n      return cardGridFunc(cardItemContext);\n    };\n\n    // todo: issue track in JET-57952, need a way to show the skeletons in keyboard navigation\n    const skeletons =\n      data && !data.length && hasMore ? (\n        <DefaultLoadMoreSkeletons layout={layout} />\n      ) : (\n        <LoadMoreSkeletons\n          layout={layout}\n          colCount={columns}\n          totalCount={data?.length || 0}\n          cardWidth={cardSize.width}\n          cardHeight={cardSize.height}\n        />\n      );\n\n    viewportConfig = getViewportConfig(rootRef, viewportConfig);\n    const collectionComponent = (\n      <div role=\"row\">\n        <BaseCardViewLayout {...layoutProps}>\n          <LoadMoreCollection\n            data={data}\n            hasMore={hasMore}\n            onLoadMore={onLoadMore}\n            loadMoreIndicator={skeletons}\n            loadMoreThreshold={gutterSizePX + 4} // gap size + padding\n            viewportConfig={viewportConfig}>\n            {childrenComponent}\n          </LoadMoreCollection>\n        </BaseCardViewLayout>\n      </div>\n    );\n\n    const initialLoadSkeletons = (\n      <BaseCardViewLayout {...layoutProps}>\n        <InitialLoadSkeletons layout={layout} />\n      </BaseCardViewLayout>\n    );\n\n    return (\n      <div\n        {...mergeProps(\n          currentKeyProps,\n          focusRingProps,\n          selectionProps,\n          {\n            onFocus: handleInitialFocus,\n            onPointerDown: handlePointerDown,\n            onKeyDown: handleKeyDown\n          },\n          // only enable tabbable mode in default focusBehavior\n          { ...(validFocusBehavior === 'card' && tabbableModeProps) }\n        )}\n        ref={rootRef}\n        role=\"grid\"\n        class={styles.baseStyle}\n        tabIndex={0}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-multiselectable={ariaMultiSelectable}\n        aria-rowcount={ariaRowcount}\n        aria-colcount={ariaColcount}>\n        {!data ? initialLoadSkeletons : data.length || hasMore ? collectionComponent : <Fragment />}\n      </div>\n    );\n  }\n);\n\n/**\n * Props specific for the BaseCardView\n */\ntype BaseCardViewProps<K, D> = BaseCardViewImplProps<K, D> & {\n  ref?: ForwardedRef<HTMLDivElement>;\n};\n\n/**\n * Cast BaseCardViewImpl to generic type, because BaseCardViewImpl would infer the generic type to specific type,\n * i.e infer <K extends string | number, D> to <string | number, unknown>, which will cause type issues in the parent component\n */\nexport const BaseCardView = BaseCardViewImpl as <K extends string | number, D>(\n  props: BaseCardViewProps<K, D>\n) => JSX.Element;\n"],"names":["ITEM_SELECTOR","animationConfigSlide","index","animationStates","slideUp","from","translateY","to","options","duration","delay","easing","slideDown","isAnimatedOnMount","animationConfigOpacity","opacity","MemoizeBaseCardViewItem","memo","children","context","isTabbable","isFocused","isFocusRingVisible","isSelected","selectionMode","focusBehavior","setIsFocusBehaviorValid","initialAnimation","isGridLayout","updateCardSize","rootRef","useRef","itemKey","metadata","key","itemIndex","isItemFocused","variantClasses","multiVariantStyles","itemFocused","itemInitialOpacity","itemInGridLayout","classes","classNames","styles","itemStyle","handleResize","useCallback","entry","contentRect","width","height","nullRef","useResizeObserver","ref","callback","useLayoutEffect","content","current","firstElementChild","focusable","allTabbableElements","length","warn","focus","nodeRef","nodeRefSlide","useAnimation","nodeRefOpacity","itemRefs","useMemo","undefined","mergeRefs","_jsx","id","useId","class","role","onKeyDown","event","stopPropagation","TabbableModeContext","Provider","value","jsx","FocusTrap","isDisabled","restoreFocusRef","prev","next","compareListItemContext","BaseCardViewLayout","layout","gap","columns","Grid","gridTemplateColumns","Flex","wrap","getSkeletonsByCount","count","isUnique","sw","sh","Array","map","_v","i","Skeleton","Date","getTime","InitialLoadSkeletons","props","Fragment","DefaultLoadMoreSkeletons","skeletons","LOADMORE_STYLE_CLASS","DEFAULT_SKELETON_NUMBER","InvisibleSkeletons","LoadMoreSkeletons","colCount","cardWidth","cardHeight","firstRowColCount","totalCount","isOnlyOneRow","firstSkeleton","push","emptyKeys","all","keys","Set","gutterSizeToPX","xs","sm","md","lg","xl","BaseCardView","forwardRef","data","onLoadMore","hasMore","getRowKey","currentKey","onCurrentKeyChange","selectedKeys","onSelectionChange","viewportConfig","ariaLabel","ariaLabelledBy","gutterSize","cardSize","useImperativeHandle","anchorKey","pendingCurrentKey","getGapSize","gutterSizePX","layoutProps","isInitialAnimation","useEffect","ariaMultiSelectable","ariaRowcount","Math","ceil","ariaColcount","isFocusBehaviorValid","useState","validFocusBehavior","isCurrentTabbableKey","tabbableModeProps","useTabbableModeSet","element","keyExtractor","currentKeyProps","useCurrentKey","getPrevNextKeyByCount","showFocusRing","focusRingProps","useCollectionFocusRing","elem","findElementByKey","scrollIntoView","block","cell","closest","setAttribute","handleSelectionChange","detail","size","values","pop","handleSelectionRangeChange","handleSelectionRange","isArray","target","selectionProps","useSelection","isPrev","getItemContext","selectorRenderer","Selector","onChange","rowKey","selector","containsKey","getViewportConfig","collectionComponent","LoadMoreCollection","loadMoreIndicator","loadMoreThreshold","cardItemContext","cardGridFunc","initialLoadSkeletons","mergeProps","onFocus","isKeyDefined","firstKey","getFirstVisibleKey","onPointerDown","preventScroll","baseStyle","tabIndex","gapWidth","rootWidth","floor","max"],"mappings":"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"}