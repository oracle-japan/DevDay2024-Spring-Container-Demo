{"version":3,"file":"layoutUtils-a2537680.js","sources":["../../src/UNSAFE_Axis/dataAxisInfo.ts","../../src/UNSAFE_Axis/utils/axisUtils.ts","../../src/UNSAFE_Axis/utils/titleUtils.ts","../../src/UNSAFE_Axis/utils/dataAxisUtil.ts","../../src/utils/PRIVATE_chartUtils/dataUtils.ts","../../src/UNSAFE_Axis/timeAxis.ts","../../src/utils/PRIVATE_chartUtils/layoutUtils.ts","../../src/UNSAFE_Axis/groupAxis.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ScaleLog, ScaleLinear } from '../utils/PRIVATE_chartUtils';\nimport { DataAxisInfoProps } from './axis.types';\n\nconst MAX_NUMBER_OF_GRIDS_AUTO = 10;\nconst MINOR_TICK_COUNT = 2;\nconst MAJOR_TICK_INCREMENT_BUFFER = 0.0000000001;\n\nexport class DataAxisInfo {\n  private dataMin!: number;\n  private dataMax!: number;\n  private viewportMin?: number;\n  private viewportMax?: number;\n  private min?: number;\n  private max?: number;\n  private isLog: boolean;\n  private majorTickCount!: number;\n  private minorTickCount!: number;\n  private majorIncrement?: number;\n  private minorIncrement?: number;\n  private minMajorIncrement?: number;\n  private isZeroBaseline: boolean;\n\n  constructor({\n    scale = 'linear',\n    baselineScaling = 'zero',\n    dataMax,\n    dataMin,\n    min,\n    max,\n    viewportMin,\n    viewportMax,\n    ...options\n  }: DataAxisInfoProps) {\n    this.isLog = scale === 'log';\n    this.isZeroBaseline = !this.isLog && baselineScaling === 'zero';\n\n    this.setDataRange(dataMin!, dataMax!);\n    this.setViewportRange(viewportMin, viewportMax, min, max);\n\n    this.majorIncrement = this.actualToLinear(options.step);\n    this.minorIncrement = this.actualToLinear(options.minorStep);\n    this.minMajorIncrement = this.actualToLinear(options.minStep);\n\n    this.calcAxisExtents();\n  }\n\n  /**\n   * Set the dataMin and dataMax.\n   * @param dataMin The minimum of the data.\n   * @param dataMax The maximum of the data.\n   */\n  setDataRange(dataMin: number, dataMax: number) {\n    this.dataMin = this.actualToLinear(dataMin)!;\n    this.dataMax = this.actualToLinear(dataMax)!;\n\n    if (this.isZeroBaseline) {\n      this.dataMin = Math.min(0, this.dataMin);\n      this.dataMax = Math.max(0, this.dataMax!);\n    }\n  }\n\n  setViewportRange(viewportMin?: number, viewportMax?: number, min?: number, max?: number) {\n    this.min = this.actualToLinear(min);\n    this.max = this.actualToLinear(max);\n    this.viewportMin = viewportMin == null ? this.min : this.actualToLinear(viewportMin);\n    this.viewportMax = viewportMax == null ? this.max : this.actualToLinear(viewportMax);\n  }\n\n  setDefaultMin(scaleUnit: number) {\n    // if already set in setViewportRange\n    if (this.min != null) {\n      return;\n    }\n\n    if (this.isZeroBaseline && this.dataMin >= 0) {\n      this.min = 0;\n    } else if (!this.isZeroBaseline && this.max != null) {\n      this.min = this.max - scaleUnit * (Math.floor((this.max - this.dataMin) / scaleUnit) + 1);\n    } else {\n      this.min = (Math.ceil(this.dataMin / scaleUnit) - 1) * scaleUnit;\n    }\n\n    // If all data points are positive, the axis min shouldn't be less than zero\n    if (this.dataMin >= 0 && !this.isLog) {\n      this.min = Math.max(this.min, 0);\n    }\n  }\n\n  setDefaultMax(scaleUnit: number) {\n    if (this.max != null) {\n      return;\n    }\n    if (this.isZeroBaseline && this.dataMax <= 0) {\n      this.max = 0;\n    } else if (!this.isZeroBaseline && this.min != null) {\n      this.max = this.min + scaleUnit * (Math.floor((this.dataMax - this.min) / scaleUnit) + 1);\n    } else {\n      this.max = (Math.floor(this.dataMax / scaleUnit) + 1) * scaleUnit;\n    }\n    // If all data points are negative, the axis max shouldn't be more that zero\n    if (this.dataMax <= 0) {\n      this.max = Math.min(this.max, 0);\n    }\n  }\n\n  calcAxisExtents() {\n    const maxValue = this.max != null ? this.max : this.dataMax;\n    const minValue = this.min != null ? this.min : this.dataMin;\n    const axisStep = this.calcAxisStep(minValue, maxValue);\n    let scaleUnit = this.minMajorIncrement ? Math.max(axisStep, this.minMajorIncrement) : axisStep;\n\n    // If there's only a single value on the axis, we need to adjust the\n    // this.dataMin and this.dataMax to produce a nice looking axis with around 6 ticks.\n    if (this.dataMin === this.dataMax) {\n      if (this.dataMin === 0) {\n        this.dataMax += 5 * scaleUnit;\n      } else {\n        this.dataMin -= 2 * scaleUnit;\n        this.dataMax += 2 * scaleUnit;\n      }\n    }\n\n    this.setDefaultMin(scaleUnit);\n\n    this.setDefaultMax(scaleUnit);\n\n    if (this.max === this.min) {\n      // happens if this.dataMin === this.dataMax === 0\n      this.max = 100;\n      this.min = 0;\n      scaleUnit = (this.max - this.min) / MAX_NUMBER_OF_GRIDS_AUTO;\n    }\n\n    if (\n      (this.viewportMin !== this.min || this.viewportMax !== this.max) &&\n      this.viewportMax != null &&\n      this.viewportMin != null\n    ) {\n      scaleUnit = this.calcAxisStep(this.viewportMin, this.viewportMax);\n    }\n\n    if (this.viewportMin == null) {\n      this.viewportMin = this.min;\n    }\n\n    if (this.viewportMax == null) {\n      this.viewportMax = this.max;\n    }\n\n    this.calcMajorMinorSteps(scaleUnit);\n  }\n\n  /**\n   * Determines the number of major and minor tick counts and increments for the axis if values were not given.\n   * The default minor tick count is 2.\n   * @param {number} scaleUnit The scale unit of the axis.\n   * @private\n   */\n\n  calcMajorMinorSteps(scaleUnit: number) {\n    if (this.max == null || this.min == null) {\n      return;\n    }\n    if (!this.majorIncrement) {\n      if (this.majorTickCount) {\n        this.majorIncrement = (this.viewportMax! - this.viewportMin!) / this.majorTickCount;\n      } else {\n        this.majorIncrement = this.minMajorIncrement\n          ? Math.max(scaleUnit, this.minMajorIncrement!)\n          : scaleUnit;\n      }\n    }\n\n    if (!this.majorTickCount) {\n      this.majorTickCount = (this.viewportMax! - this.viewportMin!) / this.majorIncrement;\n\n      // Check if we have a floating point inaccuracy that causes the tick count to be undercalculated\n      // within the allowable buffer. If so, tick count is supposed to be the rounded up integer.\n      if (Math.ceil(this.majorTickCount) - this.majorTickCount < MAJOR_TICK_INCREMENT_BUFFER) {\n        this.majorTickCount = Math.ceil(this.majorTickCount);\n      }\n    }\n\n    if (!this.minorTickCount) {\n      if (this.minorIncrement) {\n        this.minorTickCount = this.majorIncrement / this.minorIncrement;\n      } else if (this.isLog) {\n        this.minorTickCount = this.majorIncrement;\n      } else {\n        this.minorTickCount = MINOR_TICK_COUNT;\n      }\n    }\n\n    if (!this.minorIncrement) {\n      this.minorIncrement = this.majorIncrement / this.minorTickCount;\n    }\n  }\n\n  calcAxisStep(minValue: number, maxValue: number) {\n    if (this.majorIncrement) {\n      return this.majorIncrement;\n    }\n\n    const spread = maxValue - minValue;\n\n    if (spread === 0) {\n      if (minValue === 0) {\n        return 10;\n      }\n      return Math.pow(10, Math.floor(Math.log10(minValue)) - 1);\n    }\n\n    if (this.isLog) {\n      return Math.floor(spread / 8) + 1;\n    }\n\n    if (this.majorTickCount) {\n      const increment = spread / this.majorTickCount;\n      const testVal = Math.pow(10, Math.ceil(Math.log10(increment) - 1));\n      let firstDigit = increment / testVal;\n      if (firstDigit > 1 && firstDigit <= 1.5) {\n        firstDigit = 1.5;\n      } else if (firstDigit > 5) {\n        firstDigit = 10;\n      } else {\n        firstDigit = Math.ceil(firstDigit);\n      }\n      return firstDigit * testVal;\n    }\n    return this.getDefaultAxisStep(spread);\n  }\n\n  /**\n   * Aesthetically choose a step depending of the spread value.\n   * @param spread The spread of the data values.\n   * @returns The step for the axis.\n   */\n  getDefaultAxisStep(spread: number): number {\n    const t = Math.log10(spread);\n    const testVal = Math.pow(10, Math.ceil(t) - 2);\n    const first2Digits = Math.round(spread / testVal);\n\n    let scaleFactor = 1;\n    if (first2Digits >= 10 && first2Digits <= 14) {\n      scaleFactor = 2;\n    } else if (first2Digits >= 15 && first2Digits <= 19) {\n      scaleFactor = 3;\n    } else if (first2Digits >= 20 && first2Digits <= 24) {\n      scaleFactor = 4;\n    } else if (first2Digits >= 25 && first2Digits <= 45) {\n      scaleFactor = 5;\n    } else if (first2Digits >= 46 && first2Digits <= 80) {\n      scaleFactor = 10;\n    } else {\n      scaleFactor = 20;\n    }\n    return scaleFactor * testVal;\n  }\n\n  linearToActual(value: number) {\n    return this.isLog ? Math.pow(10, value) : value;\n  }\n\n  actualToLinear(value?: number) {\n    if (value == null) {\n      return;\n    }\n\n    if (this.isLog) {\n      return Math.log10(value);\n    }\n    return value;\n  }\n\n  getScale(range: [number, number]) {\n    const { viewportMin, viewportMax } = this.getAxisViewport();\n    const domain: [number, number] = [\n      this.linearToActual(viewportMin),\n      this.linearToActual(viewportMax)\n    ];\n    if (this.isLog) {\n      return new ScaleLog(domain, range);\n    }\n    return new ScaleLinear(domain, range);\n  }\n\n  getFirstTick() {\n    if (this.isZeroBaseline) {\n      return Math.ceil(this.viewportMin! / this.majorIncrement!) * this.majorIncrement!;\n    }\n    return (\n      this.min! +\n      Math.ceil((this.viewportMin! - this.min!) / this.majorIncrement!) * this.majorIncrement!\n    );\n  }\n\n  getAxisViewport() {\n    return {\n      viewportMin: this.viewportMin!,\n      viewportMax: this.viewportMax!\n    };\n  }\n\n  /**\n   * Returns the min and max extent of the axis.\n   */\n  getAxisExtent() {\n    return {\n      min: this.min!,\n      max: this.max!\n    };\n  }\n  /**\n   * Returns the major ticks.\n   */\n  getTicks() {\n    let firstTick = this.getFirstTick();\n    const ticks = [];\n\n    while (firstTick <= this.viewportMax!) {\n      ticks.push(this.linearToActual(firstTick));\n      firstTick += this.majorIncrement!;\n    }\n    return ticks;\n  }\n\n  getMinorTicks() {\n    const coords = [];\n    for (let i = -1; i <= this.majorTickCount; i++) {\n      const value = i * this.majorIncrement! + this.getFirstTick();\n      if (this.isLog && this.majorIncrement == 1 && this.minorIncrement == 1) {\n        // draw linear ticks from 2 to 9\n        for (let j = 2; j <= 9; j++) {\n          const linearValue = value + Math.log10(j);\n          if (linearValue > this.max!) break;\n          if (linearValue < this.min!) continue;\n          coords.push(this.linearToActual(linearValue));\n        }\n      } else {\n        for (let j = 1; j < this.minorTickCount; j++) {\n          const minorValue = value + j * this.minorIncrement!;\n          if (minorValue > this.max!) break;\n          if (minorValue < this.min!) continue;\n\n          coords.push(minorValue);\n        }\n      }\n    }\n    return coords;\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { useTextDimensions } from '../../hooks/PRIVATE_useTextDimensions';\nimport { AxisPosition, DataAxisProps, Dimension } from '../axis.types';\nimport { AXIS_DEFAULTS } from './axisDefaults';\nconst AXIS_MAX_RATIO = 0.3;\ntype GetTextDimensions = NonNullable<ReturnType<typeof useTextDimensions>['getTextDimensions']>;\n\n/**\n * Returns resolved axis position.\n * @param axis\n * @param orientation\n * @param isRtl\n */\nexport function getAxesPosition(\n  yAxis: DataAxisProps | undefined,\n  isHoriz: boolean,\n  isRtl: boolean\n): {\n  xAxisPosition: AxisPosition;\n  yAxisPosition: AxisPosition;\n} {\n  let xAxisPosition, yAxisPosition: AxisPosition;\n\n  if (isHoriz) {\n    yAxisPosition = yAxis?.position === 'top' ? 'top' : 'bottom';\n    xAxisPosition = (isRtl ? 'right' : 'left') as AxisPosition;\n  } else {\n    xAxisPosition = 'bottom' as AxisPosition;\n    const isYEnd = yAxis?.position === 'end';\n    yAxisPosition = isYEnd ? (isRtl ? 'left' : 'right') : isRtl ? 'right' : 'left';\n  }\n  return { xAxisPosition, yAxisPosition };\n}\n\n/**\n * Returns the scale for the axis.\n * @param availSpace\n * @param axisViewportMin\n * @param axisViewportMax\n * @param position\n * @returns\n */\nexport function getAxisRange(\n  availSpace: Dimension,\n  position: 'left' | 'right' | 'top' | 'bottom',\n  isRtl: boolean\n) {\n  const { x, y, width, height } = availSpace;\n  const y2 = y + height;\n  const x2 = x + width;\n\n  let rangeStart: number;\n  let rangeEnd: number;\n\n  if (position === 'left' || position === 'right') {\n    rangeStart = y2;\n    rangeEnd = y;\n  } else {\n    rangeStart = isRtl ? x2 : x;\n    rangeEnd = isRtl ? x : x2;\n  }\n\n  return [rangeStart, rangeEnd];\n}\n\n/**\n * Returns the maximum possible size of the axis.\n * @param availSpace The available space.\n * @param isHoriz If the axis is horizontal.\n * @param axisSize The ratio of axis to the chart.\n * @returns\n */\nexport function getAxisMaxSize(availSpace: Dimension, isHoriz: boolean, axisSize?: number) {\n  const size = Math.max(0, Math.min(1, axisSize != undefined ? axisSize : AXIS_MAX_RATIO));\n  return (isHoriz ? availSpace.height : availSpace.width) * size;\n}\n\n/**\n * Returns the width of a group for given availableSpace, axisposition and axis extents.\n * @param availSpace The available space to render the axis\n * @param position The position of the axis\n * @param min The minimum value of axis coord\n * @param max The maximum value of axis coord\n * @returns\n */\nexport function getGroupWidth(\n  availSpace: { x: number; y: number; width: number; height: number },\n  position: 'left' | 'right' | 'top' | 'bottom',\n  min: number,\n  max: number\n) {\n  const isHoriz = position === 'top' || position === 'bottom';\n  if (isHoriz) {\n    return availSpace.width / (max - min);\n  } else {\n    return availSpace.height / (max - min);\n  }\n}\n\n/**\n * Returns the num of labels to skip safely.\n * @param groupWidth\n * @param tickLabelStyle\n * @param getTextDimensions\n * @returns\n */\nexport function getSafeSkips(\n  groupWidth: number,\n  tickLabelStyle: Partial<CSSStyleDeclaration>,\n  getTextDimensions?: GetTextDimensions\n) {\n  if (!getTextDimensions) {\n    return 0;\n  }\n  const textDims = getTextDimensions('MW', tickLabelStyle as any);\n  const gaps = AXIS_DEFAULTS.labelGap;\n  return Math.floor((0.5 * textDims.width + gaps) / (2 * groupWidth));\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { DvtTextStyle } from '../../utils/UNSAFE_visUtils';\nimport { AxisPosition, Dimension } from '../axis.types';\nimport { AXIS_DEFAULTS } from './axisDefaults';\nimport type { useTextDimensions } from '../../hooks/PRIVATE_useTextDimensions';\ntype GetTextDimensions = NonNullable<ReturnType<typeof useTextDimensions>['getTextDimensions']>;\n\n/**\n * Returns the dimension of the title of the chart.\n * @param getTextDimensions\n * @param availSpace\n * @param isHoriz\n * @param title\n * @param titleStyle\n * @returns\n */\n\nexport function getTitleDimensions(\n  title: string | undefined,\n  titleStyle: DvtTextStyle | undefined,\n  axisMaxDim: number,\n  isHoriz: boolean,\n  getTextDimensions: GetTextDimensions\n) {\n  if (!title || !getTextDimensions) {\n    return { width: 0, height: 0 };\n  }\n  const { width, height } = getTextDimensions(title, titleStyle);\n\n  const titleWidth = isHoriz ? width : height + AXIS_DEFAULTS.titleGap;\n  const titleHeight = isHoriz ? height + AXIS_DEFAULTS.titleGap : width;\n\n  if ((!isHoriz && titleWidth > axisMaxDim) || (isHoriz && titleHeight > axisMaxDim)) {\n    // title does not fit.\n    return { width: 0, height: 0 };\n  }\n  return { width: isHoriz ? width : titleHeight, height: isHoriz ? titleHeight : titleWidth };\n}\n\n/**\n * Returns the (x, y) coordinate of the text given the width and height of the chart.\n * @param position\n * @param availSpace\n * @param textDims\n * @returns\n */\n\nexport const getTitlePos = (\n  position: AxisPosition,\n  availSpace: Dimension,\n  textDims: { width: number; height: number }\n) => {\n  let x: number;\n  let y: number;\n\n  if (position === 'left') {\n    x = availSpace.x + textDims.height / 2;\n    y = availSpace.y + availSpace.height / 2 + textDims.width / 2;\n  } else if (position === 'right') {\n    x = availSpace.x + availSpace.width - textDims.height / 2;\n    y = availSpace.y + availSpace.height / 2 + textDims.width / 2;\n  } else if (position === 'top') {\n    x = availSpace.x + availSpace.width / 2 - textDims.width / 2;\n    y = availSpace.y;\n  } else {\n    x = availSpace.x + availSpace.width / 2 - textDims.width / 2;\n    y = availSpace.y + availSpace.height;\n  }\n  return { x, y };\n};\n\n/**\n * Returns the title props.\n * @param titleStyle\n * @param availSpace\n * @param dims\n * @param position\n * @returns\n */\nexport function getTitleProps(\n  title: string | undefined,\n  titleStyle: Record<string, any>,\n  maxAxisDims: number,\n  availSpace: Dimension,\n  position: AxisPosition,\n  getTextDimensions?: GetTextDimensions\n) {\n  if (!getTextDimensions) {\n    return {\n      width: 0,\n      height: 0\n    };\n  }\n  const isHoriz = position === 'top' || position === 'bottom';\n  const dims = getTitleDimensions(title, titleStyle, maxAxisDims, isHoriz, getTextDimensions);\n  if (dims.width === 0 || dims.height === 0) {\n    return dims;\n  }\n  const { x, y } = getTitlePos(position, availSpace, dims);\n  const isRotated = position === 'left' || position === 'right';\n  const transform = isRotated ? `matrix(0, -1, 1, 0, ${x}, ${y})` : undefined;\n  const titleDims = dims.height;\n\n  if (isRotated) {\n    availSpace.width -= titleDims;\n    availSpace.x += position === 'left' ? titleDims : 0;\n  } else {\n    availSpace.height -= titleDims;\n    availSpace.y += position === 'top' ? titleDims : 0;\n  }\n\n  return {\n    ...dims,\n    x: isRotated ? undefined : x,\n    y: isRotated ? undefined : y,\n    transform: isRotated ? transform : undefined,\n    style: { fill: titleStyle['color'], ...titleStyle }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition, DataAxisProps, Dimension } from '../axis.types';\nimport { DataAxisInfo } from '../dataAxisInfo';\nimport { AXIS_DEFAULTS } from './axisDefaults';\nimport { getAxisMaxSize, getAxisRange } from './axisUtils';\nimport { getLabelDimensions, getMaxTextDimensions, updateLabelsDims } from './labelUtils';\nimport { getTitleProps } from './titleUtils';\nimport type { useTextDimensions } from '../../hooks/PRIVATE_useTextDimensions';\ntype GetTextDimensions = NonNullable<ReturnType<typeof useTextDimensions>['getTextDimensions']>;\n\n/**\n * The function that returns the y axis properties.\n * @param dataAxisInfo The DataAxisInfo.\n * @param dataAxis The dataAxis props.\n * @param groups The chart groups.\n * @param position The position of axis in the given space.\n * @param availSpace The available space.\n * @param isRtl Whether the reading direction is right to left.\n * @param getTextDimensions Function for text measurement.\n * @returns\n */\nexport function getDataAxisProps(\n  position: AxisPosition,\n  availSpace: Dimension,\n  isRtl: boolean,\n  dataAxis?: DataAxisProps,\n  dataAxisInfo?: DataAxisInfo,\n  axisFontSize?: string,\n  getTextDimensions?: GetTextDimensions\n) {\n  const [start, end] = getAxisRange(availSpace, position, isRtl);\n  dataAxisInfo = dataAxisInfo || new DataAxisInfo({ ...dataAxis });\n  const scale = dataAxisInfo.getScale([start, end]);\n\n  const isHoriz = position === 'top' || position === 'bottom';\n  const axisMaxDim = getAxisMaxSize(availSpace, isHoriz, dataAxis?.size);\n  const titleStyle = { fontSize: axisFontSize, ...dataAxis?.titleStyle };\n  const {\n    width: titleWidth,\n    height: titleHeight,\n    ...titleProps\n  } = getTitleProps(\n    dataAxis?.title,\n    titleStyle,\n    axisMaxDim,\n    availSpace,\n    position,\n    getTextDimensions\n  );\n\n  const gap = AXIS_DEFAULTS.labelGap;\n  const isTitleRendered = titleWidth > 0 && titleWidth > 0;\n  const tickLabelStyle = {\n    fontSize: axisFontSize,\n    fill: dataAxis?.tickLabel?.style?.color,\n    ...dataAxis?.tickLabel?.style,\n    textAnchor: position === 'left' ? 'end' : position === 'bottom' ? 'middle' : 'start',\n    dominantBaseline: 'middle'\n  };\n  const ticks = dataAxisInfo.getTicks();\n  const labels = ticks.map((i: number) => i.toString());\n  const getLabelDims = (tick: string, index: number) => {\n    const coord = scale.transform(ticks[index]);\n    return getLabelDimensions(coord, tick, tickLabelStyle, isHoriz, availSpace, getTextDimensions);\n  };\n\n  const { maxWidth, maxHeight, tickLabels } = getMaxTextDimensions(labels, getLabelDims, isHoriz);\n\n  const isLabelRendered = isHoriz\n    ? maxHeight + gap < axisMaxDim - titleHeight\n    : maxWidth + gap < axisMaxDim - titleHeight;\n\n  const getAxisPos = (index: number) => {\n    return scale.transform(ticks[index]);\n  };\n  if (isLabelRendered) {\n    updateLabelsDims(maxWidth, maxHeight, tickLabels, getAxisPos, availSpace, position, isRtl);\n  }\n\n  let axisDim = isLabelRendered ? (isHoriz ? maxHeight + gap : maxWidth + gap) : 0;\n  if (isTitleRendered) {\n    axisDim += titleHeight;\n  }\n  return {\n    title: isTitleRendered ? dataAxis?.title : undefined,\n    titleProps: isTitleRendered ? titleProps : undefined,\n    axisDim,\n    tickLabels,\n    tickLabelStyle,\n    scale\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { DataAxisProps } from '../../UNSAFE_Axis/axis.types';\nimport { ChartItem } from '../../UNSAFE_Chart';\nimport { BarSeries } from '../../UNSAFE_BarChart/barChart.types';\n\n/**\n * Returns the min and max value among the items rendered in the viewport.\n * @param series The array of chart series.\n * @param viewportMin The current viewport min.\n * @param viewportMax The current viewport max.\n * @returns\n */\nexport function getDataMinMax<K extends string | number, D extends ChartItem<K>>(\n  series: BarSeries<K, D>[],\n  xStartIndex: number,\n  xEndIndex: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isStacked: boolean,\n  isLog: boolean,\n  hiddenSet: Set<string | number>,\n  hideAndShowBehavior: 'none' | 'withRescale' | 'withoutRescale'\n) {\n  let dataMin = Number.MAX_VALUE;\n  let dataMax = Number.MIN_VALUE;\n\n  for (let groupIndex = xStartIndex; groupIndex <= xEndIndex; groupIndex++) {\n    let posCumulValue = 0;\n    let negCumulValue = 0;\n\n    series.forEach((_: BarSeries<K, D>, seriesIndex: number) => {\n      const item = getDataItem(seriesIndex, groupIndex);\n      const skipData =\n        item?.id != null && hiddenSet.has(item.id) && hideAndShowBehavior === 'withRescale';\n      if (!item || skipData || (item.value <= 0 && isLog)) return;\n      if (isStacked) {\n        posCumulValue += item.value > 0 ? item.value : 0;\n        negCumulValue += item.value < 0 ? item.value : 0;\n        dataMin = Math.min(isLog ? posCumulValue : negCumulValue, dataMin);\n        dataMax = Math.max(posCumulValue, dataMax);\n      } else {\n        dataMin = Math.min(dataMin, item.value);\n        dataMax = Math.max(dataMax, item.value);\n      }\n    });\n  }\n\n  return { dataMin, dataMax };\n}\n\n/**\n * Returns the dataMin and dataMax, used for axis extend calculations, from the chart data.\n * @param series\n * @param hiddenIds\n * @param xStartIndex\n * @param xEndIndex\n * @param yAxis\n * @returns\n */\nexport function getDataExtent<K extends string | number, D extends ChartItem<K>>(\n  series: BarSeries<K, D>[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  xStartIndex: number,\n  xEndIndex: number,\n  isStacked: boolean,\n  hiddenSet: Set<string | number>,\n  hideAndShowBehavior: 'none' | 'withRescale' | 'withoutRescale',\n  yAxis?: DataAxisProps\n) {\n  let dataMin = yAxis?.dataMin;\n  let dataMax = yAxis?.dataMax;\n\n  if (dataMin != null && dataMax != null) {\n    return { dataMin, dataMax };\n  }\n  const data = getDataMinMax(\n    series,\n    xStartIndex,\n    xEndIndex,\n    getDataItem,\n    isStacked,\n    yAxis?.scale === 'log',\n    hiddenSet,\n    hideAndShowBehavior\n  );\n\n  if (dataMin == null) {\n    dataMin = data.dataMin;\n  }\n\n  if (dataMax == null) {\n    dataMax = data.dataMax;\n  }\n  return { dataMax, dataMin };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition, Dimension, Group, TimeAxisProps } from './axis.types';\nimport { getLocale } from '../utils/UNSAFE_getLocale';\nimport { getAxisMaxSize, getAxisRange, getSafeSkips } from './utils/axisUtils';\nimport { getTitleProps } from './utils/titleUtils';\nimport { ChartItem, ChartSeries } from '../UNSAFE_Chart';\nimport {\n  getLabelDimensions,\n  getMaxTextDimensions,\n  skipLabelsGreedy,\n  updateLabelsDims\n} from './utils/labelUtils';\nimport { AXIS_DEFAULTS } from './utils/axisDefaults';\nimport { useTextDimensions } from '../hooks/PRIVATE_useTextDimensions';\ntype GetTextDimensions = NonNullable<ReturnType<typeof useTextDimensions>['getTextDimensions']>;\n\nconst TIME_SECOND = 1000;\nconst TIME_MINUTE = 60 * TIME_SECOND;\nconst TIME_HOUR = 60 * TIME_MINUTE;\nconst TIME_DAY = 24 * TIME_HOUR;\nconst TIME_MONTH_MIN = 28 * TIME_DAY;\nconst TIME_MONTH_MAX = 31 * TIME_DAY;\nconst TIME_YEAR_MIN = 365 * TIME_DAY;\nconst TIME_YEAR_MAX = 366 * TIME_DAY;\n\nexport function getTimeAxisProps(\n  groups: Group[],\n  position: AxisPosition,\n  availSpace: Dimension,\n  viewportMin: number,\n  viewportMax: number,\n  averageInterval: number,\n  isRtl: boolean,\n  xAxis?: TimeAxisProps,\n  axisFontSize?: string,\n  getTextDimensions?: GetTextDimensions\n) {\n  const isHoriz = position === 'top' || position === 'bottom';\n  const axisMaxDim = getAxisMaxSize(availSpace, isHoriz, xAxis?.size);\n  const titleStyle = { fontSize: axisFontSize, ...xAxis?.titleStyle };\n  const timeAxisType = xAxis?.timeAxisType || 'regular';\n  const {\n    width: titleWidth,\n    height: titleHeight,\n    ...titleProps\n  } = getTitleProps(xAxis?.title, titleStyle, axisMaxDim, availSpace, position, getTextDimensions);\n\n  const isTitleRendered = titleWidth > 0 && titleHeight > 0;\n\n  const [start, end] = getAxisRange(availSpace, position, isRtl);\n\n  const tickLabelStyle = {\n    fontSize: axisFontSize,\n    fill: xAxis?.tickLabel?.style?.color,\n    ...xAxis?.tickLabel?.style,\n    textAnchor: position === 'left' ? 'end' : position === 'bottom' ? 'middle' : 'start',\n    dominantBaseline: 'middle'\n  };\n\n  const valueToCoord = (value: number) =>\n    getCoordFromValue(\n      value,\n      viewportMin,\n      viewportMax,\n      start,\n      end,\n      averageInterval,\n      groups,\n      xAxis?.timeAxisType!\n    );\n\n  const locale = getLocale();\n  let axisStep = xAxis?.step;\n  const gap = AXIS_DEFAULTS.labelGap;\n\n  let times: number[] = [];\n  if (axisStep != null) {\n    times = getLabelPos(viewportMin, viewportMax, axisStep);\n  } else if (timeAxisType === 'mixedFrequency') {\n    axisStep = getMixedFrequencyStep(viewportMax - viewportMin);\n    times = getLabelPos(viewportMin, viewportMax, axisStep);\n  } else {\n    for (let i = 0; i < groups.length; i++) {\n      const date = new Date(groups[i].id).getTime();\n      if (date >= viewportMin && date <= viewportMax) times.push(date);\n    }\n    axisStep = averageInterval;\n  }\n\n  const level1Formatter = Array.isArray(xAxis?.tickLabel?.format)\n    ? xAxis?.tickLabel?.format[0]\n    : xAxis?.tickLabel?.format;\n  const level2Formatter = Array.isArray(xAxis?.tickLabel?.format)\n    ? xAxis?.tickLabel?.format[0]\n    : undefined;\n\n  if (timeAxisType != 'skipGaps') {\n    const granularity = calculateGranularity(axisStep, viewportMax - viewportMin);\n    times = treatMissingValues(times, granularity);\n\n    if (times.length > 1) {\n      // Since the contents of the times array might have been updated, the step value should\n      // be updated.\n      // The step value is approximated to the estimated average of the intervals in the updated\n      // times array.\n      // It is safe to do so even when there were no missing values as it should not have any side-effects\n      // on rendering the axis.\n      // If there are less than 2 values in the times array, proceed with the existing step value.\n      axisStep = (times[times.length - 1] - times[0]) / (times.length - 1);\n    }\n    const label = formatAxisLabel(\n      new Date(times[0] || viewportMin),\n      undefined,\n      !isHoriz,\n      false,\n      locale,\n      granularity,\n      level1Formatter,\n      level2Formatter\n    )[0];\n    const labelDims = getTextDimensions?.(label!, tickLabelStyle);\n    if (labelDims) {\n      const labelDim = isHoriz ? labelDims.width : labelDims.height;\n      const totalWidth =\n        (labelDim + getTickLabelGap(labelDims.height, isHoriz)) * (times.length - 1);\n      if (totalWidth > Math.abs(end - start)) {\n        axisStep = getMixedFrequencyStep(viewportMax - viewportMin);\n        times = getLabelPos(viewportMin, viewportMax, axisStep);\n      }\n    }\n  }\n\n  if (times.length === 0) {\n    times = [viewportMin];\n  }\n\n  const granularity = calculateGranularity(axisStep!, viewportMax - viewportMin);\n\n  const { labelInfos1, labelInfos2 } = generateLabels(\n    times,\n    granularity,\n    valueToCoord,\n    level1Formatter,\n    level2Formatter\n  );\n  const groupWidth = Math.abs(end - start) / times.length;\n\n  const numOfSafeSkips = getSafeSkips(groupWidth, tickLabelStyle, getTextDimensions);\n\n  const getLabel1Dims = (label: string, index: number) => {\n    const rangeValue = labelInfos1[index].coord;\n    return getLabelDimensions(\n      rangeValue,\n      label,\n      tickLabelStyle,\n      isHoriz,\n      availSpace,\n      getTextDimensions\n    );\n  };\n\n  const getLabel2Dims = (label: string, index: number) => {\n    const rangeValue = labelInfos2[index].coord;\n    return getLabelDimensions(\n      rangeValue,\n      label,\n      tickLabelStyle,\n      isHoriz,\n      availSpace,\n      getTextDimensions\n    );\n  };\n\n  const {\n    maxWidth: label1MaxWidth,\n    maxHeight: label1MaxHeight,\n    tickLabels: tickLabels1\n  } = getMaxTextDimensions(\n    labelInfos1.map((i) => i.text),\n    getLabel1Dims,\n    isHoriz,\n    numOfSafeSkips\n  );\n\n  const axisDim = isHoriz ? label1MaxHeight + gap : label1MaxWidth + gap;\n\n  const isLabel1Rendered = isHoriz\n    ? axisDim < axisMaxDim - titleHeight\n    : axisDim < axisMaxDim - titleHeight;\n\n  const {\n    maxWidth: label2MaxWidth,\n    maxHeight: label2MaxHeight,\n    tickLabels: tickLabels2\n  } = skipLabelsGreedy(\n    labelInfos2.map((i) => i.label2),\n    getLabel2Dims,\n    isHoriz\n  );\n\n  const level2AxisDim = isHoriz ? axisDim + label2MaxHeight + gap : axisDim + label2MaxWidth + gap;\n\n  const isLabel2Rendered = isHoriz\n    ? level2AxisDim < axisMaxDim - titleHeight\n    : level2AxisDim < axisMaxDim - titleHeight;\n\n  let tickLabels: any[] = [];\n\n  if (isLabel1Rendered) {\n    const getAxisPos = (index: number) => {\n      return labelInfos1[index].coord;\n    };\n    updateLabelsDims(\n      label1MaxWidth,\n      label1MaxHeight,\n      tickLabels1,\n      getAxisPos,\n      availSpace,\n      position,\n      isRtl\n    );\n    tickLabels = tickLabels.concat(tickLabels1);\n  }\n\n  if (isLabel2Rendered) {\n    const getAxisPos = (index: number) => {\n      return labelInfos2[index].coord;\n    };\n    updateLabelsDims(\n      label2MaxWidth,\n      label2MaxHeight,\n      tickLabels2,\n      getAxisPos,\n      availSpace,\n      position,\n      isRtl\n    );\n    tickLabels.forEach((value) => {\n      value.labelProps.y -= gap + value.labelProps.height;\n    });\n    tickLabels = tickLabels.concat(tickLabels2);\n  }\n\n  const scale = {\n    transform: valueToCoord,\n    range: () => {\n      return [start, end];\n    },\n    domain: () => {\n      return [viewportMin, viewportMax];\n    },\n    invert: (value: number) => {\n      return getCoordFromValue(\n        value,\n        viewportMin,\n        viewportMax,\n        start,\n        end,\n        averageInterval,\n        groups,\n        xAxis?.timeAxisType || 'enabled'\n      );\n    }\n  };\n\n  return {\n    title: isTitleRendered ? xAxis?.title : undefined,\n    titleProps: isTitleRendered ? titleProps : undefined,\n    axisDim: isLabel2Rendered\n      ? level2AxisDim\n      : isLabel1Rendered\n      ? axisDim\n      : isTitleRendered\n      ? titleHeight\n      : 0,\n    scale,\n    tickLabels,\n    groupWidth,\n    tickLabelStyle\n  };\n}\n\n/**\n * Calculates the granularity of the time axis.\n * @param step The step of the axis.\n * @param timeRange The time range of the axis.\n * @returns\n */\nexport function calculateGranularity(step: number, timeRange: number) {\n  if (step >= TIME_YEAR_MIN || timeRange >= 6 * TIME_YEAR_MIN) return TIME_YEAR_MIN;\n\n  if (step >= TIME_MONTH_MIN || timeRange >= 6 * TIME_MONTH_MIN) return TIME_MONTH_MIN;\n\n  if (step >= TIME_DAY || timeRange >= 6 * TIME_DAY) return TIME_DAY;\n\n  if (step >= TIME_HOUR || timeRange >= 6 * TIME_HOUR) return TIME_HOUR;\n\n  if (step >= TIME_MINUTE || timeRange >= 6 * TIME_MINUTE) return TIME_MINUTE;\n\n  return TIME_SECOND;\n}\n\n/**\n * Returns the step for mixed frequency time range.\n * @param timeRange\n * @returns\n */\nexport function getMixedFrequencyStep(timeRange: number) {\n  if (timeRange >= 6 * TIME_YEAR_MIN) return TIME_YEAR_MIN;\n  if (timeRange >= 6 * TIME_MONTH_MIN) return TIME_MONTH_MIN;\n  if (timeRange >= 6 * TIME_DAY) return TIME_DAY;\n  if (timeRange >= TIME_DAY) return 3 * TIME_HOUR;\n  if (timeRange >= 6 * TIME_HOUR) return TIME_HOUR;\n  if (timeRange >= TIME_HOUR) return 15 * TIME_MINUTE;\n  if (timeRange >= 30 * TIME_MINUTE) return 5 * TIME_MINUTE;\n  if (timeRange >= 6 * TIME_MINUTE) return TIME_MINUTE;\n  if (timeRange >= TIME_MINUTE) return 15 * TIME_SECOND;\n  if (timeRange >= 30 * TIME_SECOND) return 5 * TIME_SECOND;\n  return TIME_SECOND;\n}\n\nexport function formatLabelWithFormatter(\n  date: Date,\n  prevDate: Date | undefined,\n  granularity: number,\n  formatter?: (date: number) => string\n) {\n  if (!formatter) {\n    return '';\n  }\n\n  const label = formatter(date.getTime());\n  const prevLabel = prevDate ? formatter?.(prevDate.getTime()) : undefined;\n\n  if (prevLabel !== label || label == null) {\n    return label;\n  }\n  // do not skip label when it is same as prevLabel checking for granularity\n  // for eg. if June and July both convert to 'J' and granularity is TIME_MONTH_MIN, we want to keep both 'J's\n  // for eg. if Saturday and Sunday both convert to 'S' and granularity is TIME_MONTH_DAY, we want to keep both 'S's\n\n  if (granularity === TIME_MONTH_MIN && prevDate?.getMonth() !== date.getMonth()) {\n    return label;\n  }\n\n  if (granularity === TIME_DAY && prevDate?.getDate() != date.getDate()) {\n    return label;\n  }\n\n  return '';\n}\n\nexport function formatAxisLabel(\n  date: Date,\n  prevDate: Date | undefined,\n  bOneLabel: boolean,\n  isVert: boolean,\n  locale: string,\n  granularity: number,\n  label1Formatter?: (date: number) => string,\n  label2Formatter?: (date: number) => string\n) {\n  let label1 = null; // level 1 label\n  let label2 = null; // level 2 label\n\n  // If dateTimeFormatter is used, use it\n  if (label1Formatter || label2Formatter) {\n    if (label1Formatter)\n      label1 = formatLabelWithFormatter(date, prevDate, granularity, label1Formatter);\n    if (label2Formatter)\n      label2 = formatLabelWithFormatter(date, prevDate, granularity, label2Formatter);\n\n    return [label1, label2];\n  }\n\n  if (granularity === TIME_YEAR_MIN) {\n    label1 = formatDate(date, locale, false, false, true); // Year\n  } else if (granularity === TIME_MONTH_MIN) {\n    if (prevDate == null || prevDate.getMonth() != date.getMonth())\n      label1 = formatDate(date, locale, false, true, false); // Month\n\n    if (prevDate == null || prevDate.getFullYear() != date.getFullYear())\n      label2 = formatDate(date, locale, false, false, true); // Year\n  } else if (granularity === TIME_DAY) {\n    if (bOneLabel) {\n      label1 = formatDate(date, locale, true, true, true); // Day, Month, Year\n    } else {\n      if (prevDate == null || prevDate.getDate() != date.getDate())\n        label1 = formatDate(date, locale, true, false, false); // Day\n\n      if (prevDate == null || prevDate.getFullYear() != date.getFullYear())\n        label2 = formatDate(date, locale, false, true, true); // Year, Month\n      else if (prevDate.getMonth() != date.getMonth())\n        label2 = formatDate(date, locale, false, true, false); // Month\n    }\n  } else {\n    if (granularity === TIME_HOUR) {\n      if (prevDate == null || prevDate.getHours() != date.getHours())\n        label1 = formatTime(date, locale, false, false); // HH AM/PM or HH:MM\n    } else if (granularity === TIME_MINUTE) {\n      if (prevDate == null || prevDate.getMinutes() != date.getMinutes())\n        label1 = formatTime(date, locale, true, false); // HH:MM\n    } else {\n      if (prevDate == null || prevDate.getSeconds() != date.getSeconds())\n        label1 = formatTime(date, locale, true, true); // HH:MM:SS\n    }\n\n    if (isVert) {\n      if (prevDate == null || prevDate.getDate() != date.getDate())\n        label2 = formatDate(date, locale, true, true, false); // Month, Day\n    } else {\n      if (prevDate == null || prevDate.getFullYear() != date.getFullYear())\n        label2 = formatDate(date, locale, true, true, true); // Year, Month, Day\n      else if (prevDate.getMonth() != date.getMonth())\n        label2 = formatDate(date, locale, true, true, false); // Month, Day\n      else if (prevDate.getDate() != date.getDate())\n        label2 = formatDate(date, locale, true, false, false); // Day\n    }\n  }\n\n  return [label1, label2];\n}\n\n/**\n * Returns the formatted date string.\n * @param date\n * @param locale\n * @param showDay\n * @param showMonth\n * @param showYear\n * @returns\n */\nexport function formatDate(\n  date: Date,\n  locale: string,\n  showDay: boolean,\n  showMonth: boolean,\n  showYear: boolean\n) {\n  // this function is equivalent to _formatDate present in DvtTimeAxisInfo\n  // replacing the impl to use toLocaleDateString\n\n  const options = {\n    year: showYear ? ('numeric' as const) : undefined,\n    month: showMonth ? ('short' as const) : undefined,\n    day: showDay ? ('numeric' as const) : undefined\n  };\n\n  return date.toLocaleDateString(locale, options);\n}\n\n/**\n * Returns the formatted time string.\n * @param date\n * @param locale\n * @param showMinute\n * @param showSecond\n * @returns\n */\nexport function formatTime(date: Date, locale: string, showMinute: boolean, showSecond: boolean) {\n  // this function is equivalent to _formatDate present in DvtTimeAxisInfo\n  // replacing the impl to use toLocaleDateString\n\n  const options = {\n    hour: '2-digit' as const,\n    minute: showMinute ? ('2-digit' as const) : undefined,\n    second: showSecond ? ('2-digit' as const) : undefined\n  };\n\n  return date.toLocaleTimeString(locale, options);\n}\n\nexport function getLabelPos(start: number, end: number, step: number) {\n  // The time positions has to be at even intervals from the beginning of a year (January 1, 12:00:00 AM), otherwise\n  // we may have labels such as [2013, 2014, 2015, ...] that are drawn at [June 8 2013, June 8 2014, June 8 2015, ...],\n  // which is data misrepresentation.\n  const anchor = new Date(start);\n  const initialTimezoneOffset = anchor.getTimezoneOffset();\n  anchor.setMonth(0, 1); // January 1\n  anchor.setHours(0, 0, 0, 0); // 00:00:00\n  let time = anchor.getTime();\n\n  const times = [];\n  if (step >= TIME_YEAR_MIN && step <= TIME_YEAR_MAX) {\n    // Assume that the step is one year, which can mean different # of days depending on the year\n    while (time < start) time = addOneYear(time);\n    while (time <= end) {\n      times.push(time);\n      time = addOneYear(time);\n    }\n  } else if (step >= TIME_MONTH_MIN && step <= TIME_MONTH_MAX) {\n    // Assume that the step is one month, which can mean different # of days depending on the month\n    while (time < start) time = addOneMonth(time);\n    while (time <= end) {\n      times.push(time);\n      time = addOneMonth(time);\n    }\n  } else {\n    // Bug 26396791. Correction is needed due to daylight savings.\n    // Only apply daylight correction when step is less than a month. Daylight savings does not impact any step higher than month.\n    // JET-52348 - Ideally we should be using Date api to add and substract date offsets to calculate labels since\n    // Date will automatically handle daylight savings. This approach should solve issues for steps greater than month but we could encounter\n    // offsets in axis labels when dataset values are in different daylight savings and chart step is low (eg day or hour);\n    const timezoneCorrection = (initialTimezoneOffset - anchor.getTimezoneOffset()) * 60 * 1000;\n    const correction = step < TIME_MONTH_MIN ? timezoneCorrection : 0;\n    time += Math.ceil((start - time - correction) / step) * step + correction;\n    while (time <= end) {\n      times.push(time);\n      time += step;\n    }\n  }\n  return times;\n}\n\nexport function generateLabels(\n  times: number[],\n  granularity: number,\n  getCoordFromValue: (time: number) => number,\n  label1Formatter?: (time: number) => string,\n  label2Formatter?: (time: number) => string\n) {\n  const locale = getLocale();\n\n  const labelInfos1 = [];\n  const coords1 = [];\n\n  const labelInfos2 = [];\n  const coords2 = [];\n  let isOneLevel = true;\n  let prevDate = undefined;\n  for (let i = 0; i < times.length; i++) {\n    const time = times[i];\n    const coord = getCoordFromValue(time);\n    const date = new Date(time);\n    const [label1, label2] = formatAxisLabel(\n      date,\n      prevDate,\n      false,\n      false,\n      locale,\n      granularity,\n      label1Formatter,\n      label2Formatter\n    );\n    if (label1 != null) {\n      labelInfos1.push({ text: label1, coord });\n      coords1.push(coord);\n    }\n\n    if (label2 != null) {\n      labelInfos2.push({ label2, coord });\n      coords2.push(coord);\n      isOneLevel = false;\n    }\n\n    prevDate = date;\n  }\n  return {\n    labelInfos1,\n    labelInfos2,\n    coords1,\n    coords2,\n    isOneLevel\n  };\n}\n/**\n * Adds the time by one year, e.g. 2014 January 15 -> 2015 January 15 -> ...\n */\nexport function addOneYear(time: number) {\n  const date = new Date(time);\n  date.setFullYear(date.getFullYear() + 1);\n  return date.getTime();\n}\n\n/**\n * Adds the time by one month, e.g. January 15 -> February 15 -> March 15 -> ...\n */\nexport function addOneMonth(time: number) {\n  const date = new Date(time);\n  date.setMonth(date.getMonth() + 1);\n  return date.getTime();\n}\n\n/**\n * Returns the corresponding index for the given time in time axis.\n * @param time The time stamp.\n * @param averageInterval The average interval of the time axis.\n * @param groups The groups array.\n * @returns\n */\nexport function timeToIndex(time: number, averageInterval: number, groups: Group[]) {\n  let endIndex = groups.length;\n  for (let i = 0; i < groups.length; i++) {\n    if (time <= new Date(groups[i].id).getTime()) {\n      endIndex = i;\n      break;\n    }\n  }\n  const startIndex = endIndex - 1;\n\n  const startTime =\n    groups[startIndex] !== undefined\n      ? new Date(groups[startIndex].id).getTime()\n      : new Date(groups[0].id).getTime() - averageInterval;\n  const endTime =\n    groups[endIndex] !== undefined\n      ? new Date(groups[endIndex].id).getTime()\n      : new Date(groups[groups.length - 1].id).getTime() + averageInterval;\n\n  return startIndex + (time - startTime) / (endTime - startTime);\n}\n\n/**\n * Returns the time stamp for given index.\n * @param index The index.\n * @param averageInterval The average interval of the axis.\n * @param groups The groups array.\n * @returns\n */\nexport function indexToTime(index: number, averageInterval: number, groups: Group[]) {\n  const endIndex = Math.min(Math.max(Math.ceil(index), 0), groups.length);\n  const startIndex = endIndex - 1;\n  const startTime =\n    groups[startIndex] !== undefined\n      ? getTime(groups[startIndex].id)\n      : getTime(groups[0].id) - averageInterval;\n  const endTime =\n    groups[endIndex] !== undefined\n      ? getTime(groups[endIndex].id)\n      : getTime(groups[groups.length - 1].id) + averageInterval;\n\n  return startTime + (index - startIndex) * (endTime - startTime);\n}\n\nexport function getTime(uxTime: string) {\n  return new Date(uxTime).getTime();\n}\n\nexport function getCoordFromValue(\n  value: number,\n  minValue: number,\n  maxValue: number,\n  startCoord: number,\n  endCoord: number,\n  averageInterval: number,\n  groups: Group[],\n  timeAxisType: 'skipGaps' | 'mixedFrequency' | 'enabled'\n) {\n  let ratio;\n  if (timeAxisType === 'skipGaps') {\n    const minVal = timeToIndex(minValue, averageInterval, groups);\n    const maxVal = timeToIndex(maxValue, averageInterval, groups);\n    const val = timeToIndex(value, averageInterval, groups);\n    ratio = (val - minVal) / (maxVal - minVal);\n  } else {\n    ratio = (value - minValue) / (maxValue - minValue);\n  }\n\n  return startCoord + ratio * (endCoord - startCoord);\n}\n\nexport function getValueFromCoord(\n  coord: number,\n  startCoord: number,\n  endCoord: number,\n  minValue: number,\n  maxValue: number,\n  averageInterval: number,\n  groups: Group[],\n  timeAxisType: 'skipGaps' | 'enabled' | 'mixedFrequency'\n) {\n  const ratio = (coord - startCoord) / (endCoord - startCoord);\n\n  if (timeAxisType === 'skipGaps') {\n    const minVal = timeToIndex(minValue, averageInterval, groups);\n    const maxVal = timeToIndex(maxValue, averageInterval, groups);\n    return indexToTime(minVal + ratio * (maxVal - minVal), averageInterval, groups);\n  } else return minValue + ratio * (maxValue - minValue);\n}\n\nexport function isoToNumber(dateString?: string) {\n  if (!dateString) {\n    return;\n  }\n  return new Date(dateString).getTime();\n}\n\nexport function getAverageInterval(groups: Group[], start: number, end: number) {\n  if (groups.length > 1) {\n    return (end - start) / (groups.length - 1);\n  } else if (end - start > 0) {\n    return end - start;\n  }\n\n  return 6 * TIME_MINUTE;\n}\n\n/**\n * Returns the time axis info.\n * @param groups The groups array.\n * @param xAxis The xAxis props.\n * @param offset The start and end offset for the axis.\n * @param timeAxisRange The start and end of the time range.\n * @returns\n */\nexport function getTimeAxisInfo(\n  groups: Group[],\n  xAxis: TimeAxisProps = {},\n  offset: number,\n  timeAxisRange: { start: number; end: number }\n) {\n  const { start, end } = timeAxisRange;\n  const averageInterval = (end - start) / (groups.length - 1);\n\n  const axisOffset = offset * averageInterval;\n  const globalMin = start - axisOffset;\n  const globalMax = end + axisOffset;\n\n  const { viewportMin, viewportMax, viewportEndGroup, viewportStartGroup } = xAxis;\n\n  const minValue = isoToNumber((viewportMin || viewportStartGroup) as string) || globalMin;\n  const maxValue = isoToNumber((viewportMax || viewportEndGroup) as string) || globalMax;\n\n  let startIndex = 0;\n  let endIndex = groups.length - 1;\n\n  // TODO: since groups is expected to be sorted, can binary search here\n  groups.forEach((group: Group, index: number) => {\n    const timeStamp = new Date(group.id).getTime();\n\n    if (timeStamp < minValue) {\n      startIndex = index;\n    }\n\n    if (timeStamp < maxValue) {\n      endIndex = index;\n    }\n  });\n\n  return {\n    viewportMin: minValue,\n    viewportMax: maxValue,\n    viewportStartGroup,\n    viewportEndGroup,\n    startIndex,\n    endIndex,\n    min: globalMin,\n    max: globalMax,\n    averageInterval\n  };\n}\n\n/**\n * Returns the maximum of time stamps for the given dataset\n * and time axis type.\n * @param groups The array of groups.\n * @param series The array of series.\n * @param getDataItem The function that returns item for given seriesIndex and groupIndex.\n * @param timeAxisType The time axis type.\n * @returns\n */\nexport function getStartAndEndTime<K extends string | number, D extends ChartItem<K>>(\n  groups: Group[],\n  series: ChartSeries<K, D>[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  timeAxisType?: 'enabled' | 'mixedFrequency' | 'skipGaps'\n) {\n  let start = Number.MAX_VALUE;\n  let end = Number.MIN_VALUE;\n  const numGroups = groups.length;\n\n  if (timeAxisType != 'mixedFrequency') {\n    start = isoToNumber(groups[0].id) as number;\n    end = isoToNumber(groups[numGroups - 1].id) as number;\n  } else {\n    series.forEach((_: ChartSeries<K, D>, seriesIndex: number) => {\n      const firstItem = isoToNumber(getDataItem(seriesIndex, 0)?.x);\n      const lastItem = isoToNumber(getDataItem(seriesIndex, numGroups - 1)?.x);\n      start = firstItem ? Math.min(start, firstItem) : start;\n      end = lastItem ? Math.max(end, lastItem) : end;\n    });\n  }\n\n  return { start, end };\n}\n\n/**\n * Treat missing values when there are large gaps in time axis.\n * @param times\n * @param granularity\n * @returns\n */\nfunction treatMissingValues(times: number[], granularity: number) {\n  let initialInterval;\n  const intervals: Set<number> = new Set();\n  let hasMissingValues = false;\n  let ret = times; // If there are no missing values, the original array will be returned.\n  const intervalsCache = [];\n\n  const timeLength = times.length;\n  let previousDate = new Date(times[0]);\n  for (let i = 1; i < timeLength; i++) {\n    // Calculate the current interval.\n    const currentDate = new Date(times[i]);\n    const currentInterval = calculateGranularInterval(previousDate, currentDate, granularity);\n    previousDate = currentDate;\n\n    // Cache the result so as to not calculate again while filling the missing values\n    // Since the cache is only used for filling in the missing values, and the operation\n    // is performed in the same order as this one, having the cache key in the format\n    // '1546318800000-1514782800000' should be fine.\n    intervalsCache.push(currentInterval);\n\n    // Proceed only if the current interval is greater than the current\n    // granularity level.\n    if (currentInterval <= 0) {\n      continue;\n    }\n\n    // Add the current interval to the set.\n    // The GCD of all the intervals will be used to fill in the missing the\n    // values.\n    intervals.add(currentInterval);\n\n    // During the initial iteration, we will not have any information on intervals,\n    // so, store the current interval and continue.\n    if (!initialInterval) {\n      initialInterval = currentInterval;\n      continue;\n    }\n\n    // Check if the current interval is regular.\n    if (currentInterval !== initialInterval) {\n      hasMissingValues = true;\n    }\n  }\n\n  // If missing values are present, treat them.\n  if (hasMissingValues) {\n    // Get the GCD of intervals and it will be the minimum interval in the new set of times\n    const minimumInterval = getGCDInterval([...intervals]);\n    ret = [];\n    ret.push(times[0]);\n    for (let i = 1; i < timeLength; i++) {\n      const currentValue = times[i];\n      let previousValue = times[i - 1];\n\n      // Retrieve the interval from cache.\n      // As we are looping through the same array the cache will have the interval value\n      // and will never be undefined.\n      const currentInterval = intervalsCache[i - 1];\n\n      // If no values are missing in this interval,\n      // add current value to the return array and continue.\n      // Note: Values are considered missing only when the interval is greater than the current granularity level (minimumInterval).\n      // Example: Jan 1, Jan 15, Feb 1, Mar 1, May 1, Jun 1\n      // Granularity = Month; Minimum Interval = 1 (1 month)\n      // Mar 1, May 1 => has one missing value: Apr\n      // Jan 1, Jan 15 => has no missing value\n      if (currentInterval <= minimumInterval) {\n        ret.push(currentValue);\n        continue;\n      }\n\n      // Calculate the interval at which the values are to be filled\n      const ratioOfCurrentIntervalToMinimumInterval = currentInterval / minimumInterval; // Should be a round number as minimumInterval is a divisor of currentInterval\n      const numMissingValues = ratioOfCurrentIntervalToMinimumInterval - 1;\n      const fillIntervalInMilliseconds = Math.round(\n        (currentValue - previousValue) / ratioOfCurrentIntervalToMinimumInterval\n      );\n\n      // Fill in the missing values\n      for (let j = 1; j <= numMissingValues; j++) {\n        previousValue += fillIntervalInMilliseconds;\n        ret.push(previousValue);\n      }\n      ret.push(currentValue); // Finally, add the current value\n      previousValue = currentValue; // Update the previous value\n    }\n  }\n  return ret;\n}\n\n/**\n * Calculates the granual interval.\n * @param previousDate\n * @param currentDate\n * @param granularity\n * @returns\n */\nfunction calculateGranularInterval(previousDate: Date, currentDate: Date, granularity: number) {\n  // Treat times for the day light savings.\n  const prevTimezoneOffset = previousDate.getTimezoneOffset();\n  const currentTimezoneOffset = currentDate.getTimezoneOffset();\n  const currentTime = currentDate.getTime();\n  const currentTimezoneOffsetCorrection = (prevTimezoneOffset - currentTimezoneOffset) * 1000 * 60;\n  if (currentTimezoneOffsetCorrection > 0) {\n    currentDate.setTime(currentTime + currentTimezoneOffsetCorrection);\n  }\n\n  let granularInterval;\n  if (granularity === TIME_YEAR_MIN)\n    granularInterval = currentDate.getFullYear() - previousDate.getFullYear();\n  else if (granularity === TIME_MONTH_MIN)\n    granularInterval =\n      12 * (currentDate.getFullYear() - previousDate.getFullYear()) +\n      (currentDate.getMonth() - previousDate.getMonth());\n  else\n    granularInterval = Math.round((currentDate.getTime() - previousDate.getTime()) / granularity);\n\n  if (currentTimezoneOffsetCorrection > 0) {\n    currentDate.setTime(currentTime); // reset to original value\n  }\n\n  return granularInterval;\n}\n\n/**\n * Returns the greatest common denominator.\n * @param interval1\n * @param interval2\n * @returns\n */\nfunction gcd(interval1: number, interval2: number): number {\n  if (interval1 === 0) return interval2;\n  return gcd(interval2 % interval1, interval1);\n}\n\n/**\n * Returns the gcd of the intervals.\n * @param intervals\n * @returns\n */\nfunction getGCDInterval(intervals: number[]) {\n  let result = intervals[0];\n  for (let i = 1; i < intervals.length; i++) {\n    result = gcd(result, intervals[i]);\n    if (result === 1) return 1;\n  }\n  return result;\n}\n\n/**\n * Retuns the tick label gap.\n * @param labelHeight The height of the label.\n * @param isHoriz Whether the axis is horizontal.\n * @returns\n */\nfunction getTickLabelGap(labelHeight: number, isHoriz: boolean) {\n  // legacy numbers.\n  return isHoriz ? labelHeight * 0.79 : labelHeight * 0.28;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  DataAxisProps,\n  Dimension,\n  Group,\n  GroupAxisProps,\n  TimeAxisProps\n} from '../../UNSAFE_Axis/axis.types';\nimport { BarSeries } from '../../UNSAFE_BarChart/barChart.types';\nimport { DataAxisInfo } from '../../UNSAFE_Axis/dataAxisInfo';\nimport { getDataAxisProps } from '../../UNSAFE_Axis/utils/dataAxisUtil';\nimport { getDataExtent } from './dataUtils';\nimport { AxisPosition } from '../../UNSAFE_Axis/axis.types';\nimport { getAxesPosition } from '../../UNSAFE_Axis/utils/axisUtils';\nimport { getGroupAxisInfo, getGroupAxisProps } from '../../UNSAFE_Axis/groupAxis';\nimport { ChartItem, ChartSeries, Scale } from '../../UNSAFE_Chart/chart.types';\nimport { getStartAndEndTime, getTimeAxisInfo, getTimeAxisProps } from '../../UNSAFE_Axis/timeAxis';\nimport type { useTextDimensions } from '../../hooks/PRIVATE_useTextDimensions';\ntype GetTextDimensions = NonNullable<ReturnType<typeof useTextDimensions>['getTextDimensions']>;\n\nconst OUTER_GAP_WIDTH = 10;\nconst OUTER_GAP_HEIGHT = 8;\nconst MIN_SCROLL_SIZE = 12;\nconst SCROLL_GAP = 6;\n\n/**\n * Returns the chart layout info.\n * @returns\n */\nexport function getLayoutInfo<K extends string | number, D extends ChartItem<K>>(\n  series: BarSeries<K, D>[],\n  groups: Group[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  xAxis: GroupAxisProps | TimeAxisProps | undefined,\n  yAxis: DataAxisProps | undefined,\n  availSpace: Dimension,\n  hiddenSet: Set<number | string>,\n  hideAndShowBehavior: 'none' | 'withRescale' | 'withoutRescale',\n  isHoriz: boolean,\n  isRtl: boolean,\n  isStacked: boolean,\n  axisFontSize: string,\n  offset: number,\n  getTextDimensions?: GetTextDimensions\n) {\n  const isTimeAxis = (xAxis as TimeAxisProps)?.timeAxisType != null;\n  const { xAxisPosition, yAxisPosition } = getAxesPosition(yAxis, isHoriz, isRtl);\n  let xAxisInfo;\n  if (isTimeAxis) {\n    const timeAxisRange = getStartAndEndTime(\n      groups,\n      series,\n      getDataItem,\n      (xAxis as TimeAxisProps).timeAxisType\n    );\n    xAxisInfo = getTimeAxisInfo(groups, xAxis as TimeAxisProps, offset, timeAxisRange);\n  } else {\n    xAxisInfo = getGroupAxisInfo(groups, xAxis as GroupAxisProps, offset);\n  }\n\n  const { dataMax, dataMin } = getDataExtent(\n    series,\n    getDataItem,\n    xAxisInfo.startIndex,\n    xAxisInfo.endIndex,\n    isStacked,\n    hiddenSet,\n    hideAndShowBehavior,\n    yAxis\n  );\n\n  const yAxisInfo = new DataAxisInfo({ ...yAxis, dataMax, dataMin });\n  const { axisDim: yDim } = getDataAxisProps(\n    yAxisPosition,\n    cloneDimension(availSpace),\n    isRtl,\n    yAxis,\n    yAxisInfo,\n    axisFontSize,\n    getTextDimensions\n  );\n\n  const isXAxisHoriz = xAxisPosition === 'bottom';\n\n  // get updated available space for x axis.\n  const { xSpace: xAvailSpace } = getSpaces(\n    availSpace,\n    xAxisPosition,\n    yAxisPosition,\n    isXAxisHoriz ? availSpace.height : availSpace.width,\n    yDim\n  );\n\n  const {\n    axisDim: xMaxDim,\n    scale: xScale,\n    groupWidth,\n    ...xProps\n  } = isTimeAxis\n    ? getTimeAxisProps(\n        groups,\n        xAxisPosition,\n        xAvailSpace,\n        xAxisInfo.viewportMin,\n        xAxisInfo.viewportMax,\n        // @ts-ignore\n        xAxisInfo.averageInterval,\n        isRtl,\n        xAxis as TimeAxisProps,\n        axisFontSize,\n        getTextDimensions\n      )\n    : getGroupAxisProps(\n        groups,\n        xAxisPosition,\n        xAvailSpace,\n        isRtl,\n        xAxisInfo.viewportMin,\n        xAxisInfo.viewportMax,\n        xAxisInfo.startIndex,\n        xAxisInfo.endIndex,\n        isHoriz,\n        xAxis as GroupAxisProps,\n        axisFontSize,\n        getTextDimensions\n      );\n\n  // recalculate y axis props after the x axis.\n  const { ySpace: newYSpace } = getSpaces(\n    availSpace,\n    xAxisPosition,\n    yAxisPosition,\n    xMaxDim!,\n    isXAxisHoriz ? availSpace.width : availSpace.height\n  );\n\n  const newYProps = getDataAxisProps(\n    yAxisPosition,\n    newYSpace,\n    isRtl,\n    yAxis,\n    yAxisInfo,\n    axisFontSize,\n    getTextDimensions\n  );\n\n  const { axisDim: yMaxDim, scale: yScale, ...yProps } = newYProps;\n\n  const { plotAreaSpace } = getSpaces(availSpace, xAxisPosition, yAxisPosition, xMaxDim!, yMaxDim);\n\n  return {\n    xViewportExtent: { viewportMin: xAxisInfo.viewportMin, viewportMax: xAxisInfo.viewportMax },\n    xIndexExtent: { startIndex: xAxisInfo.startIndex, endIndex: xAxisInfo.endIndex },\n    yViewportExtent: yAxisInfo.getAxisViewport(),\n    yAxisExtent: yAxisInfo.getAxisExtent(),\n    xAxisExtent: { min: xAxisInfo.min, max: xAxisInfo.max },\n    xProps,\n    xScale,\n    xAxisPosition,\n    groupWidth,\n    yProps,\n    yScale,\n    yMaxDim,\n    yAxisPosition,\n    yMajorTicks: yAxisInfo.getTicks(),\n    yMinorTicks: yAxisInfo.getMinorTicks(),\n    plotAreaSpace\n  };\n}\n\n/**\n * Returns the available space for x axis and y axis.\n * @param availSpace The available space of the chart.\n * @param xAxisPosition The position of x axis.\n * @param yAxisPosition The position of y axis.\n * @param xMaxDim The max dimension of x axis.\n * @param yMaxDim The max dimension of y axis.\n * @returns\n */\nexport function getSpaces(\n  availSpace: Dimension,\n  xAxisPosition: AxisPosition,\n  yAxisPosition: AxisPosition,\n  xMaxDim: number,\n  yMaxDim: number\n) {\n  const isXHoriz = xAxisPosition === 'bottom' || xAxisPosition === 'top';\n  const isYLeft = yAxisPosition === 'left';\n\n  let xSpace: Dimension;\n  let ySpace: Dimension;\n  let plotAreaSpace: Dimension;\n\n  if (isXHoriz) {\n    xSpace = getHorizSpace(\n      availSpace,\n      xAxisPosition,\n      isYLeft ? yMaxDim : 0,\n      !isYLeft ? yMaxDim : 0,\n      xMaxDim\n    );\n    ySpace = getVertSpace(\n      availSpace,\n      yAxisPosition as 'left' | 'right',\n      xAxisPosition === 'bottom' ? xMaxDim : 0,\n      xAxisPosition === 'top' ? xMaxDim : 0,\n      yMaxDim\n    );\n    plotAreaSpace = {\n      x: xSpace.x,\n      y: ySpace.y,\n      width: xSpace.width,\n      height: ySpace.height\n    };\n  } else {\n    xSpace = getVertSpace(\n      availSpace,\n      xAxisPosition,\n      yAxisPosition === 'bottom' ? yMaxDim : 0,\n      yAxisPosition === 'bottom' ? 0 : yMaxDim,\n      xMaxDim\n    );\n    ySpace = getHorizSpace(\n      availSpace,\n      yAxisPosition as 'top' | 'bottom',\n      xAxisPosition === 'left' ? xMaxDim : 0,\n      xAxisPosition === 'left' ? 0 : xMaxDim,\n      yMaxDim\n    );\n\n    plotAreaSpace = {\n      x: ySpace.x,\n      y: xSpace.y,\n      width: ySpace.width,\n      height: xSpace.height\n    };\n  }\n\n  return { xSpace, ySpace, plotAreaSpace };\n}\n\n/**\n * Returns the vertical sub section of given available space.\n * @param availSpace The available space.\n * @param position The position of the vertical section.\n * @param bottomOffset The bottom offset of the vertical section.\n * @param topOffset The top offset of the vertical section.\n * @param width The width of the section.\n * @returns\n */\nexport function getVertSpace(\n  availSpace: Dimension,\n  position: 'left' | 'right',\n  bottomOffset: number,\n  topOffset: number,\n  width: number\n) {\n  return {\n    x: position === 'left' ? availSpace.x : availSpace.x + availSpace.width - width,\n    width: width,\n    y: availSpace.y + topOffset,\n    height: availSpace.height - bottomOffset - topOffset\n  };\n}\n\n/**\n * Returns the horizontal sub section of given available space.\n * @param availSpace The available space.\n * @param position The position of the horizontal section.\n * @param leftOffset The left offset of the horizontal section.\n * @param rightOffset The right offset of the horizontal section.\n * @param height The height of the section.\n * @returns\n */\nexport function getHorizSpace(\n  availSpace: Dimension,\n  position: 'top' | 'bottom',\n  leftOffset: number,\n  rightOffset: number,\n  height: number\n) {\n  return {\n    x: availSpace.x + leftOffset,\n    width: availSpace.width - leftOffset - rightOffset,\n    y: position === 'top' ? availSpace.y : availSpace.y + availSpace.height - height,\n    height: height\n  };\n}\n\n/**\n * Returns the outer spacing for the chart.\n * @param width The height of the chart.\n * @param height The width of the chart.\n * @returns\n */\nexport function getOuterGaps(width: number, height: number) {\n  const widthRatio = Math.min(width / 400, 1);\n  const heightRatio = Math.min(height / 300, 1);\n  return {\n    width: widthRatio * OUTER_GAP_WIDTH,\n    height: heightRatio * OUTER_GAP_HEIGHT\n  };\n}\n\n/**\n * Returns the default available space for chart.\n * @param width The width of the chart.\n * @param height The height of the chart.\n * @returns\n */\nexport function getAvailSpace(width: number, height: number) {\n  const gaps = getOuterGaps(width, height);\n  return {\n    width: width - 2 * gaps.width,\n    height: height - 2 * gaps.height,\n    x: gaps.width,\n    y: gaps.height\n  };\n}\n\n/**\n * Clones the given dimension.\n */\nexport function cloneDimension(dims: Dimension) {\n  return {\n    x: dims.x,\n    y: dims.y,\n    height: dims.height,\n    width: dims.width\n  };\n}\n\n/**\n * Retuns the available space for the scrollbar.\n * @param availSpace\n * @param zoomAndScroll\n * @param xAxisPosition\n * @returns\n */\nexport function getScrollBarSpace(\n  availSpace: Dimension,\n  zoomAndScroll: 'live' | 'off',\n  xAxisPosition: AxisPosition\n) {\n  const dims = { x: 0, y: 0, height: 0, width: 0 };\n  const avSpace = cloneDimension(availSpace);\n  if (zoomAndScroll === 'off') {\n    return { scrollDims: dims, availSpace: avSpace };\n  }\n  if (xAxisPosition === 'left') {\n    dims.x = availSpace.x;\n    dims.y = availSpace.y;\n    dims.width = MIN_SCROLL_SIZE;\n    dims.height = availSpace.height;\n\n    avSpace.x += dims.width + SCROLL_GAP;\n    avSpace.width -= dims.width + SCROLL_GAP;\n  } else if (xAxisPosition === 'right') {\n    dims.x = availSpace.x + availSpace.width - MIN_SCROLL_SIZE;\n    dims.width = MIN_SCROLL_SIZE;\n    dims.height = availSpace.height;\n    dims.y = availSpace.y;\n\n    avSpace.width -= dims.width + SCROLL_GAP;\n  } else {\n    dims.x = availSpace.x;\n    dims.y = availSpace.y + availSpace.height - MIN_SCROLL_SIZE;\n    dims.height = MIN_SCROLL_SIZE;\n    dims.width = availSpace.width;\n\n    avSpace.height -= dims.height + SCROLL_GAP;\n  }\n  return { scrollDims: dims, availSpace: avSpace };\n}\n\n/**\n * Updates the scrollbar space\n * @param availSpace\n * @param isHoriz\n * @param yMaxDim\n */\nexport function updateScrollBarSpace(availSpace: Dimension, isHoriz: boolean, yMaxDim: number) {\n  const newDims = cloneDimension(availSpace);\n  if (isHoriz) {\n    newDims.width -= yMaxDim;\n    newDims.x += yMaxDim;\n  } else {\n    newDims.height -= yMaxDim;\n  }\n  return newDims;\n}\n\nexport function findNearestDataPoint<K extends string | number, D extends ChartItem<K>>(\n  sereis: ChartSeries<K, D>[],\n  xScale: Scale,\n  yScale: Scale,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isStacked: boolean,\n  getSeriesDataInfo: (seriesIndex: number) => { offset: number; dataWidth: number },\n  getYCoord: (\n    value: number,\n    yScale: Scale,\n    isStacked: boolean,\n    isLog: boolean,\n    dataItemGaps: number,\n    negCummValue: number,\n    posCummValue: number\n  ) => number,\n  isLog: boolean,\n  dataItemGaps: number,\n  hiddenIds?: Set<number | string>\n) {\n  return (x: number, y: number) => {\n    const neareastGroupIndex = Math.round(x);\n    const groupCenter = xScale.transform(neareastGroupIndex);\n    let posCummValue = 0;\n    let negCummValue = 0;\n\n    let minDistance = Number.MAX_VALUE;\n    let minSeriesIndex = 0;\n    let minSeriesCenter = 0;\n\n    let yCoord;\n\n    for (let seriesIndex = 0; seriesIndex < sereis.length; seriesIndex++) {\n      const item = getDataItem(seriesIndex, neareastGroupIndex);\n      if (!item || hiddenIds?.has(item.id!) || item.value == null || (isLog && item.value <= 0)) {\n        continue;\n      }\n\n      let dist = 0;\n\n      if (!isStacked) {\n        const { offset, dataWidth } = getSeriesDataInfo(seriesIndex);\n        const seriesCenter = offset + groupCenter + dataWidth / 2;\n        dist = Math.abs(xScale.transform(x) - seriesCenter);\n        if (dist < minDistance) {\n          minSeriesCenter = seriesCenter;\n        }\n      } else {\n        const itemY = (item.value < 0 ? negCummValue : posCummValue) + item.value / 2;\n        dist = Math.abs(y - itemY);\n      }\n\n      if (dist < minDistance) {\n        minDistance = dist;\n        minSeriesIndex = seriesIndex;\n        yCoord = getYCoord(\n          item.value,\n          yScale,\n          isStacked,\n          isLog,\n          dataItemGaps,\n          negCummValue,\n          posCummValue\n        );\n      }\n\n      if (isStacked) {\n        posCummValue += item.value > 0 ? item.value : 0;\n        negCummValue += item.value < 0 ? item.value : 0;\n      }\n    }\n    return {\n      seriesIndex: minSeriesIndex,\n      groupIndex: neareastGroupIndex,\n      yCoord,\n      xCoord: isStacked ? groupCenter : minSeriesCenter\n    };\n  };\n}\n\nexport function getGroupCenterCoord<K extends string | number, D extends ChartItem<K>>(\n  group: Group,\n  groupIndex: number,\n  xScale: Scale,\n  item: D,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency'\n) {\n  if (!timeAxisType) {\n    return xScale.transform(groupIndex);\n  } else if (timeAxisType === 'mixedFrequency') {\n    return xScale.transform(new Date(item.x!).getTime());\n  } else {\n    return xScale.transform(new Date(group.id).getTime());\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ScaleLinear } from '../utils/PRIVATE_chartUtils';\nimport { AxisPosition, Dimension, Group, GroupAxisProps } from './axis.types';\nimport { AXIS_DEFAULTS } from './utils/axisDefaults';\nimport { getAxisMaxSize, getAxisRange, getSafeSkips } from './utils/axisUtils';\nimport { getTitleProps } from './utils/titleUtils';\nimport { getLabelDimensions, getMaxTextDimensions, updateLabelsDims } from './utils/labelUtils';\nimport { useTextDimensions } from '../hooks/PRIVATE_useTextDimensions';\ntype GetTextDimensions = NonNullable<ReturnType<typeof useTextDimensions>['getTextDimensions']>;\n\n/**\n * Retuns the groups axis labels.\n * @param groups The groups array.\n * @param startIndex The viewport start index.\n * @param endIndex The viewport end index.\n * @returns\n */\nfunction getGroupAxisLabels(groups: Group[], startIndex: number, endIndex: number) {\n  const ticks = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    ticks.push(groups[i].name || groups[i].id);\n  }\n  return ticks;\n}\n\n/**\n * Retuns the info about group axis.\n * @param groups The groups array.\n * @param xAxis The xAxis props.\n * @param offset The start and end offset for the chart.\n * @returns\n */\nexport function getGroupAxisInfo(groups: Group[], xAxis: GroupAxisProps = {}, offset: number) {\n  let { viewportMin, viewportMax, viewportEndGroup, viewportStartGroup } = xAxis;\n\n  if (viewportMin != null) {\n    viewportStartGroup = groups[Math.max(0, Math.ceil(viewportMin))].id;\n  }\n\n  if (viewportStartGroup != null) {\n    viewportMin = groups.findIndex((value: Group) => value.id === viewportStartGroup);\n  }\n\n  if (viewportMin == null) {\n    viewportMin = -1 * offset;\n    viewportStartGroup = groups[0]?.id;\n  }\n\n  if (viewportMax != null) {\n    viewportEndGroup = groups[Math.min(groups.length - 1, Math.floor(viewportMax))].id;\n  }\n\n  if (viewportEndGroup != null) {\n    viewportMax = groups.findIndex((value: Group) => value.id === viewportEndGroup);\n  }\n\n  if (viewportMax == null) {\n    viewportMax = groups.length - 1 + offset;\n    viewportEndGroup = groups[Math.floor(viewportMax)]?.id;\n  }\n\n  return {\n    min: -1 * offset,\n    max: groups.length - offset,\n    viewportMin,\n    viewportMax,\n    viewportStartGroup,\n    viewportEndGroup,\n    startIndex: Math.max(0, Math.ceil(viewportMin!)),\n    endIndex: Math.min(Math.floor(viewportMax), viewportMax!)\n  };\n}\n\n/**\n * The function that returns the x axis properties.\n * @param groupAxisIno The GroupAxisInfo.\n * @param groupAxis The groupAxis props.\n * @param groups The chart groups.\n * @param position The position of axis in the given space.\n * @param availSpace The available space.\n * @param isRtl Whether the reading direction is right to left.\n * @param getTextDimensions Function for text measurement.\n * @returns\n */\nexport function getGroupAxisProps(\n  groups: Group[],\n  position: AxisPosition,\n  availSpace: Dimension,\n  isRtl: boolean,\n  viewportMin: number,\n  viewportMax: number,\n  startIndex: number,\n  endIndex: number,\n  isDomainFlipped: boolean,\n  groupAxis?: GroupAxisProps,\n  axisFontSize?: string,\n  getTextDimensions?: GetTextDimensions\n) {\n  const isHoriz = position === 'top' || position === 'bottom';\n  const axisMaxDim = getAxisMaxSize(availSpace, isHoriz, groupAxis?.size);\n  const titleStyle = { fontSize: axisFontSize, ...groupAxis?.titleStyle };\n\n  const {\n    width: titleWidth,\n    height: titleHeight,\n    ...titleProps\n  } = getTitleProps(\n    groupAxis?.title,\n    titleStyle,\n    axisMaxDim,\n    availSpace,\n    position,\n    getTextDimensions\n  );\n  const gap = AXIS_DEFAULTS.labelGap;\n  const isTitleRendered = titleWidth > 0 && titleWidth > 0;\n\n  const [start, end] = getAxisRange(availSpace, position, isRtl);\n  const domain: [number, number] = isDomainFlipped\n    ? [viewportMax, viewportMin]\n    : [viewportMin, viewportMax];\n  const scale = new ScaleLinear(domain, [start, end]);\n  const groupWidth = Math.abs(end - start) / (viewportMax - viewportMin);\n\n  const tickLabelStyle = {\n    fontSize: axisFontSize,\n    fill: groupAxis?.tickLabel?.style?.color,\n    ...groupAxis?.tickLabel?.style,\n    textAnchor: position === 'left' ? 'end' : position === 'bottom' ? 'middle' : 'start',\n    dominantBaseline: 'middle'\n  };\n\n  const labelsInView = getGroupAxisLabels(groups, startIndex, endIndex);\n\n  const numOfSafeSkips = getSafeSkips(groupWidth, tickLabelStyle, getTextDimensions);\n\n  const getLabelDims = (label: string, index: number) => {\n    const rangeValue = scale.transform(index + startIndex);\n    return getLabelDimensions(\n      rangeValue,\n      label,\n      tickLabelStyle,\n      isHoriz,\n      availSpace,\n      getTextDimensions\n    );\n  };\n\n  const { maxWidth, maxHeight, tickLabels } = getMaxTextDimensions(\n    labelsInView,\n    getLabelDims,\n    isHoriz,\n    numOfSafeSkips\n  );\n\n  const isLabelRendered = isHoriz\n    ? maxHeight + gap < axisMaxDim - titleHeight\n    : maxWidth + gap < axisMaxDim - titleHeight;\n\n  const getAxisPos = (index: number) => {\n    return scale.transform(startIndex + index);\n  };\n\n  if (isLabelRendered) {\n    updateLabelsDims(maxWidth, maxHeight, tickLabels, getAxisPos, availSpace, position, isRtl);\n  }\n\n  let axisDim = isLabelRendered ? (isHoriz ? maxHeight + gap : maxWidth + gap) : 0;\n  if (isTitleRendered) {\n    axisDim += titleHeight;\n  }\n\n  return {\n    title: isTitleRendered ? groupAxis?.title : undefined,\n    titleProps: isTitleRendered ? titleProps : undefined,\n    tickLabels,\n    tickLabelStyle,\n    axisDim,\n    scale,\n    groupWidth\n  };\n}\n"],"names":["DataAxisInfo","constructor","scale","baselineScaling","dataMax","dataMin","min","max","viewportMin","viewportMax","options","this","isLog","isZeroBaseline","setDataRange","setViewportRange","majorIncrement","actualToLinear","step","minorIncrement","minorStep","minMajorIncrement","minStep","calcAxisExtents","Math","setDefaultMin","scaleUnit","ceil","floor","setDefaultMax","maxValue","minValue","axisStep","calcAxisStep","calcMajorMinorSteps","majorTickCount","minorTickCount","spread","pow","log10","increment","testVal","firstDigit","getDefaultAxisStep","t","first2Digits","round","scaleFactor","linearToActual","value","getScale","range","getAxisViewport","domain","ScaleLog","ScaleLinear","getFirstTick","getAxisExtent","getTicks","firstTick","ticks","push","getMinorTicks","coords","i","j","linearValue","minorValue","AXIS_MAX_RATIO","getAxesPosition","yAxis","isHoriz","isRtl","xAxisPosition","yAxisPosition","position","getAxisRange","availSpace","x","y","width","height","x2","rangeStart","rangeEnd","getAxisMaxSize","axisSize","size","undefined","getSafeSkips","groupWidth","tickLabelStyle","getTextDimensions","textDims","gaps","AXIS_DEFAULTS","labelGap","getTitlePos","getTitleProps","title","titleStyle","maxAxisDims","dims","axisMaxDim","titleWidth","titleGap","titleHeight","getTitleDimensions","isRotated","transform","titleDims","style","fill","getDataAxisProps","dataAxis","dataAxisInfo","axisFontSize","start","end","fontSize","titleProps","gap","isTitleRendered","tickLabel","color","textAnchor","dominantBaseline","labels","map","toString","maxWidth","maxHeight","tickLabels","getMaxTextDimensions","tick","index","coord","getLabelDimensions","isLabelRendered","getAxisPos","updateLabelsDims","axisDim","getDataExtent","series","getDataItem","xStartIndex","xEndIndex","isStacked","hiddenSet","hideAndShowBehavior","data","Number","MAX_VALUE","MIN_VALUE","groupIndex","posCumulValue","negCumulValue","forEach","_","seriesIndex","item","skipData","id","has","getDataMinMax","TIME_SECOND","TIME_MINUTE","TIME_HOUR","TIME_DAY","TIME_MONTH_MIN","TIME_MONTH_MAX","TIME_YEAR_MIN","TIME_YEAR_MAX","getTimeAxisProps","groups","averageInterval","xAxis","timeAxisType","valueToCoord","getCoordFromValue","locale","getLocale","times","getLabelPos","getMixedFrequencyStep","length","date","Date","getTime","level1Formatter","Array","isArray","format","level2Formatter","granularity","calculateGranularity","initialInterval","intervals","Set","hasMissingValues","ret","intervalsCache","timeLength","previousDate","currentDate","currentInterval","calculateGranularInterval","add","minimumInterval","result","gcd","getGCDInterval","currentValue","previousValue","ratioOfCurrentIntervalToMinimumInterval","numMissingValues","fillIntervalInMilliseconds","treatMissingValues","label","formatAxisLabel","labelDims","totalWidth","labelHeight","getTickLabelGap","abs","labelInfos1","labelInfos2","label1Formatter","label2Formatter","coords1","coords2","prevDate","isOneLevel","time","label1","label2","text","generateLabels","numOfSafeSkips","label1MaxWidth","label1MaxHeight","tickLabels1","rangeValue","isLabel1Rendered","label2MaxWidth","label2MaxHeight","tickLabels2","skipLabelsGreedy","level2AxisDim","isLabel2Rendered","concat","labelProps","invert","timeRange","formatLabelWithFormatter","formatter","getMonth","getDate","bOneLabel","isVert","formatDate","getFullYear","getHours","formatTime","getMinutes","getSeconds","showDay","showMonth","showYear","year","month","day","toLocaleDateString","showMinute","showSecond","hour","minute","second","toLocaleTimeString","anchor","initialTimezoneOffset","getTimezoneOffset","setMonth","setHours","addOneYear","addOneMonth","timezoneCorrection","correction","setFullYear","timeToIndex","endIndex","startIndex","startTime","startCoord","endCoord","ratio","minVal","maxVal","isoToNumber","dateString","prevTimezoneOffset","currentTimezoneOffset","currentTime","currentTimezoneOffsetCorrection","granularInterval","setTime","interval1","interval2","OUTER_GAP_WIDTH","OUTER_GAP_HEIGHT","getSpaces","xMaxDim","yMaxDim","isYLeft","xSpace","ySpace","plotAreaSpace","getHorizSpace","getVertSpace","bottomOffset","topOffset","leftOffset","rightOffset","cloneDimension","sereis","xScale","yScale","getSeriesDataInfo","getYCoord","dataItemGaps","hiddenIds","neareastGroupIndex","groupCenter","yCoord","posCummValue","negCummValue","minDistance","minSeriesIndex","minSeriesCenter","dist","itemY","offset","dataWidth","seriesCenter","xCoord","widthRatio","heightRatio","getOuterGaps","group","isTimeAxis","xAxisInfo","timeAxisRange","numGroups","firstItem","lastItem","getStartAndEndTime","axisOffset","globalMin","globalMax","viewportEndGroup","viewportStartGroup","timeStamp","getTimeAxisInfo","findIndex","getGroupAxisInfo","yAxisInfo","yDim","isXAxisHoriz","xAvailSpace","xProps","isDomainFlipped","groupAxis","labelsInView","name","getGroupAxisLabels","getGroupAxisProps","newYSpace","newYProps","yProps","xViewportExtent","xIndexExtent","yViewportExtent","yAxisExtent","xAxisExtent","yMajorTicks","yMinorTicks","zoomAndScroll","avSpace","scrollDims","newDims"],"mappings":"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"}