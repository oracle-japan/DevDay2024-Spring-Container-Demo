{"version":3,"file":"navUtils-a48e6198.js","sources":["../../src/utils/PRIVATE_chartUtils/navUtils.ts","../../src/utils/PRIVATE_chartUtils/accUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ChartItem, ItemInfo, Info } from '../../UNSAFE_Chart';\ntype isItemNavigableType = (seriesIndex: number, groupIndex: number) => boolean;\n\n/**\n * Returns the next navigable item in the same series.\n * @param seriesIndex\n * @param groupIndex\n * @param numOfGroups\n * @returns\n */\nexport function getNextItemInSeries(\n  info: ItemInfo,\n  viewportEndIndex: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const nextGroupIndex = groupIndex + 1;\n\n  if (nextGroupIndex > viewportEndIndex) {\n    return;\n  }\n\n  if (isNavigable(seriesIndex, nextGroupIndex)) {\n    return { seriesIndex, groupIndex: nextGroupIndex };\n  }\n\n  return getNextItemInSeries(\n    {\n      seriesIndex,\n      groupIndex: nextGroupIndex\n    },\n    viewportEndIndex,\n    isNavigable\n  );\n}\n\n/**\n * Returns the previous navigable item in the same series.\n * @param seriesIndex\n * @param itemIndex\n * @returns\n */\nexport function getPrevItemInSeries(\n  info: ItemInfo,\n  viewportStartIndex: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const prevGroupIndex = groupIndex - 1;\n\n  if (prevGroupIndex < viewportStartIndex) {\n    return;\n  }\n\n  if (isNavigable(seriesIndex, prevGroupIndex)) {\n    return { seriesIndex, groupIndex: prevGroupIndex };\n  }\n  if (prevGroupIndex === 0) {\n    return undefined;\n  }\n  return getPrevItemInSeries(\n    { seriesIndex, groupIndex: prevGroupIndex },\n    viewportStartIndex,\n    isNavigable\n  );\n}\n\n/**\n * Returns the previous navigable item in the same group.\n * @param seriesIndex\n * @param groupIndex\n * @param isNavigable\n */\nexport function getPrevItemInGroup(\n  info: ItemInfo,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const prevSeriesIndex = seriesIndex - 1;\n  if (prevSeriesIndex < 0) {\n    return;\n  }\n\n  if (isNavigable(prevSeriesIndex, groupIndex)) {\n    return { seriesIndex: prevSeriesIndex, groupIndex };\n  }\n\n  return getPrevItemInGroup(\n    {\n      seriesIndex: prevSeriesIndex,\n      groupIndex\n    },\n    isNavigable\n  );\n}\n\n/**\n * Returns the next navigable item in the same group.\n * @param seriesIndex\n * @param groupIndex\n * @param numOfSeries\n * @param numOfGroups\n */\nexport function getNextItemInGroup(\n  info: ItemInfo,\n  numOfSeries: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const nextSeriesIndex = seriesIndex + 1;\n\n  if (nextSeriesIndex >= numOfSeries) {\n    return;\n  }\n\n  if (isNavigable(nextSeriesIndex, groupIndex)) {\n    return { seriesIndex: nextSeriesIndex, groupIndex };\n  }\n\n  return getNextItemInGroup(\n    {\n      seriesIndex: nextSeriesIndex,\n      groupIndex\n    },\n    numOfSeries,\n    isNavigable\n  );\n}\n\n/**\n * Returns the next item in the group with higher value than the current item.\n * @param info The ItemInfo of current item.\n * @param numSeries The number of series in the group.\n * @param getDataItem The function that returns the chart data item.\n * @returns\n */\nexport function getNextHigherItemInGroup<K extends string | number, D extends ChartItem<K>>(\n  info: ItemInfo,\n  numSeries: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isItemNavigable: isItemNavigableType\n) {\n  const { groupIndex, seriesIndex } = info;\n  const item = getDataItem(seriesIndex, groupIndex);\n  if (!item) {\n    return info;\n  }\n\n  let minValue = Number.MAX_VALUE;\n  let minIndex = seriesIndex;\n\n  for (let i = 0; i < numSeries; i++) {\n    const itemValue = getDataItem(i, groupIndex)?.value;\n    if (\n      !itemValue ||\n      itemValue < item.value ||\n      !isItemNavigable(i, groupIndex) ||\n      seriesIndex === i\n    ) {\n      continue;\n    }\n    if (itemValue < minValue) {\n      minValue = itemValue;\n      minIndex = i;\n    }\n  }\n  return { seriesIndex: minIndex, groupIndex };\n}\n\n/**\n * Returns the item info of the item in the group with lower value than the current item.\n * @param info The ItemInfo of the current item.\n * @param numSeries The number of series in the group.\n * @param getDataItem The function that returns the chart data item.\n * @returns\n */\nexport function getNextLowerItemInGroup<K extends string | number, D extends ChartItem<K>>(\n  info: ItemInfo,\n  numSeries: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isItemNavigable: isItemNavigableType\n) {\n  const { groupIndex, seriesIndex } = info;\n  const item = getDataItem(seriesIndex, groupIndex);\n  if (!item) {\n    return info;\n  }\n\n  let maxValue = Number.MIN_VALUE;\n  let maxIndex = seriesIndex;\n\n  for (let i = 0; i < numSeries; i++) {\n    const itemValue = getDataItem(i, groupIndex)?.value;\n    if (\n      !itemValue ||\n      itemValue > item.value ||\n      !isItemNavigable(i, groupIndex) ||\n      seriesIndex === i\n    ) {\n      continue;\n    }\n\n    if (itemValue > maxValue) {\n      maxValue = itemValue;\n      maxIndex = i;\n    }\n  }\n  return { seriesIndex: maxIndex, groupIndex };\n}\n\nexport function getLineAreaChartNavUtil<K extends string | number, D extends ChartItem<K>>(\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  numSeries: number,\n  viewportStartIndex: number,\n  viewportEndIndex: number,\n  isStacked: boolean,\n  isRtl: boolean,\n  isHoriz: boolean\n) {\n  const isItemNavigable = (seriesIndex: number, groupIndex: number) => {\n    const barItem = getDataItem(seriesIndex, groupIndex);\n    return Boolean(barItem);\n  };\n\n  const getNextChartItem = (\n    itemInfo: Info,\n    arrow: 'ArrowLeft' | 'ArrowRight' | 'ArrowDown' | 'ArrowUp'\n  ): Info => {\n    let newInfo: Info | undefined;\n\n    const info = {\n      groupIndex: itemInfo.groupIndex!,\n      seriesIndex: itemInfo.seriesIndex!\n    };\n\n    if (info.groupIndex < viewportStartIndex) {\n      info.groupIndex = viewportStartIndex;\n      return info;\n    } else if (info.groupIndex > viewportEndIndex) {\n      info.groupIndex = viewportEndIndex;\n      return info;\n    }\n\n    if (arrow === 'ArrowLeft') {\n      if (!isHoriz) {\n        newInfo = isRtl\n          ? getNextItemInSeries(info, viewportEndIndex, isItemNavigable)\n          : getPrevItemInSeries(info, viewportStartIndex, isItemNavigable);\n      } else {\n        newInfo = isRtl\n          ? getNextHigherItemInGroup(info, numSeries, getDataItem, isItemNavigable)\n          : getNextLowerItemInGroup(info, numSeries, getDataItem, isItemNavigable);\n      }\n    } else if (arrow === 'ArrowRight') {\n      if (!isHoriz) {\n        newInfo = isRtl\n          ? getPrevItemInSeries(info, viewportStartIndex, isItemNavigable)\n          : getNextItemInSeries(info, viewportEndIndex, isItemNavigable);\n      } else {\n        newInfo = !isRtl\n          ? getNextHigherItemInGroup(info, numSeries, getDataItem, isItemNavigable)\n          : getNextLowerItemInGroup(info, numSeries, getDataItem, isItemNavigable);\n      }\n    } else if (arrow === 'ArrowDown') {\n      if (isHoriz) {\n        newInfo = getPrevItemInSeries(info, viewportStartIndex, isItemNavigable);\n      } else {\n        if (isStacked) {\n          newInfo = getPrevItemInGroup(info, isItemNavigable);\n        } else {\n          newInfo = getNextLowerItemInGroup(info, numSeries, getDataItem, isItemNavigable);\n        }\n      }\n    } else {\n      if (isHoriz) {\n        newInfo = getNextItemInSeries(info, viewportEndIndex, isItemNavigable);\n      } else {\n        if (isStacked) {\n          newInfo = getNextItemInGroup(info, numSeries, isItemNavigable);\n        } else {\n          newInfo = getNextHigherItemInGroup(info, numSeries, getDataItem, isItemNavigable);\n        }\n      }\n    }\n    return newInfo || info;\n  };\n\n  return getNextChartItem;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { BundleType } from \"../../resources/nls/bundle\";\n\n/**\n * Returns the aria label for the chart item\n * @param translations The translations bundle.\n * @param series The series of the item.\n * @param group The group of the item.\n * @param value The value of the item.\n * @param isSelected Whether the item is selected.\n * @param isDrillable Whether the item is drillable.\n * @param accessibleLabel The accessible label of the item.\n * @returns \n */\nexport function getItemAriaLabel(\n    translations: BundleType,\n    series: string,\n    group: string,\n    value: number,\n    isSelectionEnabled: boolean,\n    isSelected: boolean,\n    isDrillable: boolean,\n    accessibleLabel?: string,\n) {\n    const seriesLabel = translations.chart_labelSeries();\n    const groupLabel = translations.chart_labelGroup();\n    const valueLabel = translations.chart_labelValue();\n\n    const label = accessibleLabel ||  `${seriesLabel}: ${series}; ${groupLabel}: ${group}; ${valueLabel}: ${value};`\n    const selectedLabel = translations.dataVisualization_stateSelected();\n    const unselectedLabel = translations.dataVisualization_stateUnselected();\n    const drillableLabel = translations.viz_drillable();\n\n    return [\n        label,\n        isSelectionEnabled ? (isSelected ? selectedLabel: unselectedLabel) : '',\n        isDrillable ? drillableLabel: ''\n    ].filter(Boolean).join(' ');\n}"],"names":["getNextItemInSeries","info","viewportEndIndex","isNavigable","seriesIndex","groupIndex","nextGroupIndex","getPrevItemInSeries","viewportStartIndex","prevGroupIndex","getPrevItemInGroup","prevSeriesIndex","getNextItemInGroup","numOfSeries","nextSeriesIndex","getNextHigherItemInGroup","numSeries","getDataItem","isItemNavigable","item","minValue","Number","MAX_VALUE","minIndex","i","itemValue","value","getNextLowerItemInGroup","maxValue","MIN_VALUE","maxIndex","translations","series","group","isSelectionEnabled","isSelected","isDrillable","accessibleLabel","seriesLabel","chart_labelSeries","groupLabel","chart_labelGroup","valueLabel","chart_labelValue","label","selectedLabel","dataVisualization_stateSelected","unselectedLabel","dataVisualization_stateUnselected","drillableLabel","viz_drillable","filter","Boolean","join","isStacked","isRtl","isHoriz","barItem","itemInfo","arrow","newInfo"],"mappings":"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"}